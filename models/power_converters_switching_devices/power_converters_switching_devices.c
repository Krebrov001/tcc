/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * File: power_converters_switching_devices.c
 *
 * Code generated for Simulink model 'power_converters_switching_devices'.
 *
 * Model version                  : 1.1238
 * Simulink Coder version         : 9.1 (R2019a) 23-Nov-2018
 * C/C++ source code generated on : Thu Sep  5 13:33:37 2019
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: Intel->x86-64 (Windows64)
 * Code generation objectives:
 *    1. Execution efficiency
 *    2. RAM efficiency
 * Validation result: Not run
 */

#include "power_converters_switching_devices.h"
#include "power_converters_switching_devices_private.h"

/* Block signals and states (default storage) */
DW rtDW;

/* External outputs (root outports fed by signals with default storage) */
ExtY rtY;

/* Real-time model */
RT_MODEL rtM_;
RT_MODEL *const rtM = &rtM_;
real_T look1_pbinlx(real_T u0, const real_T bp0[], const real_T table[],
                    uint32_T prevIndex[], uint32_T maxIndex)
{
  real_T frac;
  uint32_T iRght;
  uint32_T iLeft;
  uint32_T bpIdx;
  uint32_T found;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'on'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Linear'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Linear'
     Use previous index: 'on'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    bpIdx = 0U;
    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search using Previous Index */
    bpIdx = prevIndex[0U];
    iLeft = 0U;
    iRght = maxIndex;
    found = 0U;
    while (found == 0U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx - 1U;
        bpIdx = (iRght + iLeft) >> 1U;
      } else if (u0 < bp0[bpIdx + 1U]) {
        found = 1U;
      } else {
        iLeft = bpIdx + 1U;
        bpIdx = (iRght + iLeft) >> 1U;
      }
    }

    frac = (u0 - bp0[bpIdx]) / (bp0[bpIdx + 1U] - bp0[bpIdx]);
  } else {
    bpIdx = maxIndex - 1U;
    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);
  }

  prevIndex[0U] = bpIdx;

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'wrapping'
   */
  return (table[bpIdx + 1U] - table[bpIdx]) * frac + table[bpIdx];
}

/*
 * Output and update for enable system:
 *    '<S209>/Subsystem - pi//2 delay'
 *    '<S222>/Subsystem - pi//2 delay'
 *    '<S228>/Subsystem - pi//2 delay'
 *    '<S243>/Subsystem - pi//2 delay'
 *    '<S288>/Subsystem - pi//2 delay'
 *    '<S301>/Subsystem - pi//2 delay'
 *    '<S307>/Subsystem - pi//2 delay'
 *    '<S322>/Subsystem - pi//2 delay'
 */
void Subsystempi2delay(uint8_T rtu_Enable, const real_T rtu_alpha_beta[2],
  real_T rtu_wt, real_T *rty_dq, real_T *rty_dq_d)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S209>/Subsystem - pi//2 delay' incorporates:
   *  EnablePort: '<S213>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S213>/Fcn' incorporates:
     *  Fcn: '<S213>/Fcn1'
     */
    tmp = cos(rtu_wt);
    tmp_0 = sin(rtu_wt);
    *rty_dq = rtu_alpha_beta[0] * tmp_0 - rtu_alpha_beta[1] * tmp;

    /* Fcn: '<S213>/Fcn1' */
    *rty_dq_d = rtu_alpha_beta[0] * tmp + rtu_alpha_beta[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S209>/Subsystem - pi//2 delay' */
}

/*
 * Output and update for enable system:
 *    '<S209>/Subsystem1'
 *    '<S222>/Subsystem1'
 *    '<S228>/Subsystem1'
 *    '<S243>/Subsystem1'
 *    '<S288>/Subsystem1'
 *    '<S301>/Subsystem1'
 *    '<S307>/Subsystem1'
 *    '<S322>/Subsystem1'
 */
void Subsystem1(uint8_T rtu_Enable, const real_T rtu_alpha_beta[2], real_T
                rtu_wt, real_T *rty_dq, real_T *rty_dq_h)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S209>/Subsystem1' incorporates:
   *  EnablePort: '<S214>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S214>/Fcn' incorporates:
     *  Fcn: '<S214>/Fcn1'
     */
    tmp = sin(rtu_wt);
    tmp_0 = cos(rtu_wt);
    *rty_dq = rtu_alpha_beta[0] * tmp_0 + rtu_alpha_beta[1] * tmp;

    /* Fcn: '<S214>/Fcn1' */
    *rty_dq_h = -rtu_alpha_beta[0] * tmp + rtu_alpha_beta[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S209>/Subsystem1' */
}

/*
 * Output and update for enable system:
 *    '<S250>/Subsystem - pi//2 delay'
 *    '<S329>/Subsystem - pi//2 delay'
 */
void Subsystempi2delay_l(uint8_T rtu_Enable, const real_T rtu_dq[2], real_T
  rtu_wt, real_T *rty_alpha_beta, real_T *rty_alpha_beta_o)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S250>/Subsystem - pi//2 delay' incorporates:
   *  EnablePort: '<S253>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S253>/Fcn' incorporates:
     *  Fcn: '<S253>/Fcn1'
     */
    tmp = cos(rtu_wt);
    tmp_0 = sin(rtu_wt);
    *rty_alpha_beta = rtu_dq[0] * tmp_0 + rtu_dq[1] * tmp;

    /* Fcn: '<S253>/Fcn1' */
    *rty_alpha_beta_o = -rtu_dq[0] * tmp + rtu_dq[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S250>/Subsystem - pi//2 delay' */
}

/*
 * Output and update for enable system:
 *    '<S250>/Subsystem1'
 *    '<S329>/Subsystem1'
 */
void Subsystem1_i(uint8_T rtu_Enable, const real_T rtu_dq[2], real_T rtu_wt,
                  real_T *rty_alpha_beta, real_T *rty_alpha_beta_m)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S250>/Subsystem1' incorporates:
   *  EnablePort: '<S254>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S254>/Fcn' incorporates:
     *  Fcn: '<S254>/Fcn1'
     */
    tmp = sin(rtu_wt);
    tmp_0 = cos(rtu_wt);
    *rty_alpha_beta = rtu_dq[0] * tmp_0 - rtu_dq[1] * tmp;

    /* Fcn: '<S254>/Fcn1' */
    *rty_alpha_beta_m = rtu_dq[0] * tmp + rtu_dq[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S250>/Subsystem1' */
}

/*
 * Output and update for enable system:
 *    '<S402>/Neg. Seq. Computation'
 *    '<S403>/Neg. Seq. Computation'
 *    '<S452>/Neg. Seq. Computation'
 *    '<S453>/Neg. Seq. Computation'
 *    '<S32>/Neg. Seq. Computation'
 */
void NegSeqComputation(real_T rtu_Enable, creal_T rtu_In, creal_T rtu_In_o,
  creal_T rtu_In_j, creal_T *rty_Out)
{
  /* Outputs for Enabled SubSystem: '<S402>/Neg. Seq. Computation' incorporates:
   *  EnablePort: '<S407>/Enable'
   */
  if (rtu_Enable > 0.0) {
    /* Gain: '<S407>/Gain3' incorporates:
     *  Gain: '<S407>/Gain1'
     *  Sum: '<S407>/Sum'
     */
    rty_Out->re = (((rtu_In.re - 0.0 * rtu_In.im) + (-0.49999999999999978 *
      rtu_In_o.re - -0.86602540378443871 * rtu_In_o.im)) + (-0.49999999999999978
      * rtu_In_j.re - 0.86602540378443871 * rtu_In_j.im)) * 0.33333333333333331;
    rty_Out->im = (((0.0 * rtu_In.re + rtu_In.im) + (-0.49999999999999978 *
      rtu_In_o.im + -0.86602540378443871 * rtu_In_o.re)) + (-0.49999999999999978
      * rtu_In_j.im + 0.86602540378443871 * rtu_In_j.re)) * 0.33333333333333331;
  }

  /* End of Outputs for SubSystem: '<S402>/Neg. Seq. Computation' */
}

/*
 * Output and update for enable system:
 *    '<S402>/Pos. Seq. Computation'
 *    '<S403>/Pos. Seq. Computation'
 *    '<S452>/Pos. Seq. Computation'
 *    '<S453>/Pos. Seq. Computation'
 *    '<S32>/Pos. Seq. Computation'
 */
void PosSeqComputation(real_T rtu_Enable, creal_T rtu_In, creal_T rtu_In_b,
  creal_T rtu_In_d, creal_T *rty_Out)
{
  /* Outputs for Enabled SubSystem: '<S402>/Pos. Seq. Computation' incorporates:
   *  EnablePort: '<S408>/Enable'
   */
  if (rtu_Enable > 0.0) {
    /* Gain: '<S408>/Gain3' incorporates:
     *  Gain: '<S408>/Gain1'
     *  Sum: '<S408>/Sum'
     */
    rty_Out->re = (((rtu_In.re - 0.0 * rtu_In.im) + (-0.49999999999999978 *
      rtu_In_b.re - 0.86602540378443871 * rtu_In_b.im)) + (-0.49999999999999978 *
      rtu_In_d.re - -0.86602540378443871 * rtu_In_d.im)) * 0.33333333333333331;
    rty_Out->im = (((0.0 * rtu_In.re + rtu_In.im) + (-0.49999999999999978 *
      rtu_In_b.im + 0.86602540378443871 * rtu_In_b.re)) + (-0.49999999999999978 *
      rtu_In_d.im + -0.86602540378443871 * rtu_In_d.re)) * 0.33333333333333331;
  }

  /* End of Outputs for SubSystem: '<S402>/Pos. Seq. Computation' */
}

/*
 * Output and update for enable system:
 *    '<S402>/Zero Seq. Computation'
 *    '<S403>/Zero Seq. Computation'
 *    '<S452>/Zero Seq. Computation'
 *    '<S453>/Zero Seq. Computation'
 *    '<S32>/Zero Seq. Computation'
 */
void ZeroSeqComputation(real_T rtu_Enable, creal_T rtu_In, creal_T rtu_In_d,
  creal_T rtu_In_o, creal_T *rty_Out)
{
  /* Outputs for Enabled SubSystem: '<S402>/Zero Seq. Computation' incorporates:
   *  EnablePort: '<S409>/Enable'
   */
  if (rtu_Enable > 0.0) {
    /* Gain: '<S409>/Gain3' incorporates:
     *  Sum: '<S409>/Sum'
     */
    rty_Out->re = ((rtu_In.re + rtu_In_d.re) + rtu_In_o.re) *
      0.33333333333333331;
    rty_Out->im = ((rtu_In.im + rtu_In_d.im) + rtu_In_o.im) *
      0.33333333333333331;
  }

  /* End of Outputs for SubSystem: '<S402>/Zero Seq. Computation' */
}

real_T rt_hypotd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T a;
  a = fabs(u0);
  y = fabs(u1);
  if (a < y) {
    a /= y;
    y *= sqrt(a * a + 1.0);
  } else if (a > y) {
    y /= a;
    y = sqrt(y * y + 1.0) * a;
  } else {
    if (!rtIsNaN(y)) {
      y = a * 1.4142135623730951;
    }
  }

  return y;
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  int32_T u0_0;
  int32_T u1_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    if (u0 > 0.0) {
      u0_0 = 1;
    } else {
      u0_0 = -1;
    }

    if (u1 > 0.0) {
      u1_0 = 1;
    } else {
      u1_0 = -1;
    }

    y = atan2(u0_0, u1_0);
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }

  return y;
}

real_T rt_remd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T u1_0;
  if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {
    y = (rtNaN);
  } else if (rtIsInf(u1)) {
    y = u0;
  } else {
    if (u1 < 0.0) {
      u1_0 = ceil(u1);
    } else {
      u1_0 = floor(u1);
    }

    if ((u1 != 0.0) && (u1 != u1_0)) {
      u1_0 = fabs(u0 / u1);
      if (fabs(u1_0 - floor(u1_0 + 0.5)) <= DBL_EPSILON * u1_0) {
        y = 0.0 * u0;
      } else {
        y = fmod(u0, u1);
      }
    } else {
      y = fmod(u0, u1);
    }
  }

  return y;
}

/* Model step function for TID0 */
void power_converters_switching_devices_step0(void) /* Sample time: [5.0E-6s, 0.0s] */
{
  real_T rtb_UnitDelay7;
  real_T rtb_UnitDelay_ai[3];
  real_T rtb_Product1;
  real_T rtb_DataTypeConversion1_g;
  real_T rtb_Product_jl;
  real_T rtb_Product1_mv;
  real_T rtb_Product_e;
  real_T rtb_Product1_gec;
  real_T rtb_UnitDelay4[3];
  real_T rtb_Product_bk;
  real_T rtb_Product1_or;
  real_T rtb_Product_gi;
  real_T rtb_Product1_nj;
  real_T rtb_Product_o;
  real_T rtb_Product1_he;
  real_T rtb_UnitDelay3[3];
  real_T rtb_UnitDelay1_d[3];
  real_T rtb_Block4;
  real_T rtb_phi;
  real_T rtb_Product_kx;
  real_T rtb_Product1_fm;
  real_T rtb_Product_h5;
  real_T rtb_Product1_ku;
  real_T rtb_Product_gk;
  real_T rtb_Product1_b;
  real_T rtb_Switch_o4;
  real_T rtb_Switch_e0;
  real_T rtb_Switch_mg;
  real_T rtb_Switch_i2;
  real_T rtb_Product_f;
  real_T rtb_Product1_eo;
  real_T rtb_Product_h4;
  real_T rtb_Product1_d;
  real_T rtb_UnitDelay6;
  real_T rtb_phi_b;
  real_T rtb_Product1_jc;
  real_T rtb_Product_aa;
  real_T rtb_Product1_j;
  real_T rtb_Product_p;
  real_T rtb_Product1_nw;
  real_T rtb_Product_bo;
  real_T rtb_Product1_ls;
  real_T rtb_Product_i;
  real_T rtb_Product1_ce;
  real_T rtb_Product_lv;
  real_T rtb_Product1_iha;
  real_T rtb_phi_f;
  real_T rtb_Add;
  real_T rtb_UnitDelay5;
  real_T rtb_B11_h;
  real_T rtb_B21_n;
  real_T rtb_B21_h;
  real_T rtb_sinwt;
  real_T rtb_Product_od;
  real_T rtb_Product1_c;
  real_T rtb_Product_mv;
  real_T rtb_Product1_it;
  real_T rtb_Product_db;
  real_T rtb_Product1_pv;
  real_T rtb_Product_cki;
  real_T rtb_Product1_e;
  real_T rtb_Product_jn;
  real_T rtb_Product1_i;
  real_T rtb_Product_ae;
  real_T rtb_Product1_dr;
  real_T rtb_Product_d;
  real_T rtb_Product1_co;
  real_T rtb_Product_p5i;
  real_T rtb_Product1_o;
  real_T rtb_Product_d3;
  real_T rtb_Product1_dtt;
  real_T rtb_Product_m;
  real_T rtb_Product1_kv;
  real_T rtb_Product_k;
  real_T rtb_Product1_f;
  real_T rtb_Product_a;
  real_T rtb_Product1_a;
  real_T rtb_Product_jv;
  real_T rtb_Product1_n;
  real_T rtb_Product_kb;
  real_T rtb_Product1_fb;
  real_T rtb_Product_pg;
  real_T rtb_Product1_cs;
  real_T rtb_Product_pk;
  boolean_T rtb_RelationalOperator1_g;
  real_T rtb_Switch_dn;
  real_T rtb_Switch_l2;
  real_T rtb_Switch_lk;
  real_T rtb_Switch_ac;
  real_T rtb_Switch_ma;
  real_T rtb_Switch_jl;
  real_T rtb_Switch_b;
  real_T rtb_Switch_iv;
  real_T rtb_Switch_n;
  real_T rtb_Switch_bl;
  real_T rtb_Switch_p;
  real_T rtb_Switch_f;
  real_T rtb_Switch_o5;
  real_T rtb_Switch_c;
  real_T rtb_Switch_o;
  real_T rtb_Switch_jj;
  real_T rtb_Switch_a;
  real_T rtb_Switch_d;
  real_T rtb_Switch_eo;
  real_T rtb_Switch_os;
  real_T rtb_Switch_j;
  real_T rtb_Switch_m;
  real_T rtb_Switch_dc;
  real_T rtb_Switch_e;
  real_T rtb_Switch_h;
  real_T rtb_Switch_on;
  real_T rtb_Switch_cd;
  real_T rtb_Switch_l;
  real_T rtb_Switch_id;
  real_T rtb_Switch_lq;
  real_T rtb_Switch_p0;
  real_T rtb_Switch_k;
  real_T rtb_Switch_kp;
  real_T rtb_Add4;
  real_T rtb_RelationalOperator3_d;
  real_T rtb_Fcn1;
  real_T rtb_Uref2;
  real_T rtb_Switch2;
  creal_T rtb_RealImagtoComplex_l;
  creal_T rtb_MagnitudeAngletoComplex;
  creal_T rtb_MagnitudeAngletoComplex1;
  creal_T Gain3_gs;
  boolean_T rtb_LogicalOperator4_d;
  int32_T rtb_MultiportSwitch4_idx_3;
  int32_T rtb_MultiportSwitch3_idx_3;
  int32_T rtb_Saturation_g_idx_3;
  int32_T rtb_MultiportSwitch4_idx_2;
  int32_T rtb_MultiportSwitch3_idx_2;
  int32_T rtb_Saturation_g_idx_2;
  int32_T rtb_MultiportSwitch4_idx_1;
  int32_T rtb_MultiportSwitch3_idx_1;
  int32_T rtb_Saturation_g_idx_1;
  int32_T rtb_MultiportSwitch4_idx_0;
  int32_T rtb_MultiportSwitch3_idx_0;
  int32_T rtb_Saturation_g_idx_0;
  boolean_T rtb_LogicalOperator4_g_idx_1;
  boolean_T rtb_LogicalOperator4_g_idx_0;
  boolean_T rtb_RelationalOperator2_k_idx_0;
  real_T lastSin_o3_tmp;
  real_T rtb_Product3_h_tmp;
  real_T rtb_Product2_tmp;
  real_T rtb_Product1_g_tmp;

  /* Update the flag to indicate when data transfers from
   *  Sample time: [5.0E-6s, 0.0s] to Sample time: [5.0E-5s, 0.0s]  */
  rtM->Timing.perTaskSampleHits[1] = (rtM->Timing.RateInteraction.TID0_1 == 0);
  (rtM->Timing.RateInteraction.TID0_1)++;
  if ((rtM->Timing.RateInteraction.TID0_1) > 9) {
    rtM->Timing.RateInteraction.TID0_1 = 0;
  }

  /* S-Function (sfun_spssw_discc): '<S830>/State-Space' incorporates:
   *  Constant: '<S342>/DC'
   */

  /* S-Function block: <S830>/State-Space */
  {
    real_T accum;

    /*
     * Compute outputs:
     * ---------------
     */
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK.DS;
    accum = 0.0;
    accum += *(Cs++) * rtDW.StateSpace_DSTATE;
    accum += *(Ds++) * 500.0;
    rtDW.StateSpace = accum;
  }

  /* Sin: '<Root>/Vload' */
  if (rtDW.systemEnable != 0) {
    rtb_UnitDelay7 = 31.415926535897931 * rtM->Timing.t[0];
    rtDW.lastSin = sin(rtb_UnitDelay7);
    rtDW.lastCos = cos(rtb_UnitDelay7);
    rtDW.systemEnable = 0;
  }

  rtDW.Vload = ((rtDW.lastSin * 0.99999998766299447 + rtDW.lastCos *
                 -0.00015707963203352558) * 0.99999998766299447 + (rtDW.lastCos *
    0.99999998766299447 - rtDW.lastSin * -0.00015707963203352558) *
                0.00015707963203352558) * 50.0 + 500.0;

  /* End of Sin: '<Root>/Vload' */

  /* Product: '<S334>/Product' incorporates:
   *  DiscreteIntegrator: '<S334>/Discrete-Time Integrator'
   *  UnitDelay: '<S334>/KE filter'
   */
  rtDW.Product = rtDW.DiscreteTimeIntegrator_DSTATE * rtDW.KEfilter_DSTATE;

  /* Outputs for Enabled SubSystem: '<S803>/Signal generator' incorporates:
   *  EnablePort: '<S805>/Enable'
   */
  if (rtDW.Signalgenerator_MODE) {
    /* Disable for Outport: '<S805>/timer' */
    rtDW.LookUpTable = 0.0;

    /* Disable for Outport: '<S805>/selector' */
    rtDW.LogicalOperator1 = false;

    /* Disable for Outport: '<S805>/magnitude' */
    rtDW.Switch2 = 0.0;

    /* Disable for Outport: '<S805>/frequency' */
    rtDW.DiscreteTimeIntegrator = 0.0;

    /* Disable for Outport: '<S805>/phase' */
    rtDW.Switch3 = 0.0;
    rtDW.Signalgenerator_MODE = false;
  }

  /* End of Outputs for SubSystem: '<S803>/Signal generator' */

  /* Switch: '<S803>/Switch1' incorporates:
   *  Constant: '<S803>/valp_nom2'
   *  Sum: '<S803>/Sum3'
   */
  if (rtDW.LogicalOperator1) {
    rtb_DataTypeConversion1_g = rtDW.LookUpTable;
  } else {
    rtb_DataTypeConversion1_g = rtDW.Switch2 + 20412.414523193151;
  }

  /* End of Switch: '<S803>/Switch1' */

  /* DigitalClock: '<S803>/t' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Sum: '<S803>/Sum' incorporates:
   *  Product: '<S803>/Product'
   */
  rtb_Switch2 = rtb_UnitDelay7 * 376.99111843077515 +
    rtDW.DiscreteTimeIntegrator;

  /* Trigonometry: '<S803>/Trigonometric Function' incorporates:
   *  Product: '<S803>/Product1'
   *  Sum: '<S803>/Sum1'
   *  Sum: '<S803>/Sum2'
   */
  rtb_UnitDelay_ai[0] = sin(rtb_Switch2 + rtDW.Switch3) *
    rtb_DataTypeConversion1_g;
  rtb_UnitDelay_ai[1] = sin((-2.0943951023931953 + rtDW.Switch3) + rtb_Switch2) *
    rtb_DataTypeConversion1_g;
  rtb_UnitDelay_ai[2] = sin((2.0943951023931953 + rtDW.Switch3) + rtb_Switch2) *
    rtb_DataTypeConversion1_g;

  /* Outputs for Enabled SubSystem: '<S803>/Harmonic Generator' incorporates:
   *  EnablePort: '<S804>/Enable'
   */
  if (rtDW.HarmonicGenerator_MODE) {
    /* Disable for Outport: '<S804>/Out1' */
    rtDW.Product1[0] = 0.0;

    /* Disable for Outport: '<S804>/Out2' */
    rtDW.Product1_o[0] = 0.0;

    /* Disable for Outport: '<S804>/Out1' */
    rtDW.Product1[1] = 0.0;

    /* Disable for Outport: '<S804>/Out2' */
    rtDW.Product1_o[1] = 0.0;

    /* Disable for Outport: '<S804>/Out1' */
    rtDW.Product1[2] = 0.0;

    /* Disable for Outport: '<S804>/Out2' */
    rtDW.Product1_o[2] = 0.0;
    rtDW.HarmonicGenerator_MODE = false;
  }

  /* End of Outputs for SubSystem: '<S803>/Harmonic Generator' */

  /* Sum: '<S803>/Sum5' */
  rtDW.Sum5[0] = (rtb_UnitDelay_ai[0] + rtDW.Product1[0]) + rtDW.Product1_o[0];
  rtDW.Sum5[1] = (rtb_UnitDelay_ai[1] + rtDW.Product1[1]) + rtDW.Product1_o[1];
  rtDW.Sum5[2] = (rtb_UnitDelay_ai[2] + rtDW.Product1[2]) + rtDW.Product1_o[2];

  /* S-Function (sfun_spssw_discc): '<S831>/State-Space' incorporates:
   *  Constant: '<S343>/DC'
   *  Constant: '<S835>/SwitchCurrents'
   */

  /* S-Function block: <S831>/State-Space */
  {
    real_T accum;

    /* Circuit has switches */
    int_T *switch_status = (int_T*) rtDW.StateSpace_PWORK_n.SWITCH_STATUS;
    int_T *switch_status_init = (int_T*)
      rtDW.StateSpace_PWORK_n.SWITCH_STATUS_INIT;
    int_T *SwitchChange = (int_T*) rtDW.StateSpace_PWORK_n.SW_CHG;
    int_T *gState = (int_T*) rtDW.StateSpace_PWORK_n.G_STATE;
    real_T *yswitch = (real_T*)rtDW.StateSpace_PWORK_n.Y_SWITCH;
    int_T *switchTypes = (int_T*) rtDW.StateSpace_PWORK_n.SWITCH_TYPES;
    int_T *idxOutSw = (int_T*) rtDW.StateSpace_PWORK_n.IDX_OUT_SW;
    real_T *DxCol = (real_T*)rtDW.StateSpace_PWORK_n.DX_COL;
    real_T *tmp2 = (real_T*)rtDW.StateSpace_PWORK_n.TMP2;
    real_T *BDcol = (real_T*)rtDW.StateSpace_PWORK_n.BD_COL;
    real_T *tmp1 = (real_T*)rtDW.StateSpace_PWORK_n.TMP1;
    real_T *uswlast = (real_T*)rtDW.StateSpace_PWORK_n.USWLAST;
    int_T newState;
    int_T swChanged = 0;
    int loopsToDo = 20;
    real_T temp;

    /* keep an initial copy of switch_status*/
    memcpy(switch_status_init, switch_status, 42 * sizeof(int_T));
    memcpy(uswlast, &rtDW.StateSpace_o1[0], 42*sizeof(real_T));
    do {
      if (loopsToDo == 1) {            /* Need to reset some variables: */
        swChanged = 0;

        /* return to the original switch status*/
        {
          int_T i1;
          for (i1=0; i1 < 42; i1++) {
            swChanged = ((SwitchChange[i1] = switch_status_init[i1] -
                          switch_status[i1]) != 0) ? 1 : swChanged;
            switch_status[i1] = switch_status_init[i1];
          }
        }
      } else {
        /*
         * Compute outputs:
         * ---------------
         */
        real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
        real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;

        {
          int_T i1;
          real_T *y0 = &rtDW.StateSpace_o1[0];
          for (i1=0; i1 < 71; i1++) {
            accum = 0.0;

            {
              int_T i2;
              real_T *xd = &rtDW.StateSpace_DSTATE_d[0];
              for (i2=0; i2 < 40; i2++) {
                accum += *(Cs++) * xd[i2];
              }
            }

            {
              int_T i2;
              const real_T *u0 = rtConstP.SwitchCurrents_Value;
              for (i2=0; i2 < 40; i2++) {
                accum += *(Ds++) * u0[i2];
              }

              accum += *(Ds++) * 0.0;
              accum += *(Ds++) * 0.0;
              accum += *(Ds++) * 500.0;
              accum += *(Ds++) * rtDW.Vload;
              accum += *(Ds++) * rtDW.Product;
              accum += *(Ds++) * rtDW.Sum5[0];
              accum += *(Ds++) * rtDW.Sum5[1];
              accum += *(Ds++) * rtDW.Sum5[2];
            }

            y0[i1] = accum;
          }
        }

        swChanged = 0;

        {
          int_T i1;
          real_T *y0 = &rtDW.StateSpace_o1[0];
          for (i1=0; i1 < 42; i1++) {
            switch (switchTypes[i1]) {
             case 3 :                  /* Diodes */
              newState = y0[i1] > 0.0 ? 1 : ((y0[i1] < 0.0) ? 0 :
                switch_status[i1]);
              break;

             case 6 :                  /* IGBT */
              newState = (y0[i1] > 0.0) && gState[i1] > 0 ? 1 : (((y0[i1] < 0.0)
                || gState[i1] == 0) ? 0 : switch_status[i1]);
              break;

             case 7 :                  /* MOSFETs or IGBT/Diode pairs */
              newState = ((y0[i1] > 0.0) && (gState[i1] > 0)) || (y0[i1] < 0.0) ?
                1 : (((y0[i1] > 0.0) && gState[i1] == 0) ? 0 : switch_status[i1]);
              break;
            }

            swChanged = ((SwitchChange[i1] = newState - switch_status[i1]) != 0)
              ? 1 : swChanged;
            switch_status[i1] = newState;/* Keep new state */
          }
        }
      }

      /*
       * Compute new As, Bs, Cs and Ds matrixes:
       * --------------------------------------
       */
      if (swChanged) {
        real_T *As = (real_T*)rtDW.StateSpace_PWORK_n.AS;
        real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
        real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_n.BS;
        real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;
        real_T a1;

        {
          int_T i1;
          for (i1=0; i1 < 42; i1++) {
            if (SwitchChange[i1] != 0) {
              a1 = 1000.0*SwitchChange[i1];
              temp = 1/(1-Ds[i1*49]*a1);

              {
                int_T i2;
                for (i2=0; i2 < 71; i2++) {
                  DxCol[i2]= Ds[i2 * 48 + i1]*temp*a1;
                }
              }

              DxCol[i1] = temp;

              {
                int_T i2;
                for (i2=0; i2 < 40; i2++) {
                  BDcol[i2]= Bs[i2 * 48 + i1]*a1;
                }
              }

              /* Copy row nSw of Cs into tmp1 and zero it out in Cs */
              memcpy(tmp1, &Cs[i1 * 40], 40 * sizeof(real_T));
              memset(&Cs[i1 * 40], '\0', 40 * sizeof(real_T));

              /* Copy row nSw of Ds into tmp2 and zero it out in Ds */
              memcpy(tmp2, &Ds[i1 * 48], 48 * sizeof(real_T));
              memset(&Ds[i1 * 48], '\0', 48 * sizeof(real_T));

              /* Cs = Cs + DxCol * tmp1, Ds = Ds + DxCol * tmp2 *******************/
              {
                int_T i2;
                for (i2=0; i2 < 71; i2++) {
                  a1 = DxCol[i2];

                  {
                    int_T i3;
                    for (i3=0; i3 < 40; i3++) {
                      Cs[i2 * 40 + i3] += a1 * tmp1[i3];
                    }
                  }

                  {
                    int_T i3;
                    for (i3=0; i3 < 48; i3++) {
                      Ds[i2 * 48 + i3] += a1 * tmp2[i3];
                    }
                  }
                }
              }

              /* As = As + BdCol*Cs(nSw,:), Bs = Bs + BdCol*Ds(nSw,:) *************/
              {
                int_T i2;
                for (i2=0; i2 < 40; i2++) {
                  a1 = BDcol[i2];

                  {
                    int_T i3;
                    for (i3=0; i3 < 40; i3++) {
                      As[i2 * 40 + i3] += a1 * Cs[i1 * 40 + i3];
                    }
                  }

                  {
                    int_T i3;
                    for (i3=0; i3 < 48; i3++) {
                      Bs[i2 * 48 + i3] += a1 * Ds[i1 * 48 + i3];
                    }
                  }
                }
              }
            }
          }
        }
      }                                /* if (swChanged) */
    } while (swChanged > 0 && --loopsToDo > 0);

    if (loopsToDo == 0) {
      real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
      real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;

      {
        int_T i1;
        real_T *y0 = &rtDW.StateSpace_o1[0];
        for (i1=0; i1 < 71; i1++) {
          accum = 0.0;

          {
            int_T i2;
            real_T *xd = &rtDW.StateSpace_DSTATE_d[0];
            for (i2=0; i2 < 40; i2++) {
              accum += *(Cs++) * xd[i2];
            }
          }

          {
            int_T i2;
            const real_T *u0 = rtConstP.SwitchCurrents_Value;
            for (i2=0; i2 < 40; i2++) {
              accum += *(Ds++) * u0[i2];
            }

            accum += *(Ds++) * 0.0;
            accum += *(Ds++) * 0.0;
            accum += *(Ds++) * 500.0;
            accum += *(Ds++) * rtDW.Vload;
            accum += *(Ds++) * rtDW.Product;
            accum += *(Ds++) * rtDW.Sum5[0];
            accum += *(Ds++) * rtDW.Sum5[1];
            accum += *(Ds++) * rtDW.Sum5[2];
          }

          y0[i1] = accum;
        }
      }
    }

    /* Output new switches states */
    {
      int_T i1;
      real_T *y1 = &rtDW.StateSpace_o2[0];
      for (i1=0; i1 < 42; i1++) {
        y1[i1] = (real_T)switch_status[i1];
      }
    }
  }

  /* Sin: '<S404>/sin(wt)' */
  if (rtDW.systemEnable_f != 0) {
    rtDW.lastSin_o = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_n = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_f = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_o * 0.99999822347173384 + rtDW.lastCos_n *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_n * 0.99999822347173384 - rtDW.lastSin_o *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S404>/sin(wt)' */

  /* Product: '<S404>/Product' */
  rtb_Switch2 = rtDW.StateSpace_o1[48] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S414>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE != 0) {
    rtDW.Integ4 = rtDW.Integ4_DSTATE;
  } else {
    rtDW.Integ4 = 2.5E-6 * rtb_Switch2 + rtDW.Integ4_DSTATE;
  }

  /* End of DiscreteIntegrator: '<S414>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */

  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S414>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S414>/Switch' incorporates:
   *  Constant: '<S414>/K1'
   *  Constant: '<S414>/K2'
   *  Gain: '<S414>/Gain'
   *  Gain: '<S414>/Gain1'
   *  Product: '<S414>/Product'
   *  RelationalOperator: '<S414>/Relational Operator'
   *  Sum: '<S414>/Sum1'
   *  Sum: '<S414>/Sum5'
   *  Sum: '<S414>/Sum7'
   *  UnitDelay: '<S414>/Unit Delay'
   *  UnitDelay: '<S414>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_sinwt = (rtDW.Integ4 - rtDW.SFunction) * 60.0 + (-0.00013333333333336367
      * rtb_Switch2 - 6.66666666667273E-5 * rtDW.UnitDelay_DSTATE);
  } else {
    rtb_sinwt = rtDW.UnitDelay1_DSTATE;
  }

  /* End of Switch: '<S414>/Switch' */

  /* Sin: '<S404>/cos(wt)' */
  if (rtDW.systemEnable_b != 0) {
    rtDW.lastSin_j = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_i = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_b = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_j * 0.0018849544759281464 + rtDW.lastCos_i *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_i * 0.0018849544759281464 - rtDW.lastSin_j *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S404>/cos(wt)' */

  /* Product: '<S404>/Product1' */
  rtb_Product1 = rtDW.StateSpace_o1[48] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S412>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_e != 0) {
    rtDW.Integ4_p = rtDW.Integ4_DSTATE_e;
  } else {
    rtDW.Integ4_p = 2.5E-6 * rtb_Product1 + rtDW.Integ4_DSTATE_e;
  }

  /* End of DiscreteIntegrator: '<S412>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */

  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S412>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S412>/Switch' incorporates:
   *  Constant: '<S412>/K1'
   *  Constant: '<S412>/K2'
   *  Gain: '<S412>/Gain'
   *  Gain: '<S412>/Gain1'
   *  Product: '<S412>/Product'
   *  RelationalOperator: '<S412>/Relational Operator'
   *  Sum: '<S412>/Sum1'
   *  Sum: '<S412>/Sum5'
   *  Sum: '<S412>/Sum7'
   *  UnitDelay: '<S412>/Unit Delay'
   *  UnitDelay: '<S412>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_dn = (rtDW.Integ4_p - rtDW.SFunction_e) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_c);
  } else {
    rtb_Switch_dn = rtDW.UnitDelay1_DSTATE_l;
  }

  /* End of Switch: '<S412>/Switch' */

  /* ComplexToMagnitudeAngle: '<S404>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S404>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_hypotd_snf(rtb_sinwt, rtb_Switch_dn);

  /* Gain: '<S402>/deg->rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S404>/Complex to Magnitude-Angle'
   *  Gain: '<S404>/Rad->Deg.'
   *  RealImagToComplex: '<S404>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_dn,
    rtb_sinwt) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S402>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay7 * cos
    (rtb_DataTypeConversion1_g);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay7 * sin
    (rtb_DataTypeConversion1_g);

  /* Sin: '<S405>/sin(wt)' */
  if (rtDW.systemEnable_n != 0) {
    rtDW.lastSin_h = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_j = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_n = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_h * 0.99999822347173384 + rtDW.lastCos_j *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_j * 0.99999822347173384 - rtDW.lastSin_h *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S405>/sin(wt)' */

  /* Product: '<S405>/Product' */
  rtb_Product_jl = rtDW.StateSpace_o1[49] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S420>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_c != 0) {
    rtDW.Integ4_d = rtDW.Integ4_DSTATE_d;
  } else {
    rtDW.Integ4_d = 2.5E-6 * rtb_Product_jl + rtDW.Integ4_DSTATE_d;
  }

  /* End of DiscreteIntegrator: '<S420>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S421>/S-Function' incorporates:
   *  Constant: '<S420>/K1'
   */

  /* Level2 S-Function Block: '<S421>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S420>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S420>/Switch' incorporates:
   *  Constant: '<S420>/K1'
   *  Constant: '<S420>/K2'
   *  Gain: '<S420>/Gain'
   *  Gain: '<S420>/Gain1'
   *  Product: '<S420>/Product'
   *  RelationalOperator: '<S420>/Relational Operator'
   *  Sum: '<S420>/Sum1'
   *  Sum: '<S420>/Sum5'
   *  Sum: '<S420>/Sum7'
   *  UnitDelay: '<S420>/Unit Delay'
   *  UnitDelay: '<S420>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_l2 = (rtDW.Integ4_d - rtDW.SFunction_em) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_jl - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_g);
  } else {
    rtb_Switch_l2 = rtDW.UnitDelay1_DSTATE_f;
  }

  /* End of Switch: '<S420>/Switch' */

  /* Sin: '<S405>/cos(wt)' */
  if (rtDW.systemEnable_c != 0) {
    rtDW.lastSin_hi = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_o = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_c = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_hi * 0.0018849544759281464 + rtDW.lastCos_o *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_o * 0.0018849544759281464 - rtDW.lastSin_hi *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S405>/cos(wt)' */

  /* Product: '<S405>/Product1' */
  rtb_Product1_mv = rtDW.StateSpace_o1[49] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S418>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i != 0) {
    rtDW.Integ4_h = rtDW.Integ4_DSTATE_dw;
  } else {
    rtDW.Integ4_h = 2.5E-6 * rtb_Product1_mv + rtDW.Integ4_DSTATE_dw;
  }

  /* End of DiscreteIntegrator: '<S418>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S419>/S-Function' incorporates:
   *  Constant: '<S418>/K1'
   */

  /* Level2 S-Function Block: '<S419>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S418>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S418>/Switch' incorporates:
   *  Constant: '<S418>/K1'
   *  Constant: '<S418>/K2'
   *  Gain: '<S418>/Gain'
   *  Gain: '<S418>/Gain1'
   *  Product: '<S418>/Product'
   *  RelationalOperator: '<S418>/Relational Operator'
   *  Sum: '<S418>/Sum1'
   *  Sum: '<S418>/Sum5'
   *  Sum: '<S418>/Sum7'
   *  UnitDelay: '<S418>/Unit Delay'
   *  UnitDelay: '<S418>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_lk = (rtDW.Integ4_h - rtDW.SFunction_c) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_mv - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_e);
  } else {
    rtb_Switch_lk = rtDW.UnitDelay1_DSTATE_j;
  }

  /* End of Switch: '<S418>/Switch' */

  /* ComplexToMagnitudeAngle: '<S405>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S405>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_hypotd_snf(rtb_Switch_l2, rtb_Switch_lk);

  /* Gain: '<S402>/deg->rad1' incorporates:
   *  ComplexToMagnitudeAngle: '<S405>/Complex to Magnitude-Angle'
   *  Gain: '<S405>/Rad->Deg.'
   *  RealImagToComplex: '<S405>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_lk,
    rtb_Switch_l2) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S402>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay7 * cos
    (rtb_DataTypeConversion1_g);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay7 * sin
    (rtb_DataTypeConversion1_g);

  /* Sin: '<S406>/sin(wt)' */
  if (rtDW.systemEnable_a != 0) {
    rtDW.lastSin_e = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_f = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_a = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_e * 0.99999822347173384 + rtDW.lastCos_f *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_f * 0.99999822347173384 - rtDW.lastSin_e *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S406>/sin(wt)' */

  /* Product: '<S406>/Product' */
  rtb_Product_e = rtDW.StateSpace_o1[50] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S426>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_n != 0) {
    rtDW.Integ4_a = rtDW.Integ4_DSTATE_p;
  } else {
    rtDW.Integ4_a = 2.5E-6 * rtb_Product_e + rtDW.Integ4_DSTATE_p;
  }

  /* End of DiscreteIntegrator: '<S426>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S427>/S-Function' incorporates:
   *  Constant: '<S426>/K1'
   */

  /* Level2 S-Function Block: '<S427>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S426>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S426>/Switch' incorporates:
   *  Constant: '<S426>/K1'
   *  Constant: '<S426>/K2'
   *  Gain: '<S426>/Gain'
   *  Gain: '<S426>/Gain1'
   *  Product: '<S426>/Product'
   *  RelationalOperator: '<S426>/Relational Operator'
   *  Sum: '<S426>/Sum1'
   *  Sum: '<S426>/Sum5'
   *  Sum: '<S426>/Sum7'
   *  UnitDelay: '<S426>/Unit Delay'
   *  UnitDelay: '<S426>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_ac = (rtDW.Integ4_a - rtDW.SFunction_l) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_e - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_l);
  } else {
    rtb_Switch_ac = rtDW.UnitDelay1_DSTATE_n;
  }

  /* End of Switch: '<S426>/Switch' */

  /* Sin: '<S406>/cos(wt)' */
  if (rtDW.systemEnable_d != 0) {
    rtDW.lastSin_k = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_g = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_d = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_k * 0.0018849544759281464 + rtDW.lastCos_g *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_g * 0.0018849544759281464 - rtDW.lastSin_k *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S406>/cos(wt)' */

  /* Product: '<S406>/Product1' */
  rtb_Product1_gec = rtDW.StateSpace_o1[50] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S424>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_k != 0) {
    rtDW.Integ4_c = rtDW.Integ4_DSTATE_pr;
  } else {
    rtDW.Integ4_c = 2.5E-6 * rtb_Product1_gec + rtDW.Integ4_DSTATE_pr;
  }

  /* End of DiscreteIntegrator: '<S424>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */

  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S424>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S424>/Switch' incorporates:
   *  Constant: '<S424>/K1'
   *  Constant: '<S424>/K2'
   *  Gain: '<S424>/Gain'
   *  Gain: '<S424>/Gain1'
   *  Product: '<S424>/Product'
   *  RelationalOperator: '<S424>/Relational Operator'
   *  Sum: '<S424>/Sum1'
   *  Sum: '<S424>/Sum5'
   *  Sum: '<S424>/Sum7'
   *  UnitDelay: '<S424>/Unit Delay'
   *  UnitDelay: '<S424>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_ma = (rtDW.Integ4_c - rtDW.SFunction_h) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_gec - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_eo);
  } else {
    rtb_Switch_ma = rtDW.UnitDelay1_DSTATE_h;
  }

  /* End of Switch: '<S424>/Switch' */

  /* ComplexToMagnitudeAngle: '<S406>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S406>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_hypotd_snf(rtb_Switch_ac, rtb_Switch_ma);

  /* Gain: '<S402>/deg->rad2' incorporates:
   *  ComplexToMagnitudeAngle: '<S406>/Complex to Magnitude-Angle'
   *  Gain: '<S406>/Rad->Deg.'
   *  RealImagToComplex: '<S406>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_ma,
    rtb_Switch_ac) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S402>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay7 * cos(rtb_DataTypeConversion1_g);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay7 * sin(rtb_DataTypeConversion1_g);

  /* Outputs for Enabled SubSystem: '<S402>/Pos. Seq. Computation' */
  /* Constant: '<S402>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_n);

  /* End of Outputs for SubSystem: '<S402>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S402>/Neg. Seq. Computation' */
  /* Constant: '<S402>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &Gain3_gs);

  /* End of Outputs for SubSystem: '<S402>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S402>/Zero Seq. Computation' */
  /* Constant: '<S402>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S402>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S402>/Complex to Magnitude-Angle' */
  rtb_UnitDelay_ai[0] = rt_hypotd_snf(rtDW.Gain3_n.re, rtDW.Gain3_n.im);
  rtb_UnitDelay3[0] = rt_atan2d_snf(rtDW.Gain3_n.im, rtDW.Gain3_n.re);

  /* Gain: '<Root>/to' */
  rtb_UnitDelay4[0] = -rtDW.StateSpace_o1[62];
  rtb_UnitDelay4[1] = -rtDW.StateSpace_o1[63];
  rtb_UnitDelay4[2] = -rtDW.StateSpace_o1[64];

  /* Sin: '<S428>/sin(wt)' */
  if (rtDW.systemEnable_fb != 0) {
    rtDW.lastSin_ob = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_k = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fb = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_ob * 0.99999822347173384 + rtDW.lastCos_k *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_k * 0.99999822347173384 - rtDW.lastSin_ob *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S428>/sin(wt)' */

  /* Product: '<S428>/Product' */
  rtb_Product_bk = rtb_UnitDelay4[0] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S438>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_g != 0) {
    rtDW.Integ4_ae = rtDW.Integ4_DSTATE_o;
  } else {
    rtDW.Integ4_ae = 2.5E-6 * rtb_Product_bk + rtDW.Integ4_DSTATE_o;
  }

  /* End of DiscreteIntegrator: '<S438>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S439>/S-Function' incorporates:
   *  Constant: '<S438>/K1'
   */

  /* Level2 S-Function Block: '<S439>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S438>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S438>/Switch' incorporates:
   *  Constant: '<S438>/K1'
   *  Constant: '<S438>/K2'
   *  Gain: '<S438>/Gain'
   *  Gain: '<S438>/Gain1'
   *  Product: '<S438>/Product'
   *  RelationalOperator: '<S438>/Relational Operator'
   *  Sum: '<S438>/Sum1'
   *  Sum: '<S438>/Sum5'
   *  Sum: '<S438>/Sum7'
   *  UnitDelay: '<S438>/Unit Delay'
   *  UnitDelay: '<S438>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_jl = (rtDW.Integ4_ae - rtDW.SFunction_c5) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_bk - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_h);
  } else {
    rtb_Switch_jl = rtDW.UnitDelay1_DSTATE_a;
  }

  /* End of Switch: '<S438>/Switch' */

  /* Sin: '<S428>/cos(wt)' */
  if (rtDW.systemEnable_o != 0) {
    rtDW.lastSin_f = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_e = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_o = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_f * 0.0018849544759281464 + rtDW.lastCos_e *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_e * 0.0018849544759281464 - rtDW.lastSin_f *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S428>/cos(wt)' */

  /* Product: '<S428>/Product1' */
  rtb_Product1_or = rtb_UnitDelay4[0] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S436>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ex != 0) {
    rtDW.Integ4_k = rtDW.Integ4_DSTATE_i;
  } else {
    rtDW.Integ4_k = 2.5E-6 * rtb_Product1_or + rtDW.Integ4_DSTATE_i;
  }

  /* End of DiscreteIntegrator: '<S436>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S437>/S-Function' incorporates:
   *  Constant: '<S436>/K1'
   */

  /* Level2 S-Function Block: '<S437>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S436>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S436>/Switch' incorporates:
   *  Constant: '<S436>/K1'
   *  Constant: '<S436>/K2'
   *  Gain: '<S436>/Gain'
   *  Gain: '<S436>/Gain1'
   *  Product: '<S436>/Product'
   *  RelationalOperator: '<S436>/Relational Operator'
   *  Sum: '<S436>/Sum1'
   *  Sum: '<S436>/Sum5'
   *  Sum: '<S436>/Sum7'
   *  UnitDelay: '<S436>/Unit Delay'
   *  UnitDelay: '<S436>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_b = (rtDW.Integ4_k - rtDW.SFunction_c1) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_or - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_f);
  } else {
    rtb_Switch_b = rtDW.UnitDelay1_DSTATE_av;
  }

  /* End of Switch: '<S436>/Switch' */

  /* ComplexToMagnitudeAngle: '<S428>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S428>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_hypotd_snf(rtb_Switch_jl, rtb_Switch_b);

  /* Gain: '<S403>/deg->rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S428>/Complex to Magnitude-Angle'
   *  Gain: '<S428>/Rad->Deg.'
   *  RealImagToComplex: '<S428>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_b,
    rtb_Switch_jl) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S403>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay7 * cos
    (rtb_DataTypeConversion1_g);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay7 * sin
    (rtb_DataTypeConversion1_g);

  /* Sin: '<S429>/sin(wt)' */
  if (rtDW.systemEnable_p != 0) {
    rtDW.lastSin_h0 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ov = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_p = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_h0 * 0.99999822347173384 + rtDW.lastCos_ov *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ov * 0.99999822347173384 - rtDW.lastSin_h0 *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S429>/sin(wt)' */

  /* Product: '<S429>/Product' */
  rtb_Product_gi = rtb_UnitDelay4[1] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S444>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_kl != 0) {
    rtDW.Integ4_dh = rtDW.Integ4_DSTATE_g;
  } else {
    rtDW.Integ4_dh = 2.5E-6 * rtb_Product_gi + rtDW.Integ4_DSTATE_g;
  }

  /* End of DiscreteIntegrator: '<S444>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */

  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S444>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S444>/Switch' incorporates:
   *  Constant: '<S444>/K1'
   *  Constant: '<S444>/K2'
   *  Gain: '<S444>/Gain'
   *  Gain: '<S444>/Gain1'
   *  Product: '<S444>/Product'
   *  RelationalOperator: '<S444>/Relational Operator'
   *  Sum: '<S444>/Sum1'
   *  Sum: '<S444>/Sum5'
   *  Sum: '<S444>/Sum7'
   *  UnitDelay: '<S444>/Unit Delay'
   *  UnitDelay: '<S444>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_iv = (rtDW.Integ4_dh - rtDW.SFunction_g) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_gi - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_b);
  } else {
    rtb_Switch_iv = rtDW.UnitDelay1_DSTATE_m;
  }

  /* End of Switch: '<S444>/Switch' */

  /* Sin: '<S429>/cos(wt)' */
  if (rtDW.systemEnable_e != 0) {
    rtDW.lastSin_a = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_a * 0.0018849544759281464 + rtDW.lastCos_h *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_h * 0.0018849544759281464 - rtDW.lastSin_a *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S429>/cos(wt)' */

  /* Product: '<S429>/Product1' */
  rtb_Product1_nj = rtb_UnitDelay4[1] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S442>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_l != 0) {
    rtDW.Integ4_b = rtDW.Integ4_DSTATE_m;
  } else {
    rtDW.Integ4_b = 2.5E-6 * rtb_Product1_nj + rtDW.Integ4_DSTATE_m;
  }

  /* End of DiscreteIntegrator: '<S442>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */

  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S442>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S442>/Switch' incorporates:
   *  Constant: '<S442>/K1'
   *  Constant: '<S442>/K2'
   *  Gain: '<S442>/Gain'
   *  Gain: '<S442>/Gain1'
   *  Product: '<S442>/Product'
   *  RelationalOperator: '<S442>/Relational Operator'
   *  Sum: '<S442>/Sum1'
   *  Sum: '<S442>/Sum5'
   *  Sum: '<S442>/Sum7'
   *  UnitDelay: '<S442>/Unit Delay'
   *  UnitDelay: '<S442>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_n = (rtDW.Integ4_b - rtDW.SFunction_gi) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_nj - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_lm);
  } else {
    rtb_Switch_n = rtDW.UnitDelay1_DSTATE_o;
  }

  /* End of Switch: '<S442>/Switch' */

  /* ComplexToMagnitudeAngle: '<S429>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S429>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_hypotd_snf(rtb_Switch_iv, rtb_Switch_n);

  /* Gain: '<S403>/deg->rad1' incorporates:
   *  ComplexToMagnitudeAngle: '<S429>/Complex to Magnitude-Angle'
   *  Gain: '<S429>/Rad->Deg.'
   *  RealImagToComplex: '<S429>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_n,
    rtb_Switch_iv) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S403>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay7 * cos
    (rtb_DataTypeConversion1_g);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay7 * sin
    (rtb_DataTypeConversion1_g);

  /* Sin: '<S430>/sin(wt)' */
  if (rtDW.systemEnable_l != 0) {
    rtDW.lastSin_fx = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_c = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_l = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_fx * 0.99999822347173384 + rtDW.lastCos_c *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_c * 0.99999822347173384 - rtDW.lastSin_fx *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S430>/sin(wt)' */

  /* Product: '<S430>/Product' */
  rtb_Product_o = rtb_UnitDelay4[2] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S450>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_k2 != 0) {
    rtDW.Integ4_hq = rtDW.Integ4_DSTATE_j;
  } else {
    rtDW.Integ4_hq = 2.5E-6 * rtb_Product_o + rtDW.Integ4_DSTATE_j;
  }

  /* End of DiscreteIntegrator: '<S450>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */

  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S450>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S450>/Switch' incorporates:
   *  Constant: '<S450>/K1'
   *  Constant: '<S450>/K2'
   *  Gain: '<S450>/Gain'
   *  Gain: '<S450>/Gain1'
   *  Product: '<S450>/Product'
   *  RelationalOperator: '<S450>/Relational Operator'
   *  Sum: '<S450>/Sum1'
   *  Sum: '<S450>/Sum5'
   *  Sum: '<S450>/Sum7'
   *  UnitDelay: '<S450>/Unit Delay'
   *  UnitDelay: '<S450>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_bl = (rtDW.Integ4_hq - rtDW.SFunction_lu) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_o - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_i);
  } else {
    rtb_Switch_bl = rtDW.UnitDelay1_DSTATE_jl;
  }

  /* End of Switch: '<S450>/Switch' */

  /* Sin: '<S430>/cos(wt)' */
  if (rtDW.systemEnable_g != 0) {
    rtDW.lastSin_f2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ni = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_g = 0;
  }

  rtb_UnitDelay7 = ((rtDW.lastSin_f2 * 0.0018849544759281464 + rtDW.lastCos_ni *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_ni * 0.0018849544759281464 - rtDW.lastSin_f2 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S430>/cos(wt)' */

  /* Product: '<S430>/Product1' */
  rtb_Product1_he = rtb_UnitDelay4[2] * rtb_UnitDelay7;

  /* DiscreteIntegrator: '<S448>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_j != 0) {
    rtDW.Integ4_j = rtDW.Integ4_DSTATE_l;
  } else {
    rtDW.Integ4_j = 2.5E-6 * rtb_Product1_he + rtDW.Integ4_DSTATE_l;
  }

  /* End of DiscreteIntegrator: '<S448>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */

  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S448>/Digital  Clock' */
  rtb_UnitDelay7 = rtM->Timing.t[0];

  /* Switch: '<S448>/Switch' incorporates:
   *  Constant: '<S448>/K1'
   *  Constant: '<S448>/K2'
   *  Gain: '<S448>/Gain'
   *  Gain: '<S448>/Gain1'
   *  Product: '<S448>/Product'
   *  RelationalOperator: '<S448>/Relational Operator'
   *  Sum: '<S448>/Sum1'
   *  Sum: '<S448>/Sum5'
   *  Sum: '<S448>/Sum7'
   *  UnitDelay: '<S448>/Unit Delay'
   *  UnitDelay: '<S448>/Unit Delay1'
   */
  if (rtb_UnitDelay7 >= 0.01667) {
    rtb_Switch_p = (rtDW.Integ4_j - rtDW.SFunction_hd) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_he - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_p);
  } else {
    rtb_Switch_p = rtDW.UnitDelay1_DSTATE_ha;
  }

  /* End of Switch: '<S448>/Switch' */

  /* ComplexToMagnitudeAngle: '<S430>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S430>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_hypotd_snf(rtb_Switch_bl, rtb_Switch_p);

  /* Gain: '<S403>/deg->rad2' incorporates:
   *  ComplexToMagnitudeAngle: '<S430>/Complex to Magnitude-Angle'
   *  Gain: '<S430>/Rad->Deg.'
   *  RealImagToComplex: '<S430>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_p,
    rtb_Switch_bl) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S403>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay7 * cos(rtb_DataTypeConversion1_g);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay7 * sin(rtb_DataTypeConversion1_g);

  /* Outputs for Enabled SubSystem: '<S403>/Pos. Seq. Computation' */
  /* Constant: '<S403>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_fk);

  /* End of Outputs for SubSystem: '<S403>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S403>/Neg. Seq. Computation' */
  /* Constant: '<S403>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &Gain3_gs);

  /* End of Outputs for SubSystem: '<S403>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S403>/Zero Seq. Computation' */
  /* Constant: '<S403>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S403>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S403>/Complex to Magnitude-Angle' */
  rtb_UnitDelay4[0] = rt_hypotd_snf(rtDW.Gain3_fk.re, rtDW.Gain3_fk.im);
  rtb_UnitDelay1_d[0] = rt_atan2d_snf(rtDW.Gain3_fk.im, rtDW.Gain3_fk.re);

  /* Product: '<S21>/Product' */
  rtb_UnitDelay7 = rtb_UnitDelay_ai[0] * rtb_UnitDelay4[0];

  /* Gain: '<S21>/Gain1' */
  rtb_UnitDelay7 *= 1.5;

  /* Gain: '<S21>/Deg->Rad' incorporates:
   *  Gain: '<S402>/rad->deg1'
   *  Gain: '<S403>/rad->deg1'
   *  Sum: '<S21>/Sum'
   */
  rtb_phi = (57.295779513082323 * rtb_UnitDelay3[0] - 57.295779513082323 *
             rtb_UnitDelay1_d[0]) * 0.017453292519943295;

  /* Outport: '<Root>/Out1' incorporates:
   *  Product: '<S21>/Product1'
   *  Trigonometry: '<S21>/Trigonometric Function2'
   */
  rtY.Pgrid = rtb_UnitDelay7 * cos(rtb_phi);

  /* Outport: '<Root>/Out20' */
  rtY.Vgrid[0] = rtDW.StateSpace_o1[48];

  /* Outport: '<Root>/Out21' */
  rtY.Igrid[0] = rtDW.StateSpace_o1[62];

  /* Outport: '<Root>/Out20' */
  rtY.Vgrid[1] = rtDW.StateSpace_o1[49];

  /* Outport: '<Root>/Out21' */
  rtY.Igrid[1] = rtDW.StateSpace_o1[63];

  /* Outport: '<Root>/Out20' */
  rtY.Vgrid[2] = rtDW.StateSpace_o1[50];

  /* Outport: '<Root>/Out21' */
  rtY.Igrid[2] = rtDW.StateSpace_o1[64];

  /* Sin: '<S779>/sin(wt)' */
  if (rtDW.systemEnable_nr != 0) {
    rtDW.lastSin_fm = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_e4 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_nr = 0;
  }

  /* Product: '<S779>/Product' incorporates:
   *  Sin: '<S779>/sin(wt)'
   */
  rtb_Product_kx = ((rtDW.lastSin_fm * 0.99999822347173384 + rtDW.lastCos_e4 *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_e4 * 0.99999822347173384 - rtDW.lastSin_fm *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[48];

  /* DiscreteIntegrator: '<S789>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_o != 0) {
    rtDW.Integ4_f = rtDW.Integ4_DSTATE_os;
  } else {
    rtDW.Integ4_f = 2.5E-6 * rtb_Product_kx + rtDW.Integ4_DSTATE_os;
  }

  /* End of DiscreteIntegrator: '<S789>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S790>/S-Function' incorporates:
   *  Constant: '<S789>/K1'
   */

  /* Level2 S-Function Block: '<S790>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S789>/Switch' incorporates:
   *  Constant: '<S789>/K1'
   *  Constant: '<S789>/K2'
   *  DigitalClock: '<S789>/Digital  Clock'
   *  Gain: '<S789>/Gain'
   *  Gain: '<S789>/Gain1'
   *  Product: '<S789>/Product'
   *  RelationalOperator: '<S789>/Relational Operator'
   *  Sum: '<S789>/Sum1'
   *  Sum: '<S789>/Sum5'
   *  Sum: '<S789>/Sum7'
   *  UnitDelay: '<S789>/Unit Delay'
   *  UnitDelay: '<S789>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_f = (rtDW.Integ4_f - rtDW.SFunction_ez) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_kx - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_o);
  } else {
    rtb_Switch_f = rtDW.UnitDelay1_DSTATE_ay;
  }

  /* End of Switch: '<S789>/Switch' */

  /* Sin: '<S779>/cos(wt)' */
  if (rtDW.systemEnable_nk != 0) {
    rtDW.lastSin_f5 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_l = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_nk = 0;
  }

  /* Product: '<S779>/Product1' incorporates:
   *  Sin: '<S779>/cos(wt)'
   */
  rtb_Product1_fm = ((rtDW.lastSin_f5 * 0.0018849544759281464 + rtDW.lastCos_l *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_l * 0.0018849544759281464 - rtDW.lastSin_f5 *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[48];

  /* DiscreteIntegrator: '<S787>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_km != 0) {
    rtDW.Integ4_aa = rtDW.Integ4_DSTATE_lo;
  } else {
    rtDW.Integ4_aa = 2.5E-6 * rtb_Product1_fm + rtDW.Integ4_DSTATE_lo;
  }

  /* End of DiscreteIntegrator: '<S787>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S788>/S-Function' incorporates:
   *  Constant: '<S787>/K1'
   */

  /* Level2 S-Function Block: '<S788>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S787>/Switch' incorporates:
   *  Constant: '<S787>/K1'
   *  Constant: '<S787>/K2'
   *  DigitalClock: '<S787>/Digital  Clock'
   *  Gain: '<S787>/Gain'
   *  Gain: '<S787>/Gain1'
   *  Product: '<S787>/Product'
   *  RelationalOperator: '<S787>/Relational Operator'
   *  Sum: '<S787>/Sum1'
   *  Sum: '<S787>/Sum5'
   *  Sum: '<S787>/Sum7'
   *  UnitDelay: '<S787>/Unit Delay'
   *  UnitDelay: '<S787>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_o5 = (rtDW.Integ4_aa - rtDW.SFunction_d) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_fm - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_a);
  } else {
    rtb_Switch_o5 = rtDW.UnitDelay1_DSTATE_e;
  }

  /* End of Switch: '<S787>/Switch' */

  /* Gain: '<S32>/deg->rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S779>/Complex to Magnitude-Angle'
   *  Gain: '<S779>/Rad->Deg.'
   *  RealImagToComplex: '<S779>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_o5,
    rtb_Switch_f) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S32>/Magnitude-Angle to Complex' incorporates:
   *  ComplexToMagnitudeAngle: '<S779>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S779>/Real-Imag to Complex'
   */
  rtb_Product_h5 = rt_hypotd_snf(rtb_Switch_f, rtb_Switch_o5);
  rtb_MagnitudeAngletoComplex.re = rtb_Product_h5 * cos
    (rtb_DataTypeConversion1_g);
  rtb_MagnitudeAngletoComplex.im = rtb_Product_h5 * sin
    (rtb_DataTypeConversion1_g);

  /* Sin: '<S780>/sin(wt)' */
  if (rtDW.systemEnable_lm != 0) {
    rtDW.lastSin_fmt = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ns = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_lm = 0;
  }

  /* Product: '<S780>/Product' incorporates:
   *  Sin: '<S780>/sin(wt)'
   */
  rtb_Product_h5 = ((rtDW.lastSin_fmt * 0.99999822347173384 + rtDW.lastCos_ns *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ns * 0.99999822347173384 - rtDW.lastSin_fmt *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[49];

  /* DiscreteIntegrator: '<S795>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_f != 0) {
    rtDW.Integ4_f0 = rtDW.Integ4_DSTATE_n;
  } else {
    rtDW.Integ4_f0 = 2.5E-6 * rtb_Product_h5 + rtDW.Integ4_DSTATE_n;
  }

  /* End of DiscreteIntegrator: '<S795>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S796>/S-Function' incorporates:
   *  Constant: '<S795>/K1'
   */

  /* Level2 S-Function Block: '<S796>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S795>/Switch' incorporates:
   *  Constant: '<S795>/K1'
   *  Constant: '<S795>/K2'
   *  DigitalClock: '<S795>/Digital  Clock'
   *  Gain: '<S795>/Gain'
   *  Gain: '<S795>/Gain1'
   *  Product: '<S795>/Product'
   *  RelationalOperator: '<S795>/Relational Operator'
   *  Sum: '<S795>/Sum1'
   *  Sum: '<S795>/Sum5'
   *  Sum: '<S795>/Sum7'
   *  UnitDelay: '<S795>/Unit Delay'
   *  UnitDelay: '<S795>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_c = (rtDW.Integ4_f0 - rtDW.SFunction_dm) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_h5 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ln);
  } else {
    rtb_Switch_c = rtDW.UnitDelay1_DSTATE_c;
  }

  /* End of Switch: '<S795>/Switch' */

  /* Sin: '<S780>/cos(wt)' */
  if (rtDW.systemEnable_fk != 0) {
    rtDW.lastSin_d = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_a = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fk = 0;
  }

  /* Product: '<S780>/Product1' incorporates:
   *  Sin: '<S780>/cos(wt)'
   */
  rtb_Product1_ku = ((rtDW.lastSin_d * 0.0018849544759281464 + rtDW.lastCos_a *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_a * 0.0018849544759281464 - rtDW.lastSin_d *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[49];

  /* DiscreteIntegrator: '<S793>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_fy != 0) {
    rtDW.Integ4_i = rtDW.Integ4_DSTATE_lc;
  } else {
    rtDW.Integ4_i = 2.5E-6 * rtb_Product1_ku + rtDW.Integ4_DSTATE_lc;
  }

  /* End of DiscreteIntegrator: '<S793>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S794>/S-Function' incorporates:
   *  Constant: '<S793>/K1'
   */

  /* Level2 S-Function Block: '<S794>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S793>/Switch' incorporates:
   *  Constant: '<S793>/K1'
   *  Constant: '<S793>/K2'
   *  DigitalClock: '<S793>/Digital  Clock'
   *  Gain: '<S793>/Gain'
   *  Gain: '<S793>/Gain1'
   *  Product: '<S793>/Product'
   *  RelationalOperator: '<S793>/Relational Operator'
   *  Sum: '<S793>/Sum1'
   *  Sum: '<S793>/Sum5'
   *  Sum: '<S793>/Sum7'
   *  UnitDelay: '<S793>/Unit Delay'
   *  UnitDelay: '<S793>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_o = (rtDW.Integ4_i - rtDW.SFunction_gs) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_ku - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_n);
  } else {
    rtb_Switch_o = rtDW.UnitDelay1_DSTATE_ag;
  }

  /* End of Switch: '<S793>/Switch' */

  /* Gain: '<S32>/deg->rad1' incorporates:
   *  ComplexToMagnitudeAngle: '<S780>/Complex to Magnitude-Angle'
   *  Gain: '<S780>/Rad->Deg.'
   *  RealImagToComplex: '<S780>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_o,
    rtb_Switch_c) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S32>/Magnitude-Angle to Complex1' incorporates:
   *  ComplexToMagnitudeAngle: '<S780>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S780>/Real-Imag to Complex'
   */
  rtb_Product_gk = rt_hypotd_snf(rtb_Switch_c, rtb_Switch_o);
  rtb_MagnitudeAngletoComplex1.re = rtb_Product_gk * cos
    (rtb_DataTypeConversion1_g);
  rtb_MagnitudeAngletoComplex1.im = rtb_Product_gk * sin
    (rtb_DataTypeConversion1_g);

  /* Sin: '<S781>/sin(wt)' */
  if (rtDW.systemEnable_es != 0) {
    rtDW.lastSin_d1 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_d = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_es = 0;
  }

  /* Product: '<S781>/Product' incorporates:
   *  Sin: '<S781>/sin(wt)'
   */
  rtb_Product_gk = ((rtDW.lastSin_d1 * 0.99999822347173384 + rtDW.lastCos_d *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_d * 0.99999822347173384 - rtDW.lastSin_d1 *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[50];

  /* DiscreteIntegrator: '<S801>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_n0 != 0) {
    rtDW.Integ4_l = rtDW.Integ4_DSTATE_o0;
  } else {
    rtDW.Integ4_l = 2.5E-6 * rtb_Product_gk + rtDW.Integ4_DSTATE_o0;
  }

  /* End of DiscreteIntegrator: '<S801>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S802>/S-Function' incorporates:
   *  Constant: '<S801>/K1'
   */

  /* Level2 S-Function Block: '<S802>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S801>/Switch' incorporates:
   *  Constant: '<S801>/K1'
   *  Constant: '<S801>/K2'
   *  DigitalClock: '<S801>/Digital  Clock'
   *  Gain: '<S801>/Gain'
   *  Gain: '<S801>/Gain1'
   *  Product: '<S801>/Product'
   *  RelationalOperator: '<S801>/Relational Operator'
   *  Sum: '<S801>/Sum1'
   *  Sum: '<S801>/Sum5'
   *  Sum: '<S801>/Sum7'
   *  UnitDelay: '<S801>/Unit Delay'
   *  UnitDelay: '<S801>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_jj = (rtDW.Integ4_l - rtDW.SFunction_dy) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_gk - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_gs);
  } else {
    rtb_Switch_jj = rtDW.UnitDelay1_DSTATE_cr;
  }

  /* End of Switch: '<S801>/Switch' */

  /* Sin: '<S781>/cos(wt)' */
  if (rtDW.systemEnable_eq != 0) {
    rtDW.lastSin_l = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_l0 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_eq = 0;
  }

  /* Product: '<S781>/Product1' incorporates:
   *  Sin: '<S781>/cos(wt)'
   */
  rtb_Product1_b = ((rtDW.lastSin_l * 0.0018849544759281464 + rtDW.lastCos_l0 *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_l0 * 0.0018849544759281464 - rtDW.lastSin_l *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[50];

  /* DiscreteIntegrator: '<S799>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_d != 0) {
    rtDW.Integ4_g = rtDW.Integ4_DSTATE_pu;
  } else {
    rtDW.Integ4_g = 2.5E-6 * rtb_Product1_b + rtDW.Integ4_DSTATE_pu;
  }

  /* End of DiscreteIntegrator: '<S799>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S800>/S-Function' incorporates:
   *  Constant: '<S799>/K1'
   */

  /* Level2 S-Function Block: '<S800>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S799>/Switch' incorporates:
   *  Constant: '<S799>/K1'
   *  Constant: '<S799>/K2'
   *  DigitalClock: '<S799>/Digital  Clock'
   *  Gain: '<S799>/Gain'
   *  Gain: '<S799>/Gain1'
   *  Product: '<S799>/Product'
   *  RelationalOperator: '<S799>/Relational Operator'
   *  Sum: '<S799>/Sum1'
   *  Sum: '<S799>/Sum5'
   *  Sum: '<S799>/Sum7'
   *  UnitDelay: '<S799>/Unit Delay'
   *  UnitDelay: '<S799>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_a = (rtDW.Integ4_g - rtDW.SFunction_p) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_b - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_p3);
  } else {
    rtb_Switch_a = rtDW.UnitDelay1_DSTATE_p;
  }

  /* End of Switch: '<S799>/Switch' */

  /* Gain: '<S32>/deg->rad2' incorporates:
   *  ComplexToMagnitudeAngle: '<S781>/Complex to Magnitude-Angle'
   *  Gain: '<S781>/Rad->Deg.'
   *  RealImagToComplex: '<S781>/Real-Imag to Complex'
   */
  rtb_DataTypeConversion1_g = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_a,
    rtb_Switch_jj) * 0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S32>/Magnitude-Angle to Complex2' incorporates:
   *  ComplexToMagnitudeAngle: '<S781>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S781>/Real-Imag to Complex'
   */
  rtb_Switch_o4 = rt_hypotd_snf(rtb_Switch_jj, rtb_Switch_a);
  rtb_RealImagtoComplex_l.re = rtb_Switch_o4 * cos(rtb_DataTypeConversion1_g);
  rtb_RealImagtoComplex_l.im = rtb_Switch_o4 * sin(rtb_DataTypeConversion1_g);

  /* Outputs for Enabled SubSystem: '<S32>/Pos. Seq. Computation' */
  /* Constant: '<S32>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_e);

  /* End of Outputs for SubSystem: '<S32>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S32>/Neg. Seq. Computation' */
  /* Constant: '<S32>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &Gain3_gs);

  /* End of Outputs for SubSystem: '<S32>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S32>/Zero Seq. Computation' */
  /* Constant: '<S32>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S32>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S32>/Complex to Magnitude-Angle' */
  rtb_UnitDelay1_d[0] = rt_hypotd_snf(rtDW.Gain3_e.re, rtDW.Gain3_e.im);

  /* Outport: '<Root>/Out22' incorporates:
   *  Gain: '<Root>/to-pu3'
   */
  rtY.V1grid_pu = 4.8989794855663556E-5 * rtb_UnitDelay1_d[0];

  /* Outport: '<Root>/Out23' incorporates:
   *  Product: '<S21>/Product3'
   *  Trigonometry: '<S21>/Trigonometric Function2'
   */
  rtY.Qgrid = rtb_UnitDelay7 * sin(rtb_phi);

  /* Product: '<Root>/Product' incorporates:
   *  Product: '<S23>/Product'
   */
  rtb_phi = rtDW.StateSpace_o1[52] * rtDW.StateSpace_o1[66];

  /* DiscreteIntegrator: '<S380>/Integ4' incorporates:
   *  Product: '<Root>/Product'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_a != 0) {
    rtDW.Integ4_m = rtDW.Integ4_DSTATE_jc;
  } else {
    rtDW.Integ4_m = 2.5E-6 * rtb_phi + rtDW.Integ4_DSTATE_jc;
  }

  /* End of DiscreteIntegrator: '<S380>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S381>/S-Function' incorporates:
   *  Constant: '<S380>/K1'
   */

  /* Level2 S-Function Block: '<S381>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S380>/Switch' incorporates:
   *  Constant: '<S380>/K1'
   *  Constant: '<S380>/K2'
   *  DigitalClock: '<S380>/Digital  Clock'
   *  Gain: '<S380>/Gain'
   *  Gain: '<S380>/Gain1'
   *  Product: '<Root>/Product'
   *  Product: '<S380>/Product'
   *  RelationalOperator: '<S380>/Relational Operator'
   *  Sum: '<S380>/Sum1'
   *  Sum: '<S380>/Sum5'
   *  Sum: '<S380>/Sum7'
   *  UnitDelay: '<S380>/Unit Delay'
   *  UnitDelay: '<S380>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_o4 = (rtDW.Integ4_m - rtDW.SFunction_f) * 60.0 +
      (-0.00013333333333336367 * rtb_phi - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_bm);
  } else {
    rtb_Switch_o4 = rtDW.UnitDelay1_DSTATE_m0;
  }

  /* End of Switch: '<S380>/Switch' */

  /* Outport: '<Root>/Out2' */
  rtY.Pbuck = rtb_Switch_o4;

  /* Outport: '<Root>/Out24' */
  rtY.Vbuck = rtDW.StateSpace_o1[52];

  /* Outport: '<Root>/Out25' */
  rtY.Ibuck = rtDW.StateSpace_o1[66];

  /* Product: '<Root>/Product1' incorporates:
   *  Product: '<S23>/Product1'
   */
  rtb_Product1_g_tmp = rtDW.StateSpace_o1[51] * rtDW.StateSpace_o1[65];

  /* DiscreteIntegrator: '<S382>/Integ4' incorporates:
   *  Product: '<Root>/Product1'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_h != 0) {
    rtDW.Integ4_fr = rtDW.Integ4_DSTATE_id;
  } else {
    rtDW.Integ4_fr = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_DSTATE_id;
  }

  /* End of DiscreteIntegrator: '<S382>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S383>/S-Function' incorporates:
   *  Constant: '<S382>/K1'
   */

  /* Level2 S-Function Block: '<S383>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S382>/Switch' incorporates:
   *  Constant: '<S382>/K1'
   *  Constant: '<S382>/K2'
   *  DigitalClock: '<S382>/Digital  Clock'
   *  Gain: '<S382>/Gain'
   *  Gain: '<S382>/Gain1'
   *  Product: '<Root>/Product1'
   *  Product: '<S382>/Product'
   *  RelationalOperator: '<S382>/Relational Operator'
   *  Sum: '<S382>/Sum1'
   *  Sum: '<S382>/Sum5'
   *  Sum: '<S382>/Sum7'
   *  UnitDelay: '<S382>/Unit Delay'
   *  UnitDelay: '<S382>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_e0 = (rtDW.Integ4_fr - rtDW.SFunction_ct) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_g_tmp - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_cr);
  } else {
    rtb_Switch_e0 = rtDW.UnitDelay1_DSTATE_g;
  }

  /* End of Switch: '<S382>/Switch' */

  /* Outport: '<Root>/Out3' */
  rtY.Pboost = rtb_Switch_e0;

  /* Outport: '<Root>/Out32' */
  rtY.Vboost = rtDW.StateSpace_o1[51];

  /* Outport: '<Root>/Out33' */
  rtY.Iboost = rtDW.StateSpace_o1[65];

  /* Product: '<Root>/Product2' incorporates:
   *  Product: '<S23>/Product2'
   */
  rtb_Product2_tmp = rtDW.StateSpace_o1[58] * rtDW.StateSpace_o1[70];

  /* DiscreteIntegrator: '<S384>/Integ4' incorporates:
   *  Product: '<Root>/Product2'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_m != 0) {
    rtDW.Integ4_mt = rtDW.Integ4_DSTATE_h;
  } else {
    rtDW.Integ4_mt = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_DSTATE_h;
  }

  /* End of DiscreteIntegrator: '<S384>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S385>/S-Function' incorporates:
   *  Constant: '<S384>/K1'
   */

  /* Level2 S-Function Block: '<S385>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S384>/Switch' incorporates:
   *  Constant: '<S384>/K1'
   *  Constant: '<S384>/K2'
   *  DigitalClock: '<S384>/Digital  Clock'
   *  Gain: '<S384>/Gain'
   *  Gain: '<S384>/Gain1'
   *  Product: '<Root>/Product2'
   *  Product: '<S384>/Product'
   *  RelationalOperator: '<S384>/Relational Operator'
   *  Sum: '<S384>/Sum1'
   *  Sum: '<S384>/Sum5'
   *  Sum: '<S384>/Sum7'
   *  UnitDelay: '<S384>/Unit Delay'
   *  UnitDelay: '<S384>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_mg = (rtDW.Integ4_mt - rtDW.SFunction_n) * 60.0 +
      (-0.00013333333333336367 * rtb_Product2_tmp - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_m);
  } else {
    rtb_Switch_mg = rtDW.UnitDelay1_DSTATE_ags;
  }

  /* End of Switch: '<S384>/Switch' */

  /* Outport: '<Root>/Out4' */
  rtY.Pmotor = rtb_Switch_mg;

  /* Outport: '<Root>/Out37' */
  rtY.Vmotor = rtDW.StateSpace_o1[58];

  /* Outport: '<Root>/Out38' */
  rtY.Imotor_m = rtDW.StateSpace_o1[70];

  /* Product: '<Root>/Product3' incorporates:
   *  Product: '<S23>/Product3'
   */
  rtb_Product3_h_tmp = rtDW.StateSpace_o1[56] * rtDW.StateSpace_o1[68];

  /* DiscreteIntegrator: '<S386>/Integ4' incorporates:
   *  Product: '<Root>/Product3'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_o0 != 0) {
    rtDW.Integ4_ge = rtDW.Integ4_DSTATE_oi;
  } else {
    rtDW.Integ4_ge = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_DSTATE_oi;
  }

  /* End of DiscreteIntegrator: '<S386>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S387>/S-Function' incorporates:
   *  Constant: '<S386>/K1'
   */

  /* Level2 S-Function Block: '<S387>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S386>/Switch' incorporates:
   *  Constant: '<S386>/K1'
   *  Constant: '<S386>/K2'
   *  DigitalClock: '<S386>/Digital  Clock'
   *  Gain: '<S386>/Gain'
   *  Gain: '<S386>/Gain1'
   *  Product: '<Root>/Product3'
   *  Product: '<S386>/Product'
   *  RelationalOperator: '<S386>/Relational Operator'
   *  Sum: '<S386>/Sum1'
   *  Sum: '<S386>/Sum5'
   *  Sum: '<S386>/Sum7'
   *  UnitDelay: '<S386>/Unit Delay'
   *  UnitDelay: '<S386>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.02) {
    rtb_Switch_i2 = (rtDW.Integ4_ge - rtDW.SFunction_k) * 50.0 +
      (-1.1368683772159017E-16 * rtb_Product3_h_tmp - 2.5849394142282115E-29 *
       rtDW.UnitDelay_DSTATE_ez);
  } else {
    rtb_Switch_i2 = rtDW.UnitDelay1_DSTATE_lg;
  }

  /* End of Switch: '<S386>/Switch' */

  /* Outport: '<Root>/Out5' */
  rtY.PFB = rtb_Switch_i2;

  /* Outport: '<Root>/Out39' */
  rtY.VFB = rtDW.StateSpace_o1[56];

  /* Outport: '<Root>/Out40' */
  rtY.IFB = rtDW.StateSpace_o1[68];

  /* Sin: '<S388>/sin(wt)' */
  if (rtDW.systemEnable_m != 0) {
    rtDW.lastSin_m = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ovt = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_m = 0;
  }

  /* Product: '<S388>/Product' incorporates:
   *  Sin: '<S388>/sin(wt)'
   */
  rtb_Product_f = ((rtDW.lastSin_m * 0.99999822347173384 + rtDW.lastCos_ovt *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_ovt * 0.99999822347173384 - rtDW.lastSin_m *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[57];

  /* DiscreteIntegrator: '<S394>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_b != 0) {
    rtDW.Integ4_lf = rtDW.Integ4_DSTATE_pg;
  } else {
    rtDW.Integ4_lf = 2.5E-6 * rtb_Product_f + rtDW.Integ4_DSTATE_pg;
  }

  /* End of DiscreteIntegrator: '<S394>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S395>/S-Function' incorporates:
   *  Constant: '<S394>/K1'
   */

  /* Level2 S-Function Block: '<S395>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S394>/Switch' incorporates:
   *  Constant: '<S394>/K1'
   *  Constant: '<S394>/K2'
   *  DigitalClock: '<S394>/Digital  Clock'
   *  Gain: '<S394>/Gain'
   *  Gain: '<S394>/Gain1'
   *  Product: '<S394>/Product'
   *  RelationalOperator: '<S394>/Relational Operator'
   *  Sum: '<S394>/Sum1'
   *  Sum: '<S394>/Sum5'
   *  Sum: '<S394>/Sum7'
   *  UnitDelay: '<S394>/Unit Delay'
   *  UnitDelay: '<S394>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_d = (rtDW.Integ4_lf - rtDW.SFunction_o) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_f - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_aq);
  } else {
    rtb_Switch_d = rtDW.UnitDelay1_DSTATE_jx;
  }

  /* End of Switch: '<S394>/Switch' */

  /* Sin: '<S388>/cos(wt)' */
  if (rtDW.systemEnable_e2 != 0) {
    rtDW.lastSin_fl = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_nl = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e2 = 0;
  }

  /* Product: '<S388>/Product1' incorporates:
   *  Sin: '<S388>/cos(wt)'
   */
  rtb_Product1_eo = ((rtDW.lastSin_fl * 0.0018849544759281464 + rtDW.lastCos_nl *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_nl * 0.0018849544759281464 - rtDW.lastSin_fl *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[57];

  /* DiscreteIntegrator: '<S392>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_en != 0) {
    rtDW.Integ4_bp = rtDW.Integ4_DSTATE_oi0;
  } else {
    rtDW.Integ4_bp = 2.5E-6 * rtb_Product1_eo + rtDW.Integ4_DSTATE_oi0;
  }

  /* End of DiscreteIntegrator: '<S392>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S393>/S-Function' incorporates:
   *  Constant: '<S392>/K1'
   */

  /* Level2 S-Function Block: '<S393>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S392>/Switch' incorporates:
   *  Constant: '<S392>/K1'
   *  Constant: '<S392>/K2'
   *  DigitalClock: '<S392>/Digital  Clock'
   *  Gain: '<S392>/Gain'
   *  Gain: '<S392>/Gain1'
   *  Product: '<S392>/Product'
   *  RelationalOperator: '<S392>/Relational Operator'
   *  Sum: '<S392>/Sum1'
   *  Sum: '<S392>/Sum5'
   *  Sum: '<S392>/Sum7'
   *  UnitDelay: '<S392>/Unit Delay'
   *  UnitDelay: '<S392>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_eo = (rtDW.Integ4_bp - rtDW.SFunction_c5r) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_eo - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_cn);
  } else {
    rtb_Switch_eo = rtDW.UnitDelay1_DSTATE_k;
  }

  /* End of Switch: '<S392>/Switch' */

  /* ComplexToMagnitudeAngle: '<S388>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S388>/Real-Imag to Complex'
   */
  rtb_UnitDelay7 = rt_atan2d_snf(rtb_Switch_eo, rtb_Switch_d);

  /* Sin: '<S389>/sin(wt)' */
  if (rtDW.systemEnable_aq != 0) {
    rtDW.lastSin_p = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fl = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_aq = 0;
  }

  /* Product: '<S389>/Product' incorporates:
   *  Sin: '<S389>/sin(wt)'
   */
  rtb_Product_h4 = ((rtDW.lastSin_p * 0.99999822347173384 + rtDW.lastCos_fl *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_fl * 0.99999822347173384 - rtDW.lastSin_p *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[69];

  /* DiscreteIntegrator: '<S400>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_a3 != 0) {
    rtDW.Integ4_n = rtDW.Integ4_DSTATE_io;
  } else {
    rtDW.Integ4_n = 2.5E-6 * rtb_Product_h4 + rtDW.Integ4_DSTATE_io;
  }

  /* End of DiscreteIntegrator: '<S400>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S401>/S-Function' incorporates:
   *  Constant: '<S400>/K1'
   */

  /* Level2 S-Function Block: '<S401>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S400>/Switch' incorporates:
   *  Constant: '<S400>/K1'
   *  Constant: '<S400>/K2'
   *  DigitalClock: '<S400>/Digital  Clock'
   *  Gain: '<S400>/Gain'
   *  Gain: '<S400>/Gain1'
   *  Product: '<S400>/Product'
   *  RelationalOperator: '<S400>/Relational Operator'
   *  Sum: '<S400>/Sum1'
   *  Sum: '<S400>/Sum5'
   *  Sum: '<S400>/Sum7'
   *  UnitDelay: '<S400>/Unit Delay'
   *  UnitDelay: '<S400>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_os = (rtDW.Integ4_n - rtDW.SFunction_h1) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_h4 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_j);
  } else {
    rtb_Switch_os = rtDW.UnitDelay1_DSTATE_lz;
  }

  /* End of Switch: '<S400>/Switch' */

  /* Sin: '<S389>/cos(wt)' */
  if (rtDW.systemEnable_ac != 0) {
    rtDW.lastSin_e1 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h5 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ac = 0;
  }

  /* Product: '<S389>/Product1' incorporates:
   *  Sin: '<S389>/cos(wt)'
   */
  rtb_Product1_d = ((rtDW.lastSin_e1 * 0.0018849544759281464 + rtDW.lastCos_h5 *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_h5 * 0.0018849544759281464 - rtDW.lastSin_e1 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[69];

  /* DiscreteIntegrator: '<S398>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_kb != 0) {
    rtDW.Integ4_o = rtDW.Integ4_DSTATE_hw;
  } else {
    rtDW.Integ4_o = 2.5E-6 * rtb_Product1_d + rtDW.Integ4_DSTATE_hw;
  }

  /* End of DiscreteIntegrator: '<S398>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S399>/S-Function' incorporates:
   *  Constant: '<S398>/K1'
   */

  /* Level2 S-Function Block: '<S399>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S398>/Switch' incorporates:
   *  Constant: '<S398>/K1'
   *  Constant: '<S398>/K2'
   *  DigitalClock: '<S398>/Digital  Clock'
   *  Gain: '<S398>/Gain'
   *  Gain: '<S398>/Gain1'
   *  Product: '<S398>/Product'
   *  RelationalOperator: '<S398>/Relational Operator'
   *  Sum: '<S398>/Sum1'
   *  Sum: '<S398>/Sum5'
   *  Sum: '<S398>/Sum7'
   *  UnitDelay: '<S398>/Unit Delay'
   *  UnitDelay: '<S398>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_j = (rtDW.Integ4_o - rtDW.SFunction_j) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_d - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_hl);
  } else {
    rtb_Switch_j = rtDW.UnitDelay1_DSTATE_i;
  }

  /* End of Switch: '<S398>/Switch' */

  /* ComplexToMagnitudeAngle: '<S389>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S389>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_atan2d_snf(rtb_Switch_j, rtb_Switch_os);

  /* Gain: '<S20>/Gain1' incorporates:
   *  ComplexToMagnitudeAngle: '<S388>/Complex to Magnitude-Angle'
   *  ComplexToMagnitudeAngle: '<S389>/Complex to Magnitude-Angle'
   *  Product: '<S20>/Product'
   *  RealImagToComplex: '<S388>/Real-Imag to Complex'
   *  RealImagToComplex: '<S389>/Real-Imag to Complex'
   */
  rtb_Block4 = rt_hypotd_snf(rtb_Switch_d, rtb_Switch_eo) * rt_hypotd_snf
    (rtb_Switch_os, rtb_Switch_j) * 0.5;

  /* Gain: '<S20>/Deg->Rad' incorporates:
   *  Gain: '<S388>/Rad->Deg.'
   *  Gain: '<S389>/Rad->Deg.'
   *  Sum: '<S20>/Sum'
   */
  rtb_phi_b = (57.295779513082323 * rtb_UnitDelay7 - 57.295779513082323 *
               rtb_UnitDelay6) * 0.017453292519943295;

  /* Outport: '<Root>/Out6' incorporates:
   *  Product: '<S20>/Product1'
   *  Trigonometry: '<S20>/Trigonometric Function2'
   */
  rtY.PHB = rtb_Block4 * cos(rtb_phi_b);

  /* Outport: '<Root>/Out8' */
  rtY.VHB = rtDW.StateSpace_o1[57];

  /* Outport: '<Root>/Out9' */
  rtY.IHB = rtDW.StateSpace_o1[69];

  /* Outport: '<Root>/Out10' incorporates:
   *  Product: '<S20>/Product3'
   *  Trigonometry: '<S20>/Trigonometric Function2'
   */
  rtY.QHB = rtb_Block4 * sin(rtb_phi_b);

  /* Sin: '<S454>/sin(wt)' */
  if (rtDW.systemEnable_j != 0) {
    rtDW.lastSin_am = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ny = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_j = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_am * 0.99999822347173384 + rtDW.lastCos_ny *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ny * 0.99999822347173384 - rtDW.lastSin_am *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S454>/sin(wt)' */

  /* Product: '<S454>/Product' */
  rtb_phi_b = rtDW.StateSpace_o1[42] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S464>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_cl != 0) {
    rtDW.Integ4_mta = rtDW.Integ4_DSTATE_nf;
  } else {
    rtDW.Integ4_mta = 2.5E-6 * rtb_phi_b + rtDW.Integ4_DSTATE_nf;
  }

  /* End of DiscreteIntegrator: '<S464>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S465>/S-Function' incorporates:
   *  Constant: '<S464>/K1'
   */

  /* Level2 S-Function Block: '<S465>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S464>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S464>/Switch' incorporates:
   *  Constant: '<S464>/K1'
   *  Constant: '<S464>/K2'
   *  Gain: '<S464>/Gain'
   *  Gain: '<S464>/Gain1'
   *  Product: '<S464>/Product'
   *  RelationalOperator: '<S464>/Relational Operator'
   *  Sum: '<S464>/Sum1'
   *  Sum: '<S464>/Sum5'
   *  Sum: '<S464>/Sum7'
   *  UnitDelay: '<S464>/Unit Delay'
   *  UnitDelay: '<S464>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_m = (rtDW.Integ4_mta - rtDW.SFunction_i) * 60.0 +
      (-0.00013333333333336367 * rtb_phi_b - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_hw);
  } else {
    rtb_Switch_m = rtDW.UnitDelay1_DSTATE_gx;
  }

  /* End of Switch: '<S464>/Switch' */

  /* Sin: '<S454>/cos(wt)' */
  if (rtDW.systemEnable_gz != 0) {
    rtDW.lastSin_jo = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_on = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_gz = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_jo * 0.0018849544759281464 + rtDW.lastCos_on *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_on * 0.0018849544759281464 - rtDW.lastSin_jo *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S454>/cos(wt)' */

  /* Product: '<S454>/Product1' */
  rtb_Product1_jc = rtDW.StateSpace_o1[42] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S462>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i2 != 0) {
    rtDW.Integ4_oc = rtDW.Integ4_DSTATE_j5;
  } else {
    rtDW.Integ4_oc = 2.5E-6 * rtb_Product1_jc + rtDW.Integ4_DSTATE_j5;
  }

  /* End of DiscreteIntegrator: '<S462>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S463>/S-Function' incorporates:
   *  Constant: '<S462>/K1'
   */

  /* Level2 S-Function Block: '<S463>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S462>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S462>/Switch' incorporates:
   *  Constant: '<S462>/K1'
   *  Constant: '<S462>/K2'
   *  Gain: '<S462>/Gain'
   *  Gain: '<S462>/Gain1'
   *  Product: '<S462>/Product'
   *  RelationalOperator: '<S462>/Relational Operator'
   *  Sum: '<S462>/Sum1'
   *  Sum: '<S462>/Sum5'
   *  Sum: '<S462>/Sum7'
   *  UnitDelay: '<S462>/Unit Delay'
   *  UnitDelay: '<S462>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_dc = (rtDW.Integ4_oc - rtDW.SFunction_ge) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_jc - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ai);
  } else {
    rtb_Switch_dc = rtDW.UnitDelay1_DSTATE_d;
  }

  /* End of Switch: '<S462>/Switch' */

  /* ComplexToMagnitudeAngle: '<S454>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S454>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_hypotd_snf(rtb_Switch_m, rtb_Switch_dc);

  /* Gain: '<S452>/deg->rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S454>/Complex to Magnitude-Angle'
   *  Gain: '<S454>/Rad->Deg.'
   *  RealImagToComplex: '<S454>/Real-Imag to Complex'
   */
  rtb_Block4 = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_dc, rtb_Switch_m) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S452>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay6 * cos(rtb_Block4);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay6 * sin(rtb_Block4);

  /* Sin: '<S455>/sin(wt)' */
  if (rtDW.systemEnable_lb != 0) {
    rtDW.lastSin_pp = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ob = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_lb = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_pp * 0.99999822347173384 + rtDW.lastCos_ob *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ob * 0.99999822347173384 - rtDW.lastSin_pp *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S455>/sin(wt)' */

  /* Product: '<S455>/Product' */
  rtb_Product_aa = rtDW.StateSpace_o1[43] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S470>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bc != 0) {
    rtDW.Integ4_do = rtDW.Integ4_DSTATE_a;
  } else {
    rtDW.Integ4_do = 2.5E-6 * rtb_Product_aa + rtDW.Integ4_DSTATE_a;
  }

  /* End of DiscreteIntegrator: '<S470>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S471>/S-Function' incorporates:
   *  Constant: '<S470>/K1'
   */

  /* Level2 S-Function Block: '<S471>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S470>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S470>/Switch' incorporates:
   *  Constant: '<S470>/K1'
   *  Constant: '<S470>/K2'
   *  Gain: '<S470>/Gain'
   *  Gain: '<S470>/Gain1'
   *  Product: '<S470>/Product'
   *  RelationalOperator: '<S470>/Relational Operator'
   *  Sum: '<S470>/Sum1'
   *  Sum: '<S470>/Sum5'
   *  Sum: '<S470>/Sum7'
   *  UnitDelay: '<S470>/Unit Delay'
   *  UnitDelay: '<S470>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_e = (rtDW.Integ4_do - rtDW.SFunction_jm) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_aa - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_lw);
  } else {
    rtb_Switch_e = rtDW.UnitDelay1_DSTATE_m5;
  }

  /* End of Switch: '<S470>/Switch' */

  /* Sin: '<S455>/cos(wt)' */
  if (rtDW.systemEnable_i != 0) {
    rtDW.lastSin_i = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_b = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_i = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_i * 0.0018849544759281464 + rtDW.lastCos_b *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_b * 0.0018849544759281464 - rtDW.lastSin_i *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S455>/cos(wt)' */

  /* Product: '<S455>/Product1' */
  rtb_Product1_j = rtDW.StateSpace_o1[43] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S468>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gs != 0) {
    rtDW.Integ4_nk = rtDW.Integ4_DSTATE_k;
  } else {
    rtDW.Integ4_nk = 2.5E-6 * rtb_Product1_j + rtDW.Integ4_DSTATE_k;
  }

  /* End of DiscreteIntegrator: '<S468>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */

  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S468>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S468>/Switch' incorporates:
   *  Constant: '<S468>/K1'
   *  Constant: '<S468>/K2'
   *  Gain: '<S468>/Gain'
   *  Gain: '<S468>/Gain1'
   *  Product: '<S468>/Product'
   *  RelationalOperator: '<S468>/Relational Operator'
   *  Sum: '<S468>/Sum1'
   *  Sum: '<S468>/Sum5'
   *  Sum: '<S468>/Sum7'
   *  UnitDelay: '<S468>/Unit Delay'
   *  UnitDelay: '<S468>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_h = (rtDW.Integ4_nk - rtDW.SFunction_et) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_j - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ei);
  } else {
    rtb_Switch_h = rtDW.UnitDelay1_DSTATE_b;
  }

  /* End of Switch: '<S468>/Switch' */

  /* ComplexToMagnitudeAngle: '<S455>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S455>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_hypotd_snf(rtb_Switch_e, rtb_Switch_h);

  /* Gain: '<S452>/deg->rad1' incorporates:
   *  ComplexToMagnitudeAngle: '<S455>/Complex to Magnitude-Angle'
   *  Gain: '<S455>/Rad->Deg.'
   *  RealImagToComplex: '<S455>/Real-Imag to Complex'
   */
  rtb_Block4 = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_h, rtb_Switch_e) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S452>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay6 * cos(rtb_Block4);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay6 * sin(rtb_Block4);

  /* Sin: '<S456>/sin(wt)' */
  if (rtDW.systemEnable_bk != 0) {
    rtDW.lastSin_hb = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_i4 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bk = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_hb * 0.99999822347173384 + rtDW.lastCos_i4 *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_i4 * 0.99999822347173384 - rtDW.lastSin_hb *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S456>/sin(wt)' */

  /* Product: '<S456>/Product' */
  rtb_Product_p = rtDW.StateSpace_o1[44] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S476>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jz != 0) {
    rtDW.Integ4_pl = rtDW.Integ4_DSTATE_kd;
  } else {
    rtDW.Integ4_pl = 2.5E-6 * rtb_Product_p + rtDW.Integ4_DSTATE_kd;
  }

  /* End of DiscreteIntegrator: '<S476>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S477>/S-Function' incorporates:
   *  Constant: '<S476>/K1'
   */

  /* Level2 S-Function Block: '<S477>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S476>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S476>/Switch' incorporates:
   *  Constant: '<S476>/K1'
   *  Constant: '<S476>/K2'
   *  Gain: '<S476>/Gain'
   *  Gain: '<S476>/Gain1'
   *  Product: '<S476>/Product'
   *  RelationalOperator: '<S476>/Relational Operator'
   *  Sum: '<S476>/Sum1'
   *  Sum: '<S476>/Sum5'
   *  Sum: '<S476>/Sum7'
   *  UnitDelay: '<S476>/Unit Delay'
   *  UnitDelay: '<S476>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_on = (rtDW.Integ4_pl - rtDW.SFunction_ko) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_p - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_jz);
  } else {
    rtb_Switch_on = rtDW.UnitDelay1_DSTATE_a1;
  }

  /* End of Switch: '<S476>/Switch' */

  /* Sin: '<S456>/cos(wt)' */
  if (rtDW.systemEnable_oz != 0) {
    rtDW.lastSin_fw = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_p = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_oz = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_fw * 0.0018849544759281464 + rtDW.lastCos_p *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_p * 0.0018849544759281464 - rtDW.lastSin_fw *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S456>/cos(wt)' */

  /* Product: '<S456>/Product1' */
  rtb_Product1_nw = rtDW.StateSpace_o1[44] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S474>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bm != 0) {
    rtDW.Integ4_nkx = rtDW.Integ4_DSTATE_me;
  } else {
    rtDW.Integ4_nkx = 2.5E-6 * rtb_Product1_nw + rtDW.Integ4_DSTATE_me;
  }

  /* End of DiscreteIntegrator: '<S474>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */

  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S474>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S474>/Switch' incorporates:
   *  Constant: '<S474>/K1'
   *  Constant: '<S474>/K2'
   *  Gain: '<S474>/Gain'
   *  Gain: '<S474>/Gain1'
   *  Product: '<S474>/Product'
   *  RelationalOperator: '<S474>/Relational Operator'
   *  Sum: '<S474>/Sum1'
   *  Sum: '<S474>/Sum5'
   *  Sum: '<S474>/Sum7'
   *  UnitDelay: '<S474>/Unit Delay'
   *  UnitDelay: '<S474>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_cd = (rtDW.Integ4_nkx - rtDW.SFunction_ey) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_nw - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_b2);
  } else {
    rtb_Switch_cd = rtDW.UnitDelay1_DSTATE_ea;
  }

  /* End of Switch: '<S474>/Switch' */

  /* ComplexToMagnitudeAngle: '<S456>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S456>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_hypotd_snf(rtb_Switch_on, rtb_Switch_cd);

  /* Gain: '<S452>/deg->rad2' incorporates:
   *  ComplexToMagnitudeAngle: '<S456>/Complex to Magnitude-Angle'
   *  Gain: '<S456>/Rad->Deg.'
   *  RealImagToComplex: '<S456>/Real-Imag to Complex'
   */
  rtb_Block4 = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_cd, rtb_Switch_on) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S452>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay6 * cos(rtb_Block4);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay6 * sin(rtb_Block4);

  /* Outputs for Enabled SubSystem: '<S452>/Pos. Seq. Computation' */
  /* Constant: '<S452>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_en);

  /* End of Outputs for SubSystem: '<S452>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S452>/Neg. Seq. Computation' */
  /* Constant: '<S452>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_l);

  /* End of Outputs for SubSystem: '<S452>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S452>/Zero Seq. Computation' */
  /* Constant: '<S452>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &rtDW.Gain3_o);

  /* End of Outputs for SubSystem: '<S452>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S452>/Complex to Magnitude-Angle' */
  rtb_UnitDelay1_d[0] = rt_hypotd_snf(rtDW.Gain3_en.re, rtDW.Gain3_en.im);
  rtb_UnitDelay4[0] = rt_atan2d_snf(rtDW.Gain3_en.im, rtDW.Gain3_en.re);

  /* Sin: '<S478>/sin(wt)' */
  if (rtDW.systemEnable_cd != 0) {
    rtDW.lastSin_dz = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_b4 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_cd = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_dz * 0.99999822347173384 + rtDW.lastCos_b4 *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_b4 * 0.99999822347173384 - rtDW.lastSin_dz *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S478>/sin(wt)' */

  /* Product: '<S478>/Product' */
  rtb_Product_bo = rtDW.StateSpace_o1[59] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S488>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ke != 0) {
    rtDW.Integ4_mr = rtDW.Integ4_DSTATE_ip;
  } else {
    rtDW.Integ4_mr = 2.5E-6 * rtb_Product_bo + rtDW.Integ4_DSTATE_ip;
  }

  /* End of DiscreteIntegrator: '<S488>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S489>/S-Function' incorporates:
   *  Constant: '<S488>/K1'
   */

  /* Level2 S-Function Block: '<S489>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S488>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S488>/Switch' incorporates:
   *  Constant: '<S488>/K1'
   *  Constant: '<S488>/K2'
   *  Gain: '<S488>/Gain'
   *  Gain: '<S488>/Gain1'
   *  Product: '<S488>/Product'
   *  RelationalOperator: '<S488>/Relational Operator'
   *  Sum: '<S488>/Sum1'
   *  Sum: '<S488>/Sum5'
   *  Sum: '<S488>/Sum7'
   *  UnitDelay: '<S488>/Unit Delay'
   *  UnitDelay: '<S488>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_l = (rtDW.Integ4_mr - rtDW.SFunction_iz) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_bo - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_fp);
  } else {
    rtb_Switch_l = rtDW.UnitDelay1_DSTATE_ma;
  }

  /* End of Switch: '<S488>/Switch' */

  /* Sin: '<S478>/cos(wt)' */
  if (rtDW.systemEnable_jg != 0) {
    rtDW.lastSin_jd = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ih = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_jg = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_jd * 0.0018849544759281464 + rtDW.lastCos_ih *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_ih * 0.0018849544759281464 - rtDW.lastSin_jd *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S478>/cos(wt)' */

  /* Product: '<S478>/Product1' */
  rtb_Product1_ls = rtDW.StateSpace_o1[59] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S486>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_oh != 0) {
    rtDW.Integ4_dg = rtDW.Integ4_DSTATE_dq;
  } else {
    rtDW.Integ4_dg = 2.5E-6 * rtb_Product1_ls + rtDW.Integ4_DSTATE_dq;
  }

  /* End of DiscreteIntegrator: '<S486>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S487>/S-Function' incorporates:
   *  Constant: '<S486>/K1'
   */

  /* Level2 S-Function Block: '<S487>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S486>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S486>/Switch' incorporates:
   *  Constant: '<S486>/K1'
   *  Constant: '<S486>/K2'
   *  Gain: '<S486>/Gain'
   *  Gain: '<S486>/Gain1'
   *  Product: '<S486>/Product'
   *  RelationalOperator: '<S486>/Relational Operator'
   *  Sum: '<S486>/Sum1'
   *  Sum: '<S486>/Sum5'
   *  Sum: '<S486>/Sum7'
   *  UnitDelay: '<S486>/Unit Delay'
   *  UnitDelay: '<S486>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_id = (rtDW.Integ4_dg - rtDW.SFunction_ff) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_ls - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_gf);
  } else {
    rtb_Switch_id = rtDW.UnitDelay1_DSTATE_e2;
  }

  /* End of Switch: '<S486>/Switch' */

  /* ComplexToMagnitudeAngle: '<S478>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S478>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_hypotd_snf(rtb_Switch_l, rtb_Switch_id);

  /* Gain: '<S453>/deg->rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S478>/Complex to Magnitude-Angle'
   *  Gain: '<S478>/Rad->Deg.'
   *  RealImagToComplex: '<S478>/Real-Imag to Complex'
   */
  rtb_Block4 = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_id, rtb_Switch_l) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S453>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay6 * cos(rtb_Block4);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay6 * sin(rtb_Block4);

  /* Sin: '<S479>/sin(wt)' */
  if (rtDW.systemEnable_av != 0) {
    rtDW.lastSin_n = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_hr = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_av = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_n * 0.99999822347173384 + rtDW.lastCos_hr *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_hr * 0.99999822347173384 - rtDW.lastSin_n *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S479>/sin(wt)' */

  /* Product: '<S479>/Product' */
  rtb_Product_i = rtDW.StateSpace_o1[60] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S494>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_lx != 0) {
    rtDW.Integ4_e = rtDW.Integ4_DSTATE_le;
  } else {
    rtDW.Integ4_e = 2.5E-6 * rtb_Product_i + rtDW.Integ4_DSTATE_le;
  }

  /* End of DiscreteIntegrator: '<S494>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */

  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S494>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S494>/Switch' incorporates:
   *  Constant: '<S494>/K1'
   *  Constant: '<S494>/K2'
   *  Gain: '<S494>/Gain'
   *  Gain: '<S494>/Gain1'
   *  Product: '<S494>/Product'
   *  RelationalOperator: '<S494>/Relational Operator'
   *  Sum: '<S494>/Sum1'
   *  Sum: '<S494>/Sum5'
   *  Sum: '<S494>/Sum7'
   *  UnitDelay: '<S494>/Unit Delay'
   *  UnitDelay: '<S494>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_lq = (rtDW.Integ4_e - rtDW.SFunction_b) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_i - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_d);
  } else {
    rtb_Switch_lq = rtDW.UnitDelay1_DSTATE_gb;
  }

  /* End of Switch: '<S494>/Switch' */

  /* Sin: '<S479>/cos(wt)' */
  if (rtDW.systemEnable_oh != 0) {
    rtDW.lastSin_o2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_dm = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_oh = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_o2 * 0.0018849544759281464 + rtDW.lastCos_dm *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_dm * 0.0018849544759281464 - rtDW.lastSin_o2 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S479>/cos(wt)' */

  /* Product: '<S479>/Product1' */
  rtb_Product1_ce = rtDW.StateSpace_o1[60] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S492>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_of != 0) {
    rtDW.Integ4_g4 = rtDW.Integ4_DSTATE_ox;
  } else {
    rtDW.Integ4_g4 = 2.5E-6 * rtb_Product1_ce + rtDW.Integ4_DSTATE_ox;
  }

  /* End of DiscreteIntegrator: '<S492>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */

  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S492>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S492>/Switch' incorporates:
   *  Constant: '<S492>/K1'
   *  Constant: '<S492>/K2'
   *  Gain: '<S492>/Gain'
   *  Gain: '<S492>/Gain1'
   *  Product: '<S492>/Product'
   *  RelationalOperator: '<S492>/Relational Operator'
   *  Sum: '<S492>/Sum1'
   *  Sum: '<S492>/Sum5'
   *  Sum: '<S492>/Sum7'
   *  UnitDelay: '<S492>/Unit Delay'
   *  UnitDelay: '<S492>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_p0 = (rtDW.Integ4_g4 - rtDW.SFunction_gv) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_ce - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_hz);
  } else {
    rtb_Switch_p0 = rtDW.UnitDelay1_DSTATE_dz;
  }

  /* End of Switch: '<S492>/Switch' */

  /* ComplexToMagnitudeAngle: '<S479>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S479>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_hypotd_snf(rtb_Switch_lq, rtb_Switch_p0);

  /* Gain: '<S453>/deg->rad1' incorporates:
   *  ComplexToMagnitudeAngle: '<S479>/Complex to Magnitude-Angle'
   *  Gain: '<S479>/Rad->Deg.'
   *  RealImagToComplex: '<S479>/Real-Imag to Complex'
   */
  rtb_Block4 = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_p0, rtb_Switch_lq) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S453>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay6 * cos(rtb_Block4);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay6 * sin(rtb_Block4);

  /* Sin: '<S480>/sin(wt)' */
  if (rtDW.systemEnable_bn != 0) {
    rtDW.lastSin_e2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_m = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bn = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_e2 * 0.99999822347173384 + rtDW.lastCos_m *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_m * 0.99999822347173384 - rtDW.lastSin_e2 *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S480>/sin(wt)' */

  /* Product: '<S480>/Product' */
  rtb_Product_lv = rtDW.StateSpace_o1[61] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S500>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_p != 0) {
    rtDW.Integ4_ao = rtDW.Integ4_DSTATE_gb;
  } else {
    rtDW.Integ4_ao = 2.5E-6 * rtb_Product_lv + rtDW.Integ4_DSTATE_gb;
  }

  /* End of DiscreteIntegrator: '<S500>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */

  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S500>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S500>/Switch' incorporates:
   *  Constant: '<S500>/K1'
   *  Constant: '<S500>/K2'
   *  Gain: '<S500>/Gain'
   *  Gain: '<S500>/Gain1'
   *  Product: '<S500>/Product'
   *  RelationalOperator: '<S500>/Relational Operator'
   *  Sum: '<S500>/Sum1'
   *  Sum: '<S500>/Sum5'
   *  Sum: '<S500>/Sum7'
   *  UnitDelay: '<S500>/Unit Delay'
   *  UnitDelay: '<S500>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_k = (rtDW.Integ4_ao - rtDW.SFunction_l5) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_lv - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_cm);
  } else {
    rtb_Switch_k = rtDW.UnitDelay1_DSTATE_jz;
  }

  /* End of Switch: '<S500>/Switch' */

  /* Sin: '<S480>/cos(wt)' */
  if (rtDW.systemEnable_na != 0) {
    rtDW.lastSin_dm = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ie = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_na = 0;
  }

  rtb_UnitDelay6 = ((rtDW.lastSin_dm * 0.0018849544759281464 + rtDW.lastCos_ie *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_ie * 0.0018849544759281464 - rtDW.lastSin_dm *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S480>/cos(wt)' */

  /* Product: '<S480>/Product1' */
  rtb_Product1_iha = rtDW.StateSpace_o1[61] * rtb_UnitDelay6;

  /* DiscreteIntegrator: '<S498>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_on != 0) {
    rtDW.Integ4_mk = rtDW.Integ4_DSTATE_ia;
  } else {
    rtDW.Integ4_mk = 2.5E-6 * rtb_Product1_iha + rtDW.Integ4_DSTATE_ia;
  }

  /* End of DiscreteIntegrator: '<S498>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */

  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S498>/Digital  Clock' */
  rtb_UnitDelay6 = rtM->Timing.t[0];

  /* Switch: '<S498>/Switch' incorporates:
   *  Constant: '<S498>/K1'
   *  Constant: '<S498>/K2'
   *  Gain: '<S498>/Gain'
   *  Gain: '<S498>/Gain1'
   *  Product: '<S498>/Product'
   *  RelationalOperator: '<S498>/Relational Operator'
   *  Sum: '<S498>/Sum1'
   *  Sum: '<S498>/Sum5'
   *  Sum: '<S498>/Sum7'
   *  UnitDelay: '<S498>/Unit Delay'
   *  UnitDelay: '<S498>/Unit Delay1'
   */
  if (rtb_UnitDelay6 >= 0.01667) {
    rtb_Switch_kp = (rtDW.Integ4_mk - rtDW.SFunction_gy) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_iha - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_lx);
  } else {
    rtb_Switch_kp = rtDW.UnitDelay1_DSTATE_pq;
  }

  /* End of Switch: '<S498>/Switch' */

  /* ComplexToMagnitudeAngle: '<S480>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S480>/Real-Imag to Complex'
   */
  rtb_UnitDelay6 = rt_hypotd_snf(rtb_Switch_k, rtb_Switch_kp);

  /* Gain: '<S453>/deg->rad2' incorporates:
   *  ComplexToMagnitudeAngle: '<S480>/Complex to Magnitude-Angle'
   *  Gain: '<S480>/Rad->Deg.'
   *  RealImagToComplex: '<S480>/Real-Imag to Complex'
   */
  rtb_Block4 = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_kp, rtb_Switch_k) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S453>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay6 * cos(rtb_Block4);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay6 * sin(rtb_Block4);

  /* Outputs for Enabled SubSystem: '<S453>/Pos. Seq. Computation' */
  /* Constant: '<S453>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_f);

  /* End of Outputs for SubSystem: '<S453>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S453>/Neg. Seq. Computation' */
  /* Constant: '<S453>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_kl);

  /* End of Outputs for SubSystem: '<S453>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S453>/Zero Seq. Computation' */
  /* Constant: '<S453>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S453>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S453>/Complex to Magnitude-Angle' */
  rtb_UnitDelay3[0] = rt_hypotd_snf(rtDW.Gain3_f.re, rtDW.Gain3_f.im);
  rtb_UnitDelay_ai[0] = rt_atan2d_snf(rtDW.Gain3_f.im, rtDW.Gain3_f.re);

  /* Product: '<S22>/Product' */
  rtb_UnitDelay6 = rtb_UnitDelay1_d[0] * rtb_UnitDelay3[0];

  /* Gain: '<S22>/Gain1' */
  rtb_UnitDelay6 *= 1.5;

  /* Gain: '<S453>/rad->deg1' */
  rtb_UnitDelay7 = 57.295779513082323 * rtb_UnitDelay_ai[0];

  /* Gain: '<S22>/Deg->Rad' incorporates:
   *  Gain: '<S452>/rad->deg1'
   *  Sum: '<S22>/Sum'
   */
  rtb_phi_f = (57.295779513082323 * rtb_UnitDelay4[0] - rtb_UnitDelay7) *
    0.017453292519943295;

  /* Outport: '<Root>/Out7' incorporates:
   *  Product: '<S22>/Product1'
   *  Trigonometry: '<S22>/Trigonometric Function2'
   */
  rtY.PQstat[0] = rtb_UnitDelay6 * cos(rtb_phi_f);

  /* Product: '<S22>/Product3' incorporates:
   *  Trigonometry: '<S22>/Trigonometric Function2'
   */
  rtb_UnitDelay6 *= sin(rtb_phi_f);

  /* Outport: '<Root>/Out7' */
  rtY.PQstat[1] = rtb_UnitDelay6;

  /* Outport: '<Root>/Out30' */
  rtY.Vstat[0] = rtDW.StateSpace_o1[42];

  /* Outport: '<Root>/Out31' */
  rtY.Istat[0] = rtDW.StateSpace_o1[59];

  /* Outport: '<Root>/Out30' */
  rtY.Vstat[1] = rtDW.StateSpace_o1[43];

  /* Outport: '<Root>/Out31' */
  rtY.Istat[1] = rtDW.StateSpace_o1[60];

  /* Outport: '<Root>/Out30' */
  rtY.Vstat[2] = rtDW.StateSpace_o1[44];

  /* Outport: '<Root>/Out31' */
  rtY.Istat[2] = rtDW.StateSpace_o1[61];

  /* UnitDelay: '<S5>/Unit Delay2' */
  rtb_phi_f = rtDW.UnitDelay2_DSTATE;

  /* RateTransition: '<S71>/Rate Transition5' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition5_Buffer = rtb_phi_f;
  }

  /* End of RateTransition: '<S71>/Rate Transition5' */

  /* UnitDelay: '<S5>/Unit Delay1' */
  rtb_UnitDelay1_d[0] = rtDW.UnitDelay1_DSTATE_o0[0];
  rtb_UnitDelay1_d[1] = rtDW.UnitDelay1_DSTATE_o0[1];
  rtb_UnitDelay1_d[2] = rtDW.UnitDelay1_DSTATE_o0[2];

  /* RateTransition: '<S71>/Rate Transition6' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition6_Buffer[0] = rtb_UnitDelay1_d[0];
    rtDW.RateTransition6_Buffer[1] = rtb_UnitDelay1_d[1];
    rtDW.RateTransition6_Buffer[2] = rtb_UnitDelay1_d[2];

    /* RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3[0] = rtDW.RateTransition3_Buffer0[0];
    rtDW.RateTransition3[1] = rtDW.RateTransition3_Buffer0[1];
  }

  /* End of RateTransition: '<S71>/Rate Transition6' */

  /* Sum: '<S238>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S238>/D*u(k)'
   *  Gain: '<S241>/C11'
   *  Gain: '<S241>/C12'
   *  Sum: '<S241>/sum2'
   *  UnitDelay: '<S238>/Delay_x1'
   *  UnitDelay: '<S238>/Delay_x2'
   *  UnitDelay: '<S71>/Unit Delay'
   */
  rtb_UnitDelay6 = (444.06110962854092 * rtDW.Delay_x1_DSTATE_o +
                    0.0010601835537138449 * rtDW.Delay_x2_DSTATE_i) +
    0.00053009177685692244 * rtDW.UnitDelay_DSTATE_dm;

  /* Saturate: '<S182>/0.8 to 1.2 x Vnom_dc' */
  if (rtb_UnitDelay6 > 1500.0) {
    rtb_UnitDelay6 = 1500.0;
  } else {
    if (rtb_UnitDelay6 < 500.0) {
      rtb_UnitDelay6 = 500.0;
    }
  }

  /* End of Saturate: '<S182>/0.8 to 1.2 x Vnom_dc' */

  /* Product: '<S182>/Product' incorporates:
   *  Constant: '<S182>/Constant1'
   *  Gain: '<S182>/Gain1'
   */
  rtb_UnitDelay6 = 489.89794855663553 / (0.61237243569579447 * rtb_UnitDelay6);

  /* Product: '<S182>/Product1' incorporates:
   *  Constant: '<S71>/Constant'
   */
  rtb_UnitDelay1_d[0] = rtDW.RateTransition3[0] * rtb_UnitDelay6;
  rtb_UnitDelay1_d[1] = rtDW.RateTransition3[1] * rtb_UnitDelay6;
  rtb_UnitDelay1_d[2] = 0.0 * rtb_UnitDelay6;

  /* RateTransition: '<S71>/Rate Transition1' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition1_Buffer[0] = rtb_UnitDelay1_d[0];
    rtDW.RateTransition1_Buffer[1] = rtb_UnitDelay1_d[1];
    rtDW.RateTransition1_Buffer[2] = rtb_UnitDelay1_d[2];
  }

  /* End of RateTransition: '<S71>/Rate Transition1' */

  /* Outport: '<Root>/Out14' */
  rtY.Vsec_3L_LLA = rtDW.StateSpace_o1[45];

  /* Outport: '<Root>/Out15' */
  rtY.Vsec_3L_LLB = rtDW.StateSpace_o1[46];

  /* Outport: '<Root>/Out16' */
  rtY.Vsec_3L_LLC = rtDW.StateSpace_o1[47];

  /* Sum: '<S10>/Add' */
  rtb_Add = rtDW.StateSpace_o1[53] + rtDW.StateSpace_o1[54];

  /* Outport: '<Root>/Out17' */
  rtY.Vdc_3L = rtb_Add;

  /* Outport: '<Root>/Out18' */
  rtY.VdcP_3L = rtDW.StateSpace_o1[53];

  /* Outport: '<Root>/Out19' */
  rtY.VdcM_3L = rtDW.StateSpace_o1[54];

  /* UnitDelay: '<S5>/Unit Delay5' */
  rtb_UnitDelay5 = rtDW.UnitDelay5_DSTATE;

  /* RateTransition: '<S72>/Rate Transition5' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition5_Buffer_a = rtb_UnitDelay5;
  }

  /* End of RateTransition: '<S72>/Rate Transition5' */

  /* UnitDelay: '<S5>/Unit Delay4' */
  rtb_UnitDelay4[0] = rtDW.UnitDelay4_DSTATE[0];
  rtb_UnitDelay4[1] = rtDW.UnitDelay4_DSTATE[1];
  rtb_UnitDelay4[2] = rtDW.UnitDelay4_DSTATE[2];

  /* RateTransition: '<S72>/Rate Transition6' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition6_Buffer_d[0] = rtb_UnitDelay4[0];
    rtDW.RateTransition6_Buffer_d[1] = rtb_UnitDelay4[1];
    rtDW.RateTransition6_Buffer_d[2] = rtb_UnitDelay4[2];

    /* RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_a[0] = rtDW.RateTransition3_Buffer0_a[0];
    rtDW.RateTransition3_a[1] = rtDW.RateTransition3_Buffer0_a[1];
  }

  /* End of RateTransition: '<S72>/Rate Transition6' */

  /* Sum: '<S317>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S317>/D*u(k)'
   *  Gain: '<S320>/C11'
   *  Gain: '<S320>/C12'
   *  Sum: '<S320>/sum2'
   *  UnitDelay: '<S317>/Delay_x1'
   *  UnitDelay: '<S317>/Delay_x2'
   *  UnitDelay: '<S72>/Unit Delay'
   */
  rtb_UnitDelay6 = (444.06110962854092 * rtDW.Delay_x1_DSTATE_py +
                    0.0010601835537138449 * rtDW.Delay_x2_DSTATE_c) +
    0.00053009177685692244 * rtDW.UnitDelay_DSTATE_ok;

  /* Saturate: '<S258>/0.5 to 1.5 x Vnom_dc' */
  if (rtb_UnitDelay6 > 3600.0) {
    rtb_UnitDelay6 = 3600.0;
  } else {
    if (rtb_UnitDelay6 < 1200.0) {
      rtb_UnitDelay6 = 1200.0;
    }
  }

  /* End of Saturate: '<S258>/0.5 to 1.5 x Vnom_dc' */

  /* Product: '<S258>/Product' incorporates:
   *  Constant: '<S258>/Constant2'
   */
  rtb_UnitDelay6 = 1837.1173070873838 / rtb_UnitDelay6;

  /* Product: '<S258>/Product1' incorporates:
   *  Constant: '<S72>/Constant'
   */
  rtb_UnitDelay_ai[0] = rtDW.RateTransition3_a[0] * rtb_UnitDelay6;
  rtb_UnitDelay_ai[1] = rtDW.RateTransition3_a[1] * rtb_UnitDelay6;
  rtb_UnitDelay_ai[2] = 0.0 * rtb_UnitDelay6;

  /* RateTransition: '<S72>/Rate Transition1' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition1_Buffer_n[0] = rtb_UnitDelay_ai[0];
    rtDW.RateTransition1_Buffer_n[1] = rtb_UnitDelay_ai[1];
    rtDW.RateTransition1_Buffer_n[2] = rtb_UnitDelay_ai[2];
  }

  /* End of RateTransition: '<S72>/Rate Transition1' */

  /* Outport: '<Root>/Out29' */
  rtY.Vdc_stat = rtDW.StateSpace_o1[55];

  /* UnitDelay: '<S5>/Unit Delay6' */
  rtb_UnitDelay6 = rtDW.UnitDelay6_DSTATE;

  /* RateTransition: '<S63>/Rate Transition1' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition1_Buffer_b = rtb_UnitDelay6;

    /* RateTransition: '<Root>/Rate Transition1' */
    rtDW.RateTransition1_Buffer_p = rtDW.StateSpace_o1[70];

    /* RateTransition: '<S63>/Rate Transition2' */
    rtDW.RateTransition2 = rtDW.RateTransition2_Buffer0;

    /* RateTransition: '<Root>/Rate Transition2' */
    rtDW.RateTransition2_Buffer = rtDW.RateTransition2;
  }

  /* End of RateTransition: '<S63>/Rate Transition1' */

  /* Gain: '<S5>/Rad2Rpm1' incorporates:
   *  DiscreteIntegrator: '<S334>/Discrete-Time Integrator'
   */
  rtb_UnitDelay6 = 9.5492965855137211 * rtDW.DiscreteTimeIntegrator_DSTATE;

  /* Outport: '<Root>/Out36' */
  rtY.w_motor = rtb_UnitDelay6;

  /* Step: '<S5>/Block4' */
  rtb_UnitDelay7 = rtM->Timing.t[0];
  rtb_Block4 = (rtb_UnitDelay7 < 0.05);

  /* DataTypeConversion: '<S43>/Data Type Conversion1' incorporates:
   *  Constant: '<S44>/Constant'
   *  RelationalOperator: '<S44>/Compare'
   */
  rtb_UnitDelay7 = (rtb_Block4 <= 0.5);

  /* Outputs for Enabled SubSystem: '<S67>/PWM Gen' incorporates:
   *  EnablePort: '<S129>/Enable'
   */
  if (!rtDW.PWMGen_MODE_e) {
    /* Enable for DiscreteIntegrator: '<S132>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_gy2 = 1U;
    rtDW.PWMGen_MODE_e = true;
  }

  /* Outputs for Enabled SubSystem: '<S65>/Subsystem' incorporates:
   *  EnablePort: '<S107>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S68>/PWM Gen' incorporates:
   *  EnablePort: '<S137>/Enable'
   */
  /* Fcn: '<S131>/Fcn' incorporates:
   *  Constant: '<S136>/Constant2'
   *  DigitalClock: '<S136>/Digital Clock'
   *  Fcn: '<S109>/Fcn'
   *  Fcn: '<S136>/Fcn'
   *  Fcn: '<S139>/Fcn'
   *  Gain: '<S136>/1\ib1'
   *  Math: '<S136>/Math Function'
   */
  rtb_DataTypeConversion1_g = ((2000.0 * rt_remd_snf(rtM->Timing.t[0], 0.0005) *
    2.0 - 1.0) + 1.0) * 0.5;

  /* End of Outputs for SubSystem: '<S68>/PWM Gen' */
  /* End of Outputs for SubSystem: '<S65>/Subsystem' */

  /* DataTypeConversion: '<S131>/Data Type Conversion' incorporates:
   *  Constant: '<S5>/Duty cycle2'
   *  Fcn: '<S131>/Fcn'
   *  RelationalOperator: '<S131>/Relational Operator'
   */
  rtDW.DataTypeConversion_ob = (0.8 >= rtb_DataTypeConversion1_g);

  /* DiscreteIntegrator: '<S132>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gy2 != 0) {
    rtDW.Integ4_hv = rtDW.Integ4_DSTATE_dd;
  } else {
    rtDW.Integ4_hv = 2.5E-6 * rtDW.DataTypeConversion_ob + rtDW.Integ4_DSTATE_dd;
  }

  /* End of DiscreteIntegrator: '<S132>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */

  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S132>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gy2 = 0U;
  rtDW.Integ4_DSTATE_dd = 2.5E-6 * rtDW.DataTypeConversion_ob + rtDW.Integ4_hv;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */
  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S67>/PWM Gen' */

  /* Saturate: '<S43>/Saturation' */
  if (rtDW.DataTypeConversion_ob > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_ob < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_ob;
  }

  /* End of Saturate: '<S43>/Saturation' */

  /* Product: '<S43>/Product4' */
  rtDW.Product4 = lastSin_o3_tmp * rtb_UnitDelay7;

  /* DataTypeConversion: '<S55>/Data Type Conversion1' incorporates:
   *  Constant: '<S56>/Constant'
   *  RelationalOperator: '<S56>/Compare'
   */
  rtb_UnitDelay7 = (rtb_Block4 <= 0.5);

  /* Outputs for Enabled SubSystem: '<S68>/PWM Gen' incorporates:
   *  EnablePort: '<S137>/Enable'
   */
  if (!rtDW.PWMGen_MODE) {
    /* Enable for DiscreteIntegrator: '<S140>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_lr = 1U;
    rtDW.PWMGen_MODE = true;
  }

  /* DataTypeConversion: '<S139>/Data Type Conversion' incorporates:
   *  Constant: '<S5>/Duty cycle1'
   *  RelationalOperator: '<S139>/Relational Operator'
   */
  rtDW.DataTypeConversion_j = (0.55 >= rtb_DataTypeConversion1_g);

  /* DiscreteIntegrator: '<S140>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_lr != 0) {
    rtDW.Integ4_jx = rtDW.Integ4_DSTATE_m0;
  } else {
    rtDW.Integ4_jx = 2.5E-6 * rtDW.DataTypeConversion_j + rtDW.Integ4_DSTATE_m0;
  }

  /* End of DiscreteIntegrator: '<S140>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S141>/S-Function' incorporates:
   *  Constant: '<S140>/K1'
   */

  /* Level2 S-Function Block: '<S141>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S140>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_lr = 0U;
  rtDW.Integ4_DSTATE_m0 = 2.5E-6 * rtDW.DataTypeConversion_j + rtDW.Integ4_jx;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S141>/S-Function' incorporates:
   *  Constant: '<S140>/K1'
   */
  /* Level2 S-Function Block: '<S141>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S68>/PWM Gen' */

  /* Saturate: '<S55>/Saturation' */
  if (rtDW.DataTypeConversion_j > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_j < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_j;
  }

  /* End of Saturate: '<S55>/Saturation' */

  /* Product: '<S55>/Product4' */
  rtDW.Product4_o = lastSin_o3_tmp * rtb_UnitDelay7;

  /* RateTransition: '<S72>/Rate Transition4' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition4 = rtDW.RateTransition4_Buffer0;
  }

  /* End of RateTransition: '<S72>/Rate Transition4' */

  /* Outputs for Enabled SubSystem: '<S329>/Subsystem1' */
  Subsystem1_i(0, &rtb_UnitDelay_ai[0], rtDW.RateTransition4, &rtDW.Fcn,
               &rtDW.Fcn1);

  /* End of Outputs for SubSystem: '<S329>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S329>/Subsystem - pi//2 delay' */
  Subsystempi2delay_l(rtConstB.Compare_o, &rtb_UnitDelay_ai[0],
                      rtDW.RateTransition4, &rtDW.Fcn_f, &rtDW.Fcn1_o);

  /* End of Outputs for SubSystem: '<S329>/Subsystem - pi//2 delay' */

  /* SignalConversion: '<S328>/TmpSignal ConversionAtGain3Inport1' incorporates:
   *  Switch: '<S329>/Switch'
   */
  rtb_UnitDelay3[0] = rtDW.Fcn_f;
  rtb_UnitDelay3[1] = rtDW.Fcn1_o;
  rtb_UnitDelay3[2] = rtb_UnitDelay_ai[2];

  /* Gain: '<S328>/Gain3' */
  for (rtb_Saturation_g_idx_0 = 0; rtb_Saturation_g_idx_0 < 3;
       rtb_Saturation_g_idx_0++) {
    rtb_UnitDelay_ai[rtb_Saturation_g_idx_0] =
      rtConstP.pooled88[rtb_Saturation_g_idx_0 + 6] * rtb_UnitDelay3[2] +
      (rtConstP.pooled88[rtb_Saturation_g_idx_0 + 3] * rtb_UnitDelay3[1] +
       rtConstP.pooled88[rtb_Saturation_g_idx_0] * rtb_UnitDelay3[0]);
  }

  /* End of Gain: '<S328>/Gain3' */

  /* Outputs for Enabled SubSystem: '<S64>/PWMgen - Averaging' incorporates:
   *  EnablePort: '<S75>/Enable'
   */
  if (!rtDW.PWMgenAveraging_MODE_e) {
    /* Enable for DiscreteIntegrator: '<S84>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_i3 = 1U;

    /* Enable for DiscreteIntegrator: '<S82>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_i05 = 1U;
    rtDW.PWMgenAveraging_MODE_e = true;
  }

  /* Lookup_n-D: '<S95>/1-D Lookup Table' incorporates:
   *  Constant: '<S95>/Constant1'
   *  Constant: '<S95>/Constant3'
   *  DigitalClock: '<S95>/Digital Clock'
   *  Gain: '<S95>/1\ib1'
   *  Math: '<S95>/Math Function'
   *  Sum: '<S95>/Add1'
   */
  rtb_RelationalOperator3_d = look1_pbinlx(rt_remd_snf(rtM->Timing.t[0] +
    0.00015432098765432098, 0.00061728395061728394) * 1620.0, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex_k, 2U);

  /* Sum: '<S86>/Add4' incorporates:
   *  Constant: '<S95>/Constant2'
   *  Sum: '<S95>/Add3'
   */
  rtb_RelationalOperator3_d = ((rtb_RelationalOperator3_d - 1.0) + -1.0) + 1.0;

  /* RelationalOperator: '<S90>/Relational Operator2' */
  rtb_LogicalOperator4_d = (rtb_UnitDelay_ai[0] >= rtb_RelationalOperator3_d);

  /* Logic: '<S80>/Logical Operator4' */
  rtb_RelationalOperator2_k_idx_0 = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S90>/Relational Operator2' */
  rtb_LogicalOperator4_g_idx_0 = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (rtb_UnitDelay_ai[1] >= rtb_RelationalOperator3_d);

  /* Logic: '<S80>/Logical Operator4' */
  rtb_RelationalOperator1_g = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S90>/Relational Operator2' */
  rtb_LogicalOperator4_g_idx_1 = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (rtb_UnitDelay_ai[2] >= rtb_RelationalOperator3_d);

  /* DataTypeConversion: '<S80>/Data Type Conversion' incorporates:
   *  Logic: '<S80>/Logical Operator4'
   */
  rtDW.DataTypeConversion_d[0] = rtb_LogicalOperator4_g_idx_0;
  rtDW.DataTypeConversion_d[1] = rtb_RelationalOperator2_k_idx_0;
  rtDW.DataTypeConversion_d[2] = rtb_LogicalOperator4_g_idx_1;
  rtDW.DataTypeConversion_d[3] = rtb_RelationalOperator1_g;
  rtDW.DataTypeConversion_d[4] = rtb_LogicalOperator4_d;
  rtDW.DataTypeConversion_d[5] = !rtb_LogicalOperator4_d;

  /* Lookup_n-D: '<S105>/1-D Lookup Table' incorporates:
   *  Constant: '<S105>/Constant1'
   *  Constant: '<S105>/Constant3'
   *  DigitalClock: '<S105>/Digital Clock'
   *  Gain: '<S105>/1\ib1'
   *  Math: '<S105>/Math Function'
   *  Sum: '<S105>/Add1'
   */
  rtb_RelationalOperator3_d = look1_pbinlx(rt_remd_snf(rtM->Timing.t[0] +
    0.00015432098765432098, 0.00061728395061728394) * 1620.0, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex_n, 2U);

  /* Sum: '<S96>/Add4' incorporates:
   *  Constant: '<S105>/Constant2'
   *  Sum: '<S105>/Add3'
   */
  rtb_RelationalOperator3_d = ((rtb_RelationalOperator3_d - 1.0) + -1.0) + 1.0;

  /* RelationalOperator: '<S100>/Relational Operator2' incorporates:
   *  Gain: '<S5>/Gain'
   */
  rtb_LogicalOperator4_d = (-rtb_UnitDelay_ai[0] >= rtb_RelationalOperator3_d);

  /* Logic: '<S81>/Logical Operator4' */
  rtb_RelationalOperator2_k_idx_0 = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S100>/Relational Operator2' incorporates:
   *  Gain: '<S5>/Gain'
   */
  rtb_LogicalOperator4_g_idx_0 = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (-rtb_UnitDelay_ai[1] >= rtb_RelationalOperator3_d);

  /* Logic: '<S81>/Logical Operator4' */
  rtb_LogicalOperator4_g_idx_1 = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S100>/Relational Operator2' incorporates:
   *  Gain: '<S5>/Gain'
   */
  rtb_RelationalOperator1_g = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (-rtb_UnitDelay_ai[2] >= rtb_RelationalOperator3_d);

  /* DataTypeConversion: '<S81>/Data Type Conversion' incorporates:
   *  Logic: '<S81>/Logical Operator4'
   */
  rtDW.DataTypeConversion_do[0] = rtb_LogicalOperator4_g_idx_0;
  rtDW.DataTypeConversion_do[1] = rtb_RelationalOperator2_k_idx_0;
  rtDW.DataTypeConversion_do[2] = rtb_RelationalOperator1_g;
  rtDW.DataTypeConversion_do[3] = rtb_LogicalOperator4_g_idx_1;
  rtDW.DataTypeConversion_do[4] = rtb_LogicalOperator4_d;
  rtDW.DataTypeConversion_do[5] = !rtb_LogicalOperator4_d;

  /* DiscreteIntegrator: '<S84>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i3 != 0) {
    rtDW.Integ4_iy[0] = rtDW.Integ4_DSTATE_ey[0];
    rtDW.Integ4_iy[1] = rtDW.Integ4_DSTATE_ey[1];
    rtDW.Integ4_iy[2] = rtDW.Integ4_DSTATE_ey[2];
  } else {
    rtDW.Integ4_iy[0] = 2.5E-6 * rtDW.DataTypeConversion_do[0] +
      rtDW.Integ4_DSTATE_ey[0];
    rtDW.Integ4_iy[1] = 2.5E-6 * rtDW.DataTypeConversion_do[2] +
      rtDW.Integ4_DSTATE_ey[1];
    rtDW.Integ4_iy[2] = 2.5E-6 * rtDW.DataTypeConversion_do[4] +
      rtDW.Integ4_DSTATE_ey[2];
  }

  /* End of DiscreteIntegrator: '<S84>/Integ4' */

  /* DiscreteIntegrator: '<S82>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i05 != 0) {
    rtDW.Integ4_im[0] = rtDW.Integ4_DSTATE_bk[0];
    rtDW.Integ4_im[1] = rtDW.Integ4_DSTATE_bk[1];
    rtDW.Integ4_im[2] = rtDW.Integ4_DSTATE_bk[2];
  } else {
    rtDW.Integ4_im[0] = 2.5E-6 * rtDW.DataTypeConversion_d[0] +
      rtDW.Integ4_DSTATE_bk[0];
    rtDW.Integ4_im[1] = 2.5E-6 * rtDW.DataTypeConversion_d[2] +
      rtDW.Integ4_DSTATE_bk[1];
    rtDW.Integ4_im[2] = 2.5E-6 * rtDW.DataTypeConversion_d[4] +
      rtDW.Integ4_DSTATE_bk[2];
  }

  /* End of DiscreteIntegrator: '<S82>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S83>/S-Function' incorporates:
   *  Constant: '<S82>/K1'
   */

  /* Level2 S-Function Block: '<S83>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnOutputs(rts,0);
  }

  /* S-Function (sfun_discreteVariableDelay): '<S85>/S-Function' incorporates:
   *  Constant: '<S84>/K1'
   */

  /* Level2 S-Function Block: '<S85>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S84>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i3 = 0U;
  rtDW.Integ4_DSTATE_ey[0] = 2.5E-6 * rtDW.DataTypeConversion_do[0] +
    rtDW.Integ4_iy[0];
  rtDW.Integ4_DSTATE_ey[1] = 2.5E-6 * rtDW.DataTypeConversion_do[2] +
    rtDW.Integ4_iy[1];
  rtDW.Integ4_DSTATE_ey[2] = 2.5E-6 * rtDW.DataTypeConversion_do[4] +
    rtDW.Integ4_iy[2];

  /* Update for DiscreteIntegrator: '<S82>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i05 = 0U;
  rtDW.Integ4_DSTATE_bk[0] = 2.5E-6 * rtDW.DataTypeConversion_d[0] +
    rtDW.Integ4_im[0];
  rtDW.Integ4_DSTATE_bk[1] = 2.5E-6 * rtDW.DataTypeConversion_d[2] +
    rtDW.Integ4_im[1];
  rtDW.Integ4_DSTATE_bk[2] = 2.5E-6 * rtDW.DataTypeConversion_d[4] +
    rtDW.Integ4_im[2];

  /* Update for S-Function (sfun_discreteVariableDelay): '<S83>/S-Function' incorporates:
   *  Constant: '<S82>/K1'
   */
  /* Level2 S-Function Block: '<S83>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for S-Function (sfun_discreteVariableDelay): '<S85>/S-Function' incorporates:
   *  Constant: '<S84>/K1'
   */
  /* Level2 S-Function Block: '<S85>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S64>/PWMgen - Averaging' */

  /* UnitDelay: '<S5>/Unit Delay3' */
  rtb_UnitDelay3[0] = rtDW.UnitDelay3_DSTATE[0];
  rtb_UnitDelay3[1] = rtDW.UnitDelay3_DSTATE[1];
  rtb_UnitDelay3[2] = rtDW.UnitDelay3_DSTATE[2];

  /* RateTransition: '<S72>/Rate Transition2' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition2_Buffer_g[0] = rtb_UnitDelay3[0];
    rtDW.RateTransition2_Buffer_g[1] = rtb_UnitDelay3[1];
    rtDW.RateTransition2_Buffer_g[2] = rtb_UnitDelay3[2];
  }

  /* End of RateTransition: '<S72>/Rate Transition2' */

  /* Sum: '<S318>/sum3' incorporates:
   *  Gain: '<S318>/A21'
   *  Gain: '<S318>/A22'
   *  UnitDelay: '<S317>/Delay_x1'
   *  UnitDelay: '<S317>/Delay_x2'
   */
  rtb_RelationalOperator3_d = -424.07342148553317 * rtDW.Delay_x1_DSTATE_py +
    0.90896529536924042 * rtDW.Delay_x2_DSTATE_c;

  /* Gain: '<S319>/B11' incorporates:
   *  UnitDelay: '<S72>/Unit Delay'
   */
  rtb_B11_h = 2.3862066192115771E-6 * rtDW.UnitDelay_DSTATE_ok;

  /* Gain: '<S319>/B21' incorporates:
   *  UnitDelay: '<S72>/Unit Delay'
   */
  rtb_B21_n = 0.95448264768462021 * rtDW.UnitDelay_DSTATE_ok;

  /* UnitDelay: '<S5>/Unit Delay7' */
  rtb_UnitDelay7 = rtDW.UnitDelay7_DSTATE;

  /* RateTransition: '<S63>/Rate Transition3' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition3_Buffer = rtb_UnitDelay7;
  }

  /* End of RateTransition: '<S63>/Rate Transition3' */

  /* Outputs for Enabled SubSystem: '<S65>/Subsystem' incorporates:
   *  EnablePort: '<S107>/Enable'
   */
  if (!rtDW.Subsystem_MODE_n) {
    /* Enable for DiscreteIntegrator: '<S110>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ae = 1U;
    rtDW.Subsystem_MODE_n = true;
  }

  /* DataTypeConversion: '<S109>/Data Type Conversion' incorporates:
   *  Constant: '<S112>/Constant'
   *  Logic: '<S109>/Logical Operator'
   *  RelationalOperator: '<S109>/Relational Operator'
   *  RelationalOperator: '<S112>/Compare'
   */
  rtDW.DataTypeConversion_l = ((rtDW.RateTransition2 != 0.0) &&
    (rtDW.RateTransition2 >= rtb_DataTypeConversion1_g));

  /* Logic: '<S107>/Logical Operator' */
  rtDW.LogicalOperator = !(rtDW.DataTypeConversion_l != 0.0);

  /* DiscreteIntegrator: '<S110>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ae != 0) {
    rtDW.Integ4_md = rtDW.Integ4_DSTATE_dt;
  } else {
    rtDW.Integ4_md = 2.5E-6 * rtDW.DataTypeConversion_l + rtDW.Integ4_DSTATE_dt;
  }

  /* End of DiscreteIntegrator: '<S110>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S111>/S-Function' incorporates:
   *  Constant: '<S110>/K1'
   */

  /* Level2 S-Function Block: '<S111>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S110>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ae = 0U;
  rtDW.Integ4_DSTATE_dt = 2.5E-6 * rtDW.DataTypeConversion_l + rtDW.Integ4_md;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S111>/S-Function' incorporates:
   *  Constant: '<S110>/K1'
   */
  /* Level2 S-Function Block: '<S111>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S65>/Subsystem' */

  /* Step: '<S5>/Block1' */
  rtb_UnitDelay7 = rtM->Timing.t[0];
  rtb_DataTypeConversion1_g = !(rtb_UnitDelay7 < 999.0);

  /* RateTransition: '<S71>/Rate Transition4' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition4_b = rtDW.RateTransition4_Buffer0_o;
  }

  /* End of RateTransition: '<S71>/Rate Transition4' */

  /* Outputs for Enabled SubSystem: '<S250>/Subsystem1' */
  Subsystem1_i(0, &rtb_UnitDelay1_d[0], rtDW.RateTransition4_b, &rtDW.Fcn_e,
               &rtDW.Fcn1_a);

  /* End of Outputs for SubSystem: '<S250>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S250>/Subsystem - pi//2 delay' */
  Subsystempi2delay_l(rtConstB.Compare_pi, &rtb_UnitDelay1_d[0],
                      rtDW.RateTransition4_b, &rtDW.Fcn_k, &rtDW.Fcn1_jb);

  /* End of Outputs for SubSystem: '<S250>/Subsystem - pi//2 delay' */

  /* SignalConversion: '<S249>/TmpSignal ConversionAtGain3Inport1' incorporates:
   *  Switch: '<S250>/Switch'
   */
  rtb_UnitDelay_ai[0] = rtDW.Fcn_k;
  rtb_UnitDelay_ai[1] = rtDW.Fcn1_jb;
  rtb_UnitDelay_ai[2] = rtb_UnitDelay1_d[2];

  /* Gain: '<S249>/Gain3' */
  for (rtb_Saturation_g_idx_0 = 0; rtb_Saturation_g_idx_0 < 3;
       rtb_Saturation_g_idx_0++) {
    rtb_UnitDelay3[rtb_Saturation_g_idx_0] =
      rtConstP.pooled88[rtb_Saturation_g_idx_0 + 6] * rtb_UnitDelay_ai[2] +
      (rtConstP.pooled88[rtb_Saturation_g_idx_0 + 3] * rtb_UnitDelay_ai[1] +
       rtConstP.pooled88[rtb_Saturation_g_idx_0] * rtb_UnitDelay_ai[0]);
  }

  /* End of Gain: '<S249>/Gain3' */

  /* Outputs for Enabled SubSystem: '<S66>/PWMgen - Averaging' incorporates:
   *  EnablePort: '<S115>/Enable'
   */
  if (!rtDW.PWMgenAveraging_MODE) {
    /* Enable for DiscreteIntegrator: '<S120>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_jm = 1U;

    /* Enable for DiscreteIntegrator: '<S122>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_h0 = 1U;
    rtDW.PWMgenAveraging_MODE = true;
  }

  /* Lookup_n-D: '<S128>/1-D Lookup Table' incorporates:
   *  Constant: '<S128>/Constant1'
   *  Constant: '<S128>/Constant3'
   *  DigitalClock: '<S128>/Digital Clock'
   *  Gain: '<S128>/1\ib1'
   *  Math: '<S128>/Math Function'
   *  Sum: '<S128>/Add1'
   */
  rtb_Add4 = look1_pbinlx(rt_remd_snf(rtM->Timing.t[0] + 0.00012626262626262626,
    0.000505050505050505) * 1980.0, rtConstP.pooled8, rtConstP.pooled7,
    &rtDW.m_bpIndex_b, 2U);

  /* Sum: '<S128>/Add3' incorporates:
   *  Constant: '<S128>/Constant2'
   */
  rtb_Add4--;

  /* Fcn: '<S119>/Fcn' */
  rtb_UnitDelay7 = (rtb_Add4 + 1.0) * 0.5;

  /* Fcn: '<S119>/Fcn1' */
  rtb_Fcn1 = (rtb_Add4 - 1.0) * 0.5;

  /* Outputs for Enabled SubSystem: '<S119>/Half bridge (1-ph) and 3-ph bridge' incorporates:
   *  EnablePort: '<S125>/Enable'
   */
  /* MultiPortSwitch: '<S119>/Multiport Switch2' incorporates:
   *  RelationalOperator: '<S125>/Relational Operator1'
   *  RelationalOperator: '<S125>/Relational Operator3'
   *  Sum: '<S125>/Sum3'
   */
  rtb_UnitDelay_ai[0] = (rtb_UnitDelay3[0] >= rtb_UnitDelay7) - (rtb_UnitDelay3
    [0] <= rtb_Fcn1);
  rtb_UnitDelay_ai[1] = (rtb_UnitDelay3[1] >= rtb_UnitDelay7) - (rtb_UnitDelay3
    [1] <= rtb_Fcn1);
  rtb_UnitDelay_ai[2] = (rtb_UnitDelay3[2] >= rtb_UnitDelay7) - (rtb_UnitDelay3
    [2] <= rtb_Fcn1);

  /* End of Outputs for SubSystem: '<S119>/Half bridge (1-ph) and 3-ph bridge' */

  /* Sum: '<S126>/Sum' incorporates:
   *  Constant: '<S126>/Constant2'
   */
  rtb_UnitDelay_ai[0] = (int32_T)rtb_UnitDelay_ai[0] + 2;
  rtb_UnitDelay_ai[1] = (int32_T)rtb_UnitDelay_ai[1] + 2;
  rtb_UnitDelay_ai[2] = (int32_T)rtb_UnitDelay_ai[2] + 2;

  /* MultiPortSwitch: '<S126>/Multiport Switch' */
  switch ((int32_T)rtb_UnitDelay_ai[0]) {
   case 1:
    rtb_Saturation_g_idx_0 = 0;
    rtb_Saturation_g_idx_1 = 0;
    rtb_Saturation_g_idx_2 = 1;
    rtb_Saturation_g_idx_3 = 1;
    break;

   case 2:
    rtb_Saturation_g_idx_0 = 0;
    rtb_Saturation_g_idx_1 = 1;
    rtb_Saturation_g_idx_2 = 1;
    rtb_Saturation_g_idx_3 = 0;
    break;

   default:
    rtb_Saturation_g_idx_0 = 1;
    rtb_Saturation_g_idx_1 = 1;
    rtb_Saturation_g_idx_2 = 0;
    rtb_Saturation_g_idx_3 = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S126>/Multiport Switch' */

  /* MultiPortSwitch: '<S126>/Multiport Switch3' */
  switch ((int32_T)rtb_UnitDelay_ai[1]) {
   case 1:
    rtb_MultiportSwitch3_idx_0 = 0;
    rtb_MultiportSwitch3_idx_1 = 0;
    rtb_MultiportSwitch3_idx_2 = 1;
    rtb_MultiportSwitch3_idx_3 = 1;
    break;

   case 2:
    rtb_MultiportSwitch3_idx_0 = 0;
    rtb_MultiportSwitch3_idx_1 = 1;
    rtb_MultiportSwitch3_idx_2 = 1;
    rtb_MultiportSwitch3_idx_3 = 0;
    break;

   default:
    rtb_MultiportSwitch3_idx_0 = 1;
    rtb_MultiportSwitch3_idx_1 = 1;
    rtb_MultiportSwitch3_idx_2 = 0;
    rtb_MultiportSwitch3_idx_3 = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S126>/Multiport Switch3' */

  /* MultiPortSwitch: '<S126>/Multiport Switch4' */
  switch ((int32_T)rtb_UnitDelay_ai[2]) {
   case 1:
    rtb_MultiportSwitch4_idx_0 = 0;
    rtb_MultiportSwitch4_idx_1 = 0;
    rtb_MultiportSwitch4_idx_2 = 1;
    rtb_MultiportSwitch4_idx_3 = 1;
    break;

   case 2:
    rtb_MultiportSwitch4_idx_0 = 0;
    rtb_MultiportSwitch4_idx_1 = 1;
    rtb_MultiportSwitch4_idx_2 = 1;
    rtb_MultiportSwitch4_idx_3 = 0;
    break;

   default:
    rtb_MultiportSwitch4_idx_0 = 1;
    rtb_MultiportSwitch4_idx_1 = 1;
    rtb_MultiportSwitch4_idx_2 = 0;
    rtb_MultiportSwitch4_idx_3 = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S126>/Multiport Switch4' */

  /* DataTypeConversion: '<S119>/Data Type Conversion' */
  rtDW.DataTypeConversion_or[0] = rtb_Saturation_g_idx_0;
  rtDW.DataTypeConversion_or[4] = rtb_MultiportSwitch3_idx_0;
  rtDW.DataTypeConversion_or[8] = rtb_MultiportSwitch4_idx_0;
  rtDW.DataTypeConversion_or[1] = rtb_Saturation_g_idx_1;
  rtDW.DataTypeConversion_or[5] = rtb_MultiportSwitch3_idx_1;
  rtDW.DataTypeConversion_or[9] = rtb_MultiportSwitch4_idx_1;
  rtDW.DataTypeConversion_or[2] = rtb_Saturation_g_idx_2;
  rtDW.DataTypeConversion_or[6] = rtb_MultiportSwitch3_idx_2;
  rtDW.DataTypeConversion_or[10] = rtb_MultiportSwitch4_idx_2;
  rtDW.DataTypeConversion_or[3] = rtb_Saturation_g_idx_3;
  rtDW.DataTypeConversion_or[7] = rtb_MultiportSwitch3_idx_3;
  rtDW.DataTypeConversion_or[11] = rtb_MultiportSwitch4_idx_3;

  /* DiscreteIntegrator: '<S120>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jm != 0) {
    rtDW.Integ4_lh[0] = rtDW.Integ4_DSTATE_lf[0];
    rtDW.Integ4_lh[1] = rtDW.Integ4_DSTATE_lf[1];
    rtDW.Integ4_lh[2] = rtDW.Integ4_DSTATE_lf[2];
  } else {
    rtDW.Integ4_lh[0] = 2.5E-6 * rtDW.DataTypeConversion_or[0] +
      rtDW.Integ4_DSTATE_lf[0];
    rtDW.Integ4_lh[1] = 2.5E-6 * rtDW.DataTypeConversion_or[4] +
      rtDW.Integ4_DSTATE_lf[1];
    rtDW.Integ4_lh[2] = 2.5E-6 * rtDW.DataTypeConversion_or[8] +
      rtDW.Integ4_DSTATE_lf[2];
  }

  /* End of DiscreteIntegrator: '<S120>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S121>/S-Function' incorporates:
   *  Constant: '<S120>/K1'
   */

  /* Level2 S-Function Block: '<S121>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S122>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_h0 != 0) {
    rtDW.Integ4_fe[0] = rtDW.Integ4_DSTATE_lk[0];
    rtDW.Integ4_fe[1] = rtDW.Integ4_DSTATE_lk[1];
    rtDW.Integ4_fe[2] = rtDW.Integ4_DSTATE_lk[2];
  } else {
    rtDW.Integ4_fe[0] = 2.5E-6 * rtDW.DataTypeConversion_or[3] +
      rtDW.Integ4_DSTATE_lk[0];
    rtDW.Integ4_fe[1] = 2.5E-6 * rtDW.DataTypeConversion_or[7] +
      rtDW.Integ4_DSTATE_lk[1];
    rtDW.Integ4_fe[2] = 2.5E-6 * rtDW.DataTypeConversion_or[11] +
      rtDW.Integ4_DSTATE_lk[2];
  }

  /* End of DiscreteIntegrator: '<S122>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */

  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S120>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jm = 0U;
  rtDW.Integ4_DSTATE_lf[0] = 2.5E-6 * rtDW.DataTypeConversion_or[0] +
    rtDW.Integ4_lh[0];
  rtDW.Integ4_DSTATE_lf[1] = 2.5E-6 * rtDW.DataTypeConversion_or[4] +
    rtDW.Integ4_lh[1];
  rtDW.Integ4_DSTATE_lf[2] = 2.5E-6 * rtDW.DataTypeConversion_or[8] +
    rtDW.Integ4_lh[2];

  /* Update for S-Function (sfun_discreteVariableDelay): '<S121>/S-Function' incorporates:
   *  Constant: '<S120>/K1'
   */
  /* Level2 S-Function Block: '<S121>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S122>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h0 = 0U;
  rtDW.Integ4_DSTATE_lk[0] = 2.5E-6 * rtDW.DataTypeConversion_or[3] +
    rtDW.Integ4_fe[0];
  rtDW.Integ4_DSTATE_lk[1] = 2.5E-6 * rtDW.DataTypeConversion_or[7] +
    rtDW.Integ4_fe[1];
  rtDW.Integ4_DSTATE_lk[2] = 2.5E-6 * rtDW.DataTypeConversion_or[11] +
    rtDW.Integ4_fe[2];

  /* Update for S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */
  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S66>/PWMgen - Averaging' */

  /* UnitDelay: '<S5>/Unit Delay' */
  rtb_UnitDelay_ai[0] = rtDW.UnitDelay_DSTATE_ds[0];
  rtb_UnitDelay_ai[1] = rtDW.UnitDelay_DSTATE_ds[1];
  rtb_UnitDelay_ai[2] = rtDW.UnitDelay_DSTATE_ds[2];

  /* RateTransition: '<S71>/Rate Transition2' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition2_Buffer_i[0] = rtb_UnitDelay_ai[0];
    rtDW.RateTransition2_Buffer_i[1] = rtb_UnitDelay_ai[1];
    rtDW.RateTransition2_Buffer_i[2] = rtb_UnitDelay_ai[2];
  }

  /* End of RateTransition: '<S71>/Rate Transition2' */

  /* Sum: '<S239>/sum3' incorporates:
   *  Gain: '<S239>/A21'
   *  Gain: '<S239>/A22'
   *  UnitDelay: '<S238>/Delay_x1'
   *  UnitDelay: '<S238>/Delay_x2'
   */
  rtb_UnitDelay7 = -424.07342148553317 * rtDW.Delay_x1_DSTATE_o +
    0.90896529536924042 * rtDW.Delay_x2_DSTATE_i;

  /* Gain: '<S240>/B11' incorporates:
   *  UnitDelay: '<S71>/Unit Delay'
   */
  rtb_Fcn1 = 2.3862066192115771E-6 * rtDW.UnitDelay_DSTATE_dm;

  /* Gain: '<S240>/B21' incorporates:
   *  UnitDelay: '<S71>/Unit Delay'
   */
  rtb_B21_h = 0.95448264768462021 * rtDW.UnitDelay_DSTATE_dm;

  /* Sin: '<S5>/Uref1' */
  if (rtDW.systemEnable_h != 0) {
    rtDW.lastSin_b = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_he = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_h = 0;
  }

  /* Outputs for Enabled SubSystem: '<S70>/Subsystem' incorporates:
   *  EnablePort: '<S165>/Enable'
   */
  if (!rtDW.Subsystem_MODE) {
    /* Enable for DiscreteIntegrator: '<S168>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ji = 1U;
    rtDW.Subsystem_MODE = true;
  }

  /* Lookup_n-D: '<S179>/1-D Lookup Table' incorporates:
   *  Constant: '<S179>/Constant1'
   *  Constant: '<S179>/Constant3'
   *  DigitalClock: '<S179>/Digital Clock'
   *  Gain: '<S179>/1\ib1'
   *  Math: '<S179>/Math Function'
   *  Sum: '<S179>/Add1'
   */
  rtb_Add4 = look1_pbinlx(rt_remd_snf(rtM->Timing.t[0] + 0.00012626262626262626,
    0.000505050505050505) * 1980.0, rtConstP.pooled8, rtConstP.pooled7,
    &rtDW.m_bpIndex, 2U);

  /* RelationalOperator: '<S174>/Relational Operator2' incorporates:
   *  Constant: '<S179>/Constant2'
   *  Sin: '<S5>/Uref1'
   *  Sum: '<S170>/Add4'
   *  Sum: '<S179>/Add3'
   */
  rtb_RelationalOperator1_g = ((rtDW.lastSin_b * 0.96641197241205634 +
    rtDW.lastCos_he * 0.2569978590934931) * 0.99999822347173384 +
    (rtDW.lastCos_he * 0.96641197241205634 - rtDW.lastSin_b * 0.2569978590934931)
    * 0.0018849544759281136 >= ((rtb_Add4 - 1.0) + -1.0) + 1.0);

  /* DataTypeConversion: '<S167>/Data Type Conversion' incorporates:
   *  Logic: '<S167>/Logical Operator4'
   */
  rtDW.DataTypeConversion[0] = rtb_RelationalOperator1_g;
  rtDW.DataTypeConversion[1] = !rtb_RelationalOperator1_g;

  /* DiscreteIntegrator: '<S168>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ji != 0) {
    rtDW.Integ4_l1 = rtDW.Integ4_DSTATE_go;
  } else {
    rtDW.Integ4_l1 = 2.5E-6 * rtDW.DataTypeConversion[0] + rtDW.Integ4_DSTATE_go;
  }

  /* End of DiscreteIntegrator: '<S168>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S169>/S-Function' incorporates:
   *  Constant: '<S168>/K1'
   */

  /* Level2 S-Function Block: '<S169>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S168>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ji = 0U;
  rtDW.Integ4_DSTATE_go = 2.5E-6 * rtDW.DataTypeConversion[0] + rtDW.Integ4_l1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S169>/S-Function' incorporates:
   *  Constant: '<S168>/K1'
   */
  /* Level2 S-Function Block: '<S169>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S70>/Subsystem' */

  /* Sin: '<S5>/Uref2' */
  if (rtDW.systemEnable_ia != 0) {
    lastSin_o3_tmp = 314.15926535897933 * rtM->Timing.t[0];
    rtDW.lastSin_o3 = sin(lastSin_o3_tmp);
    rtDW.lastCos_nyp = cos(lastSin_o3_tmp);
    rtDW.systemEnable_ia = 0;
  }

  rtb_Uref2 = ((rtDW.lastSin_o3 * 0.99999876629970352 + rtDW.lastCos_nyp *
                -0.0015707956808308789) * 0.99999876629970352 +
               (rtDW.lastCos_nyp * 0.99999876629970352 - rtDW.lastSin_o3 *
                -0.0015707956808308789) * 0.0015707956808308789) * 0.9;

  /* End of Sin: '<S5>/Uref2' */

  /* Outputs for Enabled SubSystem: '<S69>/PWM gen' incorporates:
   *  EnablePort: '<S145>/Enable'
   */
  if (!rtDW.PWMgen_MODE) {
    /* Enable for DiscreteIntegrator: '<S150>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_b4 = 1U;

    /* Enable for DiscreteIntegrator: '<S152>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ke4 = 1U;
    rtDW.PWMgen_MODE = true;
  }

  /* Lookup_n-D: '<S163>/1-D Lookup Table' incorporates:
   *  Constant: '<S163>/Constant1'
   *  Constant: '<S163>/Constant3'
   *  DigitalClock: '<S163>/Digital Clock'
   *  Gain: '<S163>/1\ib1'
   *  Math: '<S163>/Math Function'
   *  Sum: '<S163>/Add1'
   */
  rtb_Add4 = look1_pbinlx(rt_remd_snf(rtM->Timing.t[0] + 0.00015151515151515152,
    0.00060606060606060606) * 1650.0, rtConstP.pooled8, rtConstP.pooled7,
    &rtDW.m_bpIndex_c, 2U);

  /* Sum: '<S154>/Add4' incorporates:
   *  Constant: '<S163>/Constant2'
   *  Sum: '<S163>/Add3'
   */
  rtb_Add4 = ((rtb_Add4 - 1.0) + -1.0) + 1.0;

  /* RelationalOperator: '<S158>/Relational Operator1' */
  rtb_RelationalOperator1_g = (rtb_Uref2 >= rtb_Add4);

  /* RelationalOperator: '<S158>/Relational Operator3' incorporates:
   *  Gain: '<S158>/Gain'
   */
  rtb_LogicalOperator4_g_idx_1 = (-rtb_Uref2 >= rtb_Add4);

  /* DataTypeConversion: '<S149>/Data Type Conversion' incorporates:
   *  Logic: '<S149>/Logical Operator4'
   */
  rtDW.DataTypeConversion_o[0] = rtb_RelationalOperator1_g;
  rtDW.DataTypeConversion_o[1] = !rtb_RelationalOperator1_g;
  rtDW.DataTypeConversion_o[2] = rtb_LogicalOperator4_g_idx_1;
  rtDW.DataTypeConversion_o[3] = !rtb_LogicalOperator4_g_idx_1;

  /* DiscreteIntegrator: '<S150>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_b4 != 0) {
    rtDW.Integ4_m0 = rtDW.Integ4_DSTATE_f0;
  } else {
    rtDW.Integ4_m0 = 2.5E-6 * rtDW.DataTypeConversion_o[0] +
      rtDW.Integ4_DSTATE_f0;
  }

  /* End of DiscreteIntegrator: '<S150>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S151>/S-Function' incorporates:
   *  Constant: '<S150>/K1'
   */

  /* Level2 S-Function Block: '<S151>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S152>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ke4 != 0) {
    rtDW.Integ4_jq = rtDW.Integ4_DSTATE_b0;
  } else {
    rtDW.Integ4_jq = 2.5E-6 * rtDW.DataTypeConversion_o[2] +
      rtDW.Integ4_DSTATE_b0;
  }

  /* End of DiscreteIntegrator: '<S152>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */

  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S150>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_b4 = 0U;
  rtDW.Integ4_DSTATE_f0 = 2.5E-6 * rtDW.DataTypeConversion_o[0] + rtDW.Integ4_m0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S151>/S-Function' incorporates:
   *  Constant: '<S150>/K1'
   */
  /* Level2 S-Function Block: '<S151>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S152>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ke4 = 0U;
  rtDW.Integ4_DSTATE_b0 = 2.5E-6 * rtDW.DataTypeConversion_o[2] + rtDW.Integ4_jq;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */
  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S69>/PWM gen' */

  /* Gain: '<S334>/Field-armature mutual inductance' */
  rtb_Add4 = 2.621 * rtDW.StateSpace;

  /* RelationalOperator: '<S659>/Compare' incorporates:
   *  Constant: '<S659>/Constant'
   */
  rtb_LogicalOperator4_g_idx_1 = (rtb_DataTypeConversion1_g <= 0.5);

  /* Saturate: '<S656>/Saturation' */
  if (rtDW.DataTypeConversion_or[0] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[0] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[0];
  }

  /* Product: '<S656>/Product4' incorporates:
   *  DataTypeConversion: '<S656>/Data Type Conversion1'
   */
  rtDW.Product4_c[0] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S656>/Saturation' */
  if (rtDW.DataTypeConversion_or[1] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[1] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[1];
  }

  /* Product: '<S656>/Product4' incorporates:
   *  DataTypeConversion: '<S656>/Data Type Conversion1'
   */
  rtDW.Product4_c[1] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S656>/Saturation' */
  if (rtDW.DataTypeConversion_or[2] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[2] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[2];
  }

  /* Product: '<S656>/Product4' incorporates:
   *  DataTypeConversion: '<S656>/Data Type Conversion1'
   */
  rtDW.Product4_c[2] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S656>/Saturation' */
  if (rtDW.DataTypeConversion_or[3] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[3] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[3];
  }

  /* Product: '<S656>/Product4' incorporates:
   *  DataTypeConversion: '<S656>/Data Type Conversion1'
   */
  rtDW.Product4_c[3] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* RelationalOperator: '<S678>/Compare' incorporates:
   *  Constant: '<S678>/Constant'
   */
  rtb_LogicalOperator4_g_idx_1 = (rtb_DataTypeConversion1_g <= 0.5);

  /* Saturate: '<S657>/Saturation' */
  if (rtDW.DataTypeConversion_or[4] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[4] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[4];
  }

  /* Product: '<S657>/Product4' incorporates:
   *  DataTypeConversion: '<S657>/Data Type Conversion1'
   */
  rtDW.Product4_d[0] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S657>/Saturation' */
  if (rtDW.DataTypeConversion_or[5] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[5] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[5];
  }

  /* Product: '<S657>/Product4' incorporates:
   *  DataTypeConversion: '<S657>/Data Type Conversion1'
   */
  rtDW.Product4_d[1] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S657>/Saturation' */
  if (rtDW.DataTypeConversion_or[6] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[6] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[6];
  }

  /* Product: '<S657>/Product4' incorporates:
   *  DataTypeConversion: '<S657>/Data Type Conversion1'
   */
  rtDW.Product4_d[2] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S657>/Saturation' */
  if (rtDW.DataTypeConversion_or[7] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[7] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[7];
  }

  /* Product: '<S657>/Product4' incorporates:
   *  DataTypeConversion: '<S657>/Data Type Conversion1'
   */
  rtDW.Product4_d[3] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* RelationalOperator: '<S697>/Compare' incorporates:
   *  Constant: '<S697>/Constant'
   */
  rtb_LogicalOperator4_g_idx_1 = (rtb_DataTypeConversion1_g <= 0.5);

  /* Saturate: '<S658>/Saturation' */
  if (rtDW.DataTypeConversion_or[8] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[8] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[8];
  }

  /* Product: '<S658>/Product4' incorporates:
   *  DataTypeConversion: '<S658>/Data Type Conversion1'
   */
  rtDW.Product4_p[0] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S658>/Saturation' */
  if (rtDW.DataTypeConversion_or[9] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[9] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[9];
  }

  /* Product: '<S658>/Product4' incorporates:
   *  DataTypeConversion: '<S658>/Data Type Conversion1'
   */
  rtDW.Product4_p[1] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S658>/Saturation' */
  if (rtDW.DataTypeConversion_or[10] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[10] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[10];
  }

  /* Product: '<S658>/Product4' incorporates:
   *  DataTypeConversion: '<S658>/Data Type Conversion1'
   */
  rtDW.Product4_p[2] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S658>/Saturation' */
  if (rtDW.DataTypeConversion_or[11] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_or[11] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_or[11];
  }

  /* Product: '<S658>/Product4' incorporates:
   *  DataTypeConversion: '<S658>/Data Type Conversion1'
   */
  rtDW.Product4_p[3] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S771>/Saturation' */
  if (rtDW.DataTypeConversion_l > 1.0) {
    /* Product: '<S771>/Product4' */
    rtDW.Product4_i[0] = 1.0;
  } else if (rtDW.DataTypeConversion_l < 0.0) {
    /* Product: '<S771>/Product4' */
    rtDW.Product4_i[0] = 0.0;
  } else {
    /* Product: '<S771>/Product4' */
    rtDW.Product4_i[0] = rtDW.DataTypeConversion_l;
  }

  if (rtDW.LogicalOperator > 1.0) {
    /* Product: '<S771>/Product4' */
    rtDW.Product4_i[1] = 1.0;
  } else if (rtDW.LogicalOperator < 0.0) {
    /* Product: '<S771>/Product4' */
    rtDW.Product4_i[1] = 0.0;
  } else {
    /* Product: '<S771>/Product4' */
    rtDW.Product4_i[1] = rtDW.LogicalOperator;
  }

  /* End of Saturate: '<S771>/Saturation' */

  /* RelationalOperator: '<S355>/Compare' incorporates:
   *  Constant: '<S355>/Constant'
   */
  rtb_LogicalOperator4_g_idx_1 = (rtb_Block4 <= 0.5);

  /* Saturate: '<S354>/Saturation' */
  if (rtDW.DataTypeConversion_o[0] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_o[0] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_o[0];
  }

  /* Product: '<S354>/Product4' incorporates:
   *  DataTypeConversion: '<S354>/Data Type Conversion1'
   */
  rtDW.Product4_k[0] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S354>/Saturation' */
  if (rtDW.DataTypeConversion_o[1] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_o[1] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_o[1];
  }

  /* Product: '<S354>/Product4' incorporates:
   *  DataTypeConversion: '<S354>/Data Type Conversion1'
   */
  rtDW.Product4_k[1] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S354>/Saturation' */
  if (rtDW.DataTypeConversion_o[2] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_o[2] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_o[2];
  }

  /* Product: '<S354>/Product4' incorporates:
   *  DataTypeConversion: '<S354>/Data Type Conversion1'
   */
  rtDW.Product4_k[2] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S354>/Saturation' */
  if (rtDW.DataTypeConversion_o[3] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion_o[3] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion_o[3];
  }

  /* Product: '<S354>/Product4' incorporates:
   *  DataTypeConversion: '<S354>/Data Type Conversion1'
   */
  rtDW.Product4_k[3] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* RelationalOperator: '<S373>/Compare' incorporates:
   *  Constant: '<S373>/Constant'
   */
  rtb_LogicalOperator4_g_idx_1 = (rtb_Block4 <= 0.5);

  /* Saturate: '<S372>/Saturation' */
  if (rtDW.DataTypeConversion[0] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion[0] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion[0];
  }

  /* Product: '<S372>/Product4' incorporates:
   *  DataTypeConversion: '<S372>/Data Type Conversion1'
   */
  rtDW.Product4_e[0] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S372>/Saturation' */
  if (rtDW.DataTypeConversion[1] > 1.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DataTypeConversion[1] < 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = rtDW.DataTypeConversion[1];
  }

  /* Product: '<S372>/Product4' incorporates:
   *  DataTypeConversion: '<S372>/Data Type Conversion1'
   */
  rtDW.Product4_e[1] = lastSin_o3_tmp * (real_T)rtb_LogicalOperator4_g_idx_1;

  /* Saturate: '<S723>/Saturation' */
  if (rtDW.DataTypeConversion_d[0] > 1.0) {
    /* Product: '<S723>/Product4' */
    rtDW.Product4_h[0] = 1.0;
  } else if (rtDW.DataTypeConversion_d[0] < 0.0) {
    /* Product: '<S723>/Product4' */
    rtDW.Product4_h[0] = 0.0;
  } else {
    /* Product: '<S723>/Product4' */
    rtDW.Product4_h[0] = rtDW.DataTypeConversion_d[0];
  }

  if (rtDW.DataTypeConversion_d[1] > 1.0) {
    /* Product: '<S723>/Product4' */
    rtDW.Product4_h[1] = 1.0;
  } else if (rtDW.DataTypeConversion_d[1] < 0.0) {
    /* Product: '<S723>/Product4' */
    rtDW.Product4_h[1] = 0.0;
  } else {
    /* Product: '<S723>/Product4' */
    rtDW.Product4_h[1] = rtDW.DataTypeConversion_d[1];
  }

  /* End of Saturate: '<S723>/Saturation' */

  /* Saturate: '<S724>/Saturation' */
  if (rtDW.DataTypeConversion_d[2] > 1.0) {
    /* Product: '<S724>/Product4' */
    rtDW.Product4_it[0] = 1.0;
  } else if (rtDW.DataTypeConversion_d[2] < 0.0) {
    /* Product: '<S724>/Product4' */
    rtDW.Product4_it[0] = 0.0;
  } else {
    /* Product: '<S724>/Product4' */
    rtDW.Product4_it[0] = rtDW.DataTypeConversion_d[2];
  }

  if (rtDW.DataTypeConversion_d[3] > 1.0) {
    /* Product: '<S724>/Product4' */
    rtDW.Product4_it[1] = 1.0;
  } else if (rtDW.DataTypeConversion_d[3] < 0.0) {
    /* Product: '<S724>/Product4' */
    rtDW.Product4_it[1] = 0.0;
  } else {
    /* Product: '<S724>/Product4' */
    rtDW.Product4_it[1] = rtDW.DataTypeConversion_d[3];
  }

  /* End of Saturate: '<S724>/Saturation' */

  /* Saturate: '<S725>/Saturation' */
  if (rtDW.DataTypeConversion_d[4] > 1.0) {
    /* Product: '<S725>/Product4' */
    rtDW.Product4_ij[0] = 1.0;
  } else if (rtDW.DataTypeConversion_d[4] < 0.0) {
    /* Product: '<S725>/Product4' */
    rtDW.Product4_ij[0] = 0.0;
  } else {
    /* Product: '<S725>/Product4' */
    rtDW.Product4_ij[0] = rtDW.DataTypeConversion_d[4];
  }

  if (rtDW.DataTypeConversion_d[5] > 1.0) {
    /* Product: '<S725>/Product4' */
    rtDW.Product4_ij[1] = 1.0;
  } else if (rtDW.DataTypeConversion_d[5] < 0.0) {
    /* Product: '<S725>/Product4' */
    rtDW.Product4_ij[1] = 0.0;
  } else {
    /* Product: '<S725>/Product4' */
    rtDW.Product4_ij[1] = rtDW.DataTypeConversion_d[5];
  }

  /* End of Saturate: '<S725>/Saturation' */

  /* Saturate: '<S747>/Saturation' */
  if (rtDW.DataTypeConversion_do[0] > 1.0) {
    /* Product: '<S747>/Product4' */
    rtDW.Product4_a[0] = 1.0;
  } else if (rtDW.DataTypeConversion_do[0] < 0.0) {
    /* Product: '<S747>/Product4' */
    rtDW.Product4_a[0] = 0.0;
  } else {
    /* Product: '<S747>/Product4' */
    rtDW.Product4_a[0] = rtDW.DataTypeConversion_do[0];
  }

  if (rtDW.DataTypeConversion_do[1] > 1.0) {
    /* Product: '<S747>/Product4' */
    rtDW.Product4_a[1] = 1.0;
  } else if (rtDW.DataTypeConversion_do[1] < 0.0) {
    /* Product: '<S747>/Product4' */
    rtDW.Product4_a[1] = 0.0;
  } else {
    /* Product: '<S747>/Product4' */
    rtDW.Product4_a[1] = rtDW.DataTypeConversion_do[1];
  }

  /* End of Saturate: '<S747>/Saturation' */

  /* Saturate: '<S748>/Saturation' */
  if (rtDW.DataTypeConversion_do[2] > 1.0) {
    /* Product: '<S748>/Product4' */
    rtDW.Product4_az[0] = 1.0;
  } else if (rtDW.DataTypeConversion_do[2] < 0.0) {
    /* Product: '<S748>/Product4' */
    rtDW.Product4_az[0] = 0.0;
  } else {
    /* Product: '<S748>/Product4' */
    rtDW.Product4_az[0] = rtDW.DataTypeConversion_do[2];
  }

  if (rtDW.DataTypeConversion_do[3] > 1.0) {
    /* Product: '<S748>/Product4' */
    rtDW.Product4_az[1] = 1.0;
  } else if (rtDW.DataTypeConversion_do[3] < 0.0) {
    /* Product: '<S748>/Product4' */
    rtDW.Product4_az[1] = 0.0;
  } else {
    /* Product: '<S748>/Product4' */
    rtDW.Product4_az[1] = rtDW.DataTypeConversion_do[3];
  }

  /* End of Saturate: '<S748>/Saturation' */

  /* Saturate: '<S749>/Saturation' */
  if (rtDW.DataTypeConversion_do[4] > 1.0) {
    /* Product: '<S749>/Product4' */
    rtDW.Product4_j[0] = 1.0;
  } else if (rtDW.DataTypeConversion_do[4] < 0.0) {
    /* Product: '<S749>/Product4' */
    rtDW.Product4_j[0] = 0.0;
  } else {
    /* Product: '<S749>/Product4' */
    rtDW.Product4_j[0] = rtDW.DataTypeConversion_do[4];
  }

  if (rtDW.DataTypeConversion_do[5] > 1.0) {
    /* Product: '<S749>/Product4' */
    rtDW.Product4_j[1] = 1.0;
  } else if (rtDW.DataTypeConversion_do[5] < 0.0) {
    /* Product: '<S749>/Product4' */
    rtDW.Product4_j[1] = 0.0;
  } else {
    /* Product: '<S749>/Product4' */
    rtDW.Product4_j[1] = rtDW.DataTypeConversion_do[5];
  }

  /* End of Saturate: '<S749>/Saturation' */

  /* DiscreteIntegrator: '<S516>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_o3 != 0) {
    rtDW.Integ4_c1 = rtDW.Integ4_DSTATE_oe;
  } else {
    rtDW.Integ4_c1 = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_DSTATE_oe;
  }

  /* End of DiscreteIntegrator: '<S516>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */

  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S584>/cos(wt)' */
  if (rtDW.systemEnable_bz != 0) {
    rtDW.lastSin_g = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ko = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bz = 0;
  }

  /* Product: '<S584>/Product1' incorporates:
   *  Sin: '<S584>/cos(wt)'
   */
  rtb_DataTypeConversion1_g = ((rtDW.lastSin_g * 0.0018849544759281464 +
    rtDW.lastCos_ko * 0.99999822347173384) * 0.99999822347173384 +
    (rtDW.lastCos_ko * 0.0018849544759281464 - rtDW.lastSin_g *
     0.99999822347173384) * 0.0018849544759281136) * 2.0 * rtDW.StateSpace_o1[42];

  /* DiscreteIntegrator: '<S592>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_og != 0) {
    rtDW.Integ4_is = rtDW.Integ4_DSTATE_n5;
  } else {
    rtDW.Integ4_is = 2.5E-6 * rtb_DataTypeConversion1_g + rtDW.Integ4_DSTATE_n5;
  }

  /* End of DiscreteIntegrator: '<S592>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S593>/S-Function' incorporates:
   *  Constant: '<S592>/K1'
   */

  /* Level2 S-Function Block: '<S593>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S584>/sin(wt)' */
  if (rtDW.systemEnable_e5 != 0) {
    rtDW.lastSin_ne = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_n3 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e5 = 0;
  }

  /* Product: '<S584>/Product' incorporates:
   *  Sin: '<S584>/sin(wt)'
   */
  rtb_Uref2 = ((rtDW.lastSin_ne * 0.99999822347173384 + rtDW.lastCos_n3 *
                -0.0018849544759281136) * 0.99999822347173384 + (rtDW.lastCos_n3
    * 0.99999822347173384 - rtDW.lastSin_ne * -0.0018849544759281136) *
               0.0018849544759281136) * 2.0 * rtDW.StateSpace_o1[42];

  /* DiscreteIntegrator: '<S594>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gy != 0) {
    rtDW.Integ4_np = rtDW.Integ4_DSTATE_c;
  } else {
    rtDW.Integ4_np = 2.5E-6 * rtb_Uref2 + rtDW.Integ4_DSTATE_c;
  }

  /* End of DiscreteIntegrator: '<S594>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S595>/S-Function' incorporates:
   *  Constant: '<S594>/K1'
   */

  /* Level2 S-Function Block: '<S595>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S585>/cos(wt)' */
  if (rtDW.systemEnable_bj != 0) {
    rtDW.lastSin_am5 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gn = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bj = 0;
  }

  /* Product: '<S585>/Product1' incorporates:
   *  Sin: '<S585>/cos(wt)'
   */
  rtb_Block4 = ((rtDW.lastSin_am5 * 0.0018849544759281464 + rtDW.lastCos_gn *
                 0.99999822347173384) * 0.99999822347173384 + (rtDW.lastCos_gn *
    0.0018849544759281464 - rtDW.lastSin_am5 * 0.99999822347173384) *
                0.0018849544759281136) * 2.0 * rtDW.StateSpace_o1[43];

  /* DiscreteIntegrator: '<S598>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_nt != 0) {
    rtDW.Integ4_nw = rtDW.Integ4_DSTATE_cd;
  } else {
    rtDW.Integ4_nw = 2.5E-6 * rtb_Block4 + rtDW.Integ4_DSTATE_cd;
  }

  /* End of DiscreteIntegrator: '<S598>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */

  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S585>/sin(wt)' */
  if (rtDW.systemEnable_di != 0) {
    rtDW.lastSin_on = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gs = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_di = 0;
  }

  /* Product: '<S585>/Product' incorporates:
   *  Sin: '<S585>/sin(wt)'
   */
  rtb_Product_od = ((rtDW.lastSin_on * 0.99999822347173384 + rtDW.lastCos_gs *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_gs * 0.99999822347173384 - rtDW.lastSin_on *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[43];

  /* DiscreteIntegrator: '<S600>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ax != 0) {
    rtDW.Integ4_pz = rtDW.Integ4_DSTATE_lz;
  } else {
    rtDW.Integ4_pz = 2.5E-6 * rtb_Product_od + rtDW.Integ4_DSTATE_lz;
  }

  /* End of DiscreteIntegrator: '<S600>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S601>/S-Function' incorporates:
   *  Constant: '<S600>/K1'
   */

  /* Level2 S-Function Block: '<S601>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S586>/cos(wt)' */
  if (rtDW.systemEnable_k != 0) {
    rtDW.lastSin_h5 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_pj = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_k = 0;
  }

  /* Product: '<S586>/Product1' incorporates:
   *  Sin: '<S586>/cos(wt)'
   */
  rtb_Product1_c = ((rtDW.lastSin_h5 * 0.0018849544759281464 + rtDW.lastCos_pj *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_pj * 0.0018849544759281464 - rtDW.lastSin_h5 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[44];

  /* DiscreteIntegrator: '<S604>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ob != 0) {
    rtDW.Integ4_i0 = rtDW.Integ4_DSTATE_ne;
  } else {
    rtDW.Integ4_i0 = 2.5E-6 * rtb_Product1_c + rtDW.Integ4_DSTATE_ne;
  }

  /* End of DiscreteIntegrator: '<S604>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */

  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S586>/sin(wt)' */
  if (rtDW.systemEnable_go != 0) {
    rtDW.lastSin_n1 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ihc = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_go = 0;
  }

  /* Product: '<S586>/Product' incorporates:
   *  Sin: '<S586>/sin(wt)'
   */
  rtb_Product_mv = ((rtDW.lastSin_n1 * 0.99999822347173384 + rtDW.lastCos_ihc *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ihc * 0.99999822347173384 - rtDW.lastSin_n1 *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[44];

  /* DiscreteIntegrator: '<S606>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_pc != 0) {
    rtDW.Integ4_j1 = rtDW.Integ4_DSTATE_df;
  } else {
    rtDW.Integ4_j1 = 2.5E-6 * rtb_Product_mv + rtDW.Integ4_DSTATE_df;
  }

  /* End of DiscreteIntegrator: '<S606>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S607>/S-Function' incorporates:
   *  Constant: '<S606>/K1'
   */

  /* Level2 S-Function Block: '<S607>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S608>/cos(wt)' */
  if (rtDW.systemEnable_fq != 0) {
    rtDW.lastSin_ds = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_k2 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fq = 0;
  }

  /* Product: '<S608>/Product1' incorporates:
   *  Sin: '<S608>/cos(wt)'
   */
  rtb_Product1_it = ((rtDW.lastSin_ds * 0.0018849544759281464 + rtDW.lastCos_k2 *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_k2 * 0.0018849544759281464 - rtDW.lastSin_ds *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[59];

  /* DiscreteIntegrator: '<S616>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ka != 0) {
    rtDW.Integ4_di = rtDW.Integ4_DSTATE_am;
  } else {
    rtDW.Integ4_di = 2.5E-6 * rtb_Product1_it + rtDW.Integ4_DSTATE_am;
  }

  /* End of DiscreteIntegrator: '<S616>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S617>/S-Function' incorporates:
   *  Constant: '<S616>/K1'
   */

  /* Level2 S-Function Block: '<S617>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S608>/sin(wt)' */
  if (rtDW.systemEnable_kf != 0) {
    rtDW.lastSin_ft = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_le = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_kf = 0;
  }

  /* Product: '<S608>/Product' incorporates:
   *  Sin: '<S608>/sin(wt)'
   */
  rtb_Product_db = ((rtDW.lastSin_ft * 0.99999822347173384 + rtDW.lastCos_le *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_le * 0.99999822347173384 - rtDW.lastSin_ft *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[59];

  /* DiscreteIntegrator: '<S618>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ft != 0) {
    rtDW.Integ4_dd = rtDW.Integ4_DSTATE_ct;
  } else {
    rtDW.Integ4_dd = 2.5E-6 * rtb_Product_db + rtDW.Integ4_DSTATE_ct;
  }

  /* End of DiscreteIntegrator: '<S618>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S619>/S-Function' incorporates:
   *  Constant: '<S618>/K1'
   */

  /* Level2 S-Function Block: '<S619>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S609>/cos(wt)' */
  if (rtDW.systemEnable_ip != 0) {
    rtDW.lastSin_ik = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gx = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ip = 0;
  }

  /* Product: '<S609>/Product1' incorporates:
   *  Sin: '<S609>/cos(wt)'
   */
  rtb_Product1_pv = ((rtDW.lastSin_ik * 0.0018849544759281464 + rtDW.lastCos_gx *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_gx * 0.0018849544759281464 - rtDW.lastSin_ik *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[60];

  /* DiscreteIntegrator: '<S622>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_js != 0) {
    rtDW.Integ4_a3 = rtDW.Integ4_DSTATE_dn;
  } else {
    rtDW.Integ4_a3 = 2.5E-6 * rtb_Product1_pv + rtDW.Integ4_DSTATE_dn;
  }

  /* End of DiscreteIntegrator: '<S622>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */

  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S609>/sin(wt)' */
  if (rtDW.systemEnable_g1 != 0) {
    rtDW.lastSin_gg = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_kz = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_g1 = 0;
  }

  /* Product: '<S609>/Product' incorporates:
   *  Sin: '<S609>/sin(wt)'
   */
  rtb_Product_cki = ((rtDW.lastSin_gg * 0.99999822347173384 + rtDW.lastCos_kz *
                      -0.0018849544759281136) * 0.99999822347173384 +
                     (rtDW.lastCos_kz * 0.99999822347173384 - rtDW.lastSin_gg *
                      -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[60];

  /* DiscreteIntegrator: '<S624>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jw != 0) {
    rtDW.Integ4_lc = rtDW.Integ4_DSTATE_f;
  } else {
    rtDW.Integ4_lc = 2.5E-6 * rtb_Product_cki + rtDW.Integ4_DSTATE_f;
  }

  /* End of DiscreteIntegrator: '<S624>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */

  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S610>/cos(wt)' */
  if (rtDW.systemEnable_e3 != 0) {
    rtDW.lastSin_c = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_a5 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e3 = 0;
  }

  /* Product: '<S610>/Product1' incorporates:
   *  Sin: '<S610>/cos(wt)'
   */
  rtb_Product1_e = ((rtDW.lastSin_c * 0.0018849544759281464 + rtDW.lastCos_a5 *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_a5 * 0.0018849544759281464 - rtDW.lastSin_c *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[61];

  /* DiscreteIntegrator: '<S628>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_h5 != 0) {
    rtDW.Integ4_hp = rtDW.Integ4_DSTATE_fv;
  } else {
    rtDW.Integ4_hp = 2.5E-6 * rtb_Product1_e + rtDW.Integ4_DSTATE_fv;
  }

  /* End of DiscreteIntegrator: '<S628>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */

  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S610>/sin(wt)' */
  if (rtDW.systemEnable_bl != 0) {
    rtDW.lastSin_mp = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_pe = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bl = 0;
  }

  /* Product: '<S610>/Product' incorporates:
   *  Sin: '<S610>/sin(wt)'
   */
  rtb_Product_jn = ((rtDW.lastSin_mp * 0.99999822347173384 + rtDW.lastCos_pe *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_pe * 0.99999822347173384 - rtDW.lastSin_mp *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[61];

  /* DiscreteIntegrator: '<S630>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_k5 != 0) {
    rtDW.Integ4_ce = rtDW.Integ4_DSTATE_ex;
  } else {
    rtDW.Integ4_ce = 2.5E-6 * rtb_Product_jn + rtDW.Integ4_DSTATE_ex;
  }

  /* End of DiscreteIntegrator: '<S630>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */

  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S518>/cos(wt)' */
  if (rtDW.systemEnable_pz != 0) {
    rtDW.lastSin_nh = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_kw = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_pz = 0;
  }

  /* Product: '<S518>/Product1' incorporates:
   *  Sin: '<S518>/cos(wt)'
   */
  rtb_Product1_i = ((rtDW.lastSin_nh * 0.0018849544759281464 + rtDW.lastCos_kw *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_kw * 0.0018849544759281464 - rtDW.lastSin_nh *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[57];

  /* DiscreteIntegrator: '<S522>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bj != 0) {
    rtDW.Integ4_mu = rtDW.Integ4_DSTATE_nc;
  } else {
    rtDW.Integ4_mu = 2.5E-6 * rtb_Product1_i + rtDW.Integ4_DSTATE_nc;
  }

  /* End of DiscreteIntegrator: '<S522>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */

  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S518>/sin(wt)' */
  if (rtDW.systemEnable_avi != 0) {
    rtDW.lastSin_mi = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bb = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_avi = 0;
  }

  /* Product: '<S518>/Product' incorporates:
   *  Sin: '<S518>/sin(wt)'
   */
  rtb_Product_ae = ((rtDW.lastSin_mi * 0.99999822347173384 + rtDW.lastCos_bb *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_bb * 0.99999822347173384 - rtDW.lastSin_mi *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[57];

  /* DiscreteIntegrator: '<S524>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ba != 0) {
    rtDW.Integ4_ddm = rtDW.Integ4_DSTATE_nd;
  } else {
    rtDW.Integ4_ddm = 2.5E-6 * rtb_Product_ae + rtDW.Integ4_DSTATE_nd;
  }

  /* End of DiscreteIntegrator: '<S524>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */

  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S519>/cos(wt)' */
  if (rtDW.systemEnable_ci != 0) {
    rtDW.lastSin_et = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ju = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ci = 0;
  }

  /* Product: '<S519>/Product1' incorporates:
   *  Sin: '<S519>/cos(wt)'
   */
  rtb_Product1_dr = ((rtDW.lastSin_et * 0.0018849544759281464 + rtDW.lastCos_ju *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_ju * 0.0018849544759281464 - rtDW.lastSin_et *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[69];

  /* DiscreteIntegrator: '<S528>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gl != 0) {
    rtDW.Integ4_m1 = rtDW.Integ4_DSTATE_li;
  } else {
    rtDW.Integ4_m1 = 2.5E-6 * rtb_Product1_dr + rtDW.Integ4_DSTATE_li;
  }

  /* End of DiscreteIntegrator: '<S528>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */

  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S519>/sin(wt)' */
  if (rtDW.systemEnable_bj1 != 0) {
    rtDW.lastSin_ac = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bd = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bj1 = 0;
  }

  /* Product: '<S519>/Product' incorporates:
   *  Sin: '<S519>/sin(wt)'
   */
  rtb_Product_d = ((rtDW.lastSin_ac * 0.99999822347173384 + rtDW.lastCos_bd *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_bd * 0.99999822347173384 - rtDW.lastSin_ac *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[69];

  /* DiscreteIntegrator: '<S530>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_fs != 0) {
    rtDW.Integ4_nr = rtDW.Integ4_DSTATE_j5d;
  } else {
    rtDW.Integ4_nr = 2.5E-6 * rtb_Product_d + rtDW.Integ4_DSTATE_j5d;
  }

  /* End of DiscreteIntegrator: '<S530>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */

  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S534>/cos(wt)' */
  if (rtDW.systemEnable_co != 0) {
    rtDW.lastSin_at = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ci = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_co = 0;
  }

  /* Product: '<S534>/Product1' incorporates:
   *  Sin: '<S534>/cos(wt)'
   */
  rtb_Product1_co = ((rtDW.lastSin_at * 0.0018849544759281464 + rtDW.lastCos_ci *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_ci * 0.0018849544759281464 - rtDW.lastSin_at *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[48];

  /* DiscreteIntegrator: '<S542>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_cm != 0) {
    rtDW.Integ4_ab = rtDW.Integ4_DSTATE_av;
  } else {
    rtDW.Integ4_ab = 2.5E-6 * rtb_Product1_co + rtDW.Integ4_DSTATE_av;
  }

  /* End of DiscreteIntegrator: '<S542>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */

  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S534>/sin(wt)' */
  if (rtDW.systemEnable_pd != 0) {
    rtDW.lastSin_la = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bbd = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_pd = 0;
  }

  /* Product: '<S534>/Product' incorporates:
   *  Sin: '<S534>/sin(wt)'
   */
  rtb_Product_p5i = ((rtDW.lastSin_la * 0.99999822347173384 + rtDW.lastCos_bbd *
                      -0.0018849544759281136) * 0.99999822347173384 +
                     (rtDW.lastCos_bbd * 0.99999822347173384 - rtDW.lastSin_la *
                      -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[48];

  /* DiscreteIntegrator: '<S544>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_cc != 0) {
    rtDW.Integ4_cc = rtDW.Integ4_DSTATE_leb;
  } else {
    rtDW.Integ4_cc = 2.5E-6 * rtb_Product_p5i + rtDW.Integ4_DSTATE_leb;
  }

  /* End of DiscreteIntegrator: '<S544>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */

  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S535>/cos(wt)' */
  if (rtDW.systemEnable_i2 != 0) {
    rtDW.lastSin_gh = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_lz = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_i2 = 0;
  }

  /* Product: '<S535>/Product1' incorporates:
   *  Sin: '<S535>/cos(wt)'
   */
  rtb_Product1_o = ((rtDW.lastSin_gh * 0.0018849544759281464 + rtDW.lastCos_lz *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_lz * 0.0018849544759281464 - rtDW.lastSin_gh *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[49];

  /* DiscreteIntegrator: '<S548>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ix != 0) {
    rtDW.Integ4_m3 = rtDW.Integ4_DSTATE_b;
  } else {
    rtDW.Integ4_m3 = 2.5E-6 * rtb_Product1_o + rtDW.Integ4_DSTATE_b;
  }

  /* End of DiscreteIntegrator: '<S548>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S549>/S-Function' incorporates:
   *  Constant: '<S548>/K1'
   */

  /* Level2 S-Function Block: '<S549>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S535>/sin(wt)' */
  if (rtDW.systemEnable_ov != 0) {
    rtDW.lastSin_lo = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gsk = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ov = 0;
  }

  /* Product: '<S535>/Product' incorporates:
   *  Sin: '<S535>/sin(wt)'
   */
  rtb_Product_d3 = ((rtDW.lastSin_lo * 0.99999822347173384 + rtDW.lastCos_gsk *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_gsk * 0.99999822347173384 - rtDW.lastSin_lo *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[49];

  /* DiscreteIntegrator: '<S550>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jo != 0) {
    rtDW.Integ4_ocz = rtDW.Integ4_DSTATE_e5;
  } else {
    rtDW.Integ4_ocz = 2.5E-6 * rtb_Product_d3 + rtDW.Integ4_DSTATE_e5;
  }

  /* End of DiscreteIntegrator: '<S550>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S551>/S-Function' incorporates:
   *  Constant: '<S550>/K1'
   */

  /* Level2 S-Function Block: '<S551>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S536>/cos(wt)' */
  if (rtDW.systemEnable_mj != 0) {
    rtDW.lastSin_fa = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_hf = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_mj = 0;
  }

  /* Product: '<S536>/Product1' incorporates:
   *  Sin: '<S536>/cos(wt)'
   */
  rtb_Product1_dtt = ((rtDW.lastSin_fa * 0.0018849544759281464 + rtDW.lastCos_hf
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_hf * 0.0018849544759281464 - rtDW.lastSin_fa
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[50];

  /* DiscreteIntegrator: '<S554>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bu != 0) {
    rtDW.Integ4_frw = rtDW.Integ4_DSTATE_eb;
  } else {
    rtDW.Integ4_frw = 2.5E-6 * rtb_Product1_dtt + rtDW.Integ4_DSTATE_eb;
  }

  /* End of DiscreteIntegrator: '<S554>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */

  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S536>/sin(wt)' */
  if (rtDW.systemEnable_nf != 0) {
    rtDW.lastSin_lk = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ig = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_nf = 0;
  }

  /* Product: '<S536>/Product' incorporates:
   *  Sin: '<S536>/sin(wt)'
   */
  rtb_Product_m = ((rtDW.lastSin_lk * 0.99999822347173384 + rtDW.lastCos_ig *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_ig * 0.99999822347173384 - rtDW.lastSin_lk *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[50];

  /* DiscreteIntegrator: '<S556>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i0 != 0) {
    rtDW.Integ4_ah = rtDW.Integ4_DSTATE_cq;
  } else {
    rtDW.Integ4_ah = 2.5E-6 * rtb_Product_m + rtDW.Integ4_DSTATE_cq;
  }

  /* End of DiscreteIntegrator: '<S556>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S557>/S-Function' incorporates:
   *  Constant: '<S556>/K1'
   */

  /* Level2 S-Function Block: '<S557>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S558>/cos(wt)' */
  if (rtDW.systemEnable_mx != 0) {
    rtDW.lastSin_gh2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ew = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_mx = 0;
  }

  /* Product: '<S558>/Product1' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S558>/cos(wt)'
   */
  rtb_Product1_kv = ((rtDW.lastSin_gh2 * 0.0018849544759281464 + rtDW.lastCos_ew
                      * 0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_ew * 0.0018849544759281464 - rtDW.lastSin_gh2
                      * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1[62];

  /* DiscreteIntegrator: '<S566>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_af != 0) {
    rtDW.Integ4_jz = rtDW.Integ4_DSTATE_hc;
  } else {
    rtDW.Integ4_jz = 2.5E-6 * rtb_Product1_kv + rtDW.Integ4_DSTATE_hc;
  }

  /* End of DiscreteIntegrator: '<S566>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S567>/S-Function' incorporates:
   *  Constant: '<S566>/K1'
   */

  /* Level2 S-Function Block: '<S567>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S558>/sin(wt)' */
  if (rtDW.systemEnable_mx0 != 0) {
    rtDW.lastSin_nr = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_op = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_mx0 = 0;
  }

  /* Product: '<S558>/Product' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S558>/sin(wt)'
   */
  rtb_Product_k = ((rtDW.lastSin_nr * 0.99999822347173384 + rtDW.lastCos_op *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_op * 0.99999822347173384 - rtDW.lastSin_nr *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1[62];

  /* DiscreteIntegrator: '<S568>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ks != 0) {
    rtDW.Integ4_oe = rtDW.Integ4_DSTATE_m3;
  } else {
    rtDW.Integ4_oe = 2.5E-6 * rtb_Product_k + rtDW.Integ4_DSTATE_m3;
  }

  /* End of DiscreteIntegrator: '<S568>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S569>/S-Function' incorporates:
   *  Constant: '<S568>/K1'
   */

  /* Level2 S-Function Block: '<S569>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S559>/cos(wt)' */
  if (rtDW.systemEnable_gl != 0) {
    rtDW.lastSin_fxm = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h0 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_gl = 0;
  }

  /* Product: '<S559>/Product1' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S559>/cos(wt)'
   */
  rtb_Product1_f = ((rtDW.lastSin_fxm * 0.0018849544759281464 + rtDW.lastCos_h0 *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_h0 * 0.0018849544759281464 - rtDW.lastSin_fxm *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1[63];

  /* DiscreteIntegrator: '<S572>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_fu != 0) {
    rtDW.Integ4_ea = rtDW.Integ4_DSTATE_bo;
  } else {
    rtDW.Integ4_ea = 2.5E-6 * rtb_Product1_f + rtDW.Integ4_DSTATE_bo;
  }

  /* End of DiscreteIntegrator: '<S572>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */

  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S559>/sin(wt)' */
  if (rtDW.systemEnable_df != 0) {
    rtDW.lastSin_o2f = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_niz = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_df = 0;
  }

  /* Product: '<S559>/Product' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S559>/sin(wt)'
   */
  rtb_Product_a = ((rtDW.lastSin_o2f * 0.99999822347173384 + rtDW.lastCos_niz *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_niz * 0.99999822347173384 - rtDW.lastSin_o2f *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1[63];

  /* DiscreteIntegrator: '<S574>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ns != 0) {
    rtDW.Integ4_no = rtDW.Integ4_DSTATE_jx;
  } else {
    rtDW.Integ4_no = 2.5E-6 * rtb_Product_a + rtDW.Integ4_DSTATE_jx;
  }

  /* End of DiscreteIntegrator: '<S574>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */

  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S560>/cos(wt)' */
  if (rtDW.systemEnable_h1 != 0) {
    rtDW.lastSin_p0 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fu = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_h1 = 0;
  }

  /* Product: '<S560>/Product1' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S560>/cos(wt)'
   */
  rtb_Product1_a = ((rtDW.lastSin_p0 * 0.0018849544759281464 + rtDW.lastCos_fu *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_fu * 0.0018849544759281464 - rtDW.lastSin_p0 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1[64];

  /* DiscreteIntegrator: '<S578>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_or != 0) {
    rtDW.Integ4_ex = rtDW.Integ4_DSTATE_g5;
  } else {
    rtDW.Integ4_ex = 2.5E-6 * rtb_Product1_a + rtDW.Integ4_DSTATE_g5;
  }

  /* End of DiscreteIntegrator: '<S578>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */

  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S560>/sin(wt)' */
  if (rtDW.systemEnable_iv != 0) {
    rtDW.lastSin_nx = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ez = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_iv = 0;
  }

  /* Product: '<S560>/Product' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S560>/sin(wt)'
   */
  rtb_Product_jv = ((rtDW.lastSin_nx * 0.99999822347173384 + rtDW.lastCos_ez *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ez * 0.99999822347173384 - rtDW.lastSin_nx *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1[64];

  /* DiscreteIntegrator: '<S580>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_a0 != 0) {
    rtDW.Integ4_ij = rtDW.Integ4_DSTATE_my;
  } else {
    rtDW.Integ4_ij = 2.5E-6 * rtb_Product_jv + rtDW.Integ4_DSTATE_my;
  }

  /* End of DiscreteIntegrator: '<S580>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */

  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S632>/cos(wt)' */
  if (rtDW.systemEnable_jo != 0) {
    rtDW.lastSin_eb = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h2 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_jo = 0;
  }

  /* Product: '<S632>/Product1' incorporates:
   *  Sin: '<S632>/cos(wt)'
   */
  rtb_Product1_n = ((rtDW.lastSin_eb * 0.0018849544759281464 + rtDW.lastCos_h2 *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_h2 * 0.0018849544759281464 - rtDW.lastSin_eb *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[48];

  /* DiscreteIntegrator: '<S640>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ic != 0) {
    rtDW.Integ4_fg = rtDW.Integ4_DSTATE_pv;
  } else {
    rtDW.Integ4_fg = 2.5E-6 * rtb_Product1_n + rtDW.Integ4_DSTATE_pv;
  }

  /* End of DiscreteIntegrator: '<S640>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S641>/S-Function' incorporates:
   *  Constant: '<S640>/K1'
   */

  /* Level2 S-Function Block: '<S641>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S632>/sin(wt)' */
  if (rtDW.systemEnable_fh != 0) {
    rtDW.lastSin_pc = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fuy = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fh = 0;
  }

  /* Product: '<S632>/Product' incorporates:
   *  Sin: '<S632>/sin(wt)'
   */
  rtb_Product_kb = ((rtDW.lastSin_pc * 0.99999822347173384 + rtDW.lastCos_fuy *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_fuy * 0.99999822347173384 - rtDW.lastSin_pc *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[48];

  /* DiscreteIntegrator: '<S642>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bz != 0) {
    rtDW.Integ4_kv = rtDW.Integ4_DSTATE_ij;
  } else {
    rtDW.Integ4_kv = 2.5E-6 * rtb_Product_kb + rtDW.Integ4_DSTATE_ij;
  }

  /* End of DiscreteIntegrator: '<S642>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S643>/S-Function' incorporates:
   *  Constant: '<S642>/K1'
   */

  /* Level2 S-Function Block: '<S643>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S633>/cos(wt)' */
  if (rtDW.systemEnable_lo != 0) {
    rtDW.lastSin_ae = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_kf = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_lo = 0;
  }

  /* Product: '<S633>/Product1' incorporates:
   *  Sin: '<S633>/cos(wt)'
   */
  rtb_Product1_fb = ((rtDW.lastSin_ae * 0.0018849544759281464 + rtDW.lastCos_kf *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_kf * 0.0018849544759281464 - rtDW.lastSin_ae *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[49];

  /* DiscreteIntegrator: '<S646>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ds != 0) {
    rtDW.Integ4_ks = rtDW.Integ4_DSTATE_n2;
  } else {
    rtDW.Integ4_ks = 2.5E-6 * rtb_Product1_fb + rtDW.Integ4_DSTATE_n2;
  }

  /* End of DiscreteIntegrator: '<S646>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */

  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S633>/sin(wt)' */
  if (rtDW.systemEnable_jc != 0) {
    rtDW.lastSin_mk = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_pk = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_jc = 0;
  }

  /* Product: '<S633>/Product' incorporates:
   *  Sin: '<S633>/sin(wt)'
   */
  rtb_Product_pg = ((rtDW.lastSin_mk * 0.99999822347173384 + rtDW.lastCos_pk *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_pk * 0.99999822347173384 - rtDW.lastSin_mk *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[49];

  /* DiscreteIntegrator: '<S648>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ow != 0) {
    rtDW.Integ4_dl = rtDW.Integ4_DSTATE_dy;
  } else {
    rtDW.Integ4_dl = 2.5E-6 * rtb_Product_pg + rtDW.Integ4_DSTATE_dy;
  }

  /* End of DiscreteIntegrator: '<S648>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */

  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S634>/cos(wt)' */
  if (rtDW.systemEnable_pq != 0) {
    rtDW.lastSin_pu = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bdo = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_pq = 0;
  }

  /* Product: '<S634>/Product1' incorporates:
   *  Sin: '<S634>/cos(wt)'
   */
  rtb_Product1_cs = ((rtDW.lastSin_pu * 0.0018849544759281464 + rtDW.lastCos_bdo
                      * 0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_bdo * 0.0018849544759281464 - rtDW.lastSin_pu
                      * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[50];

  /* DiscreteIntegrator: '<S652>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i1 != 0) {
    rtDW.Integ4_kd = rtDW.Integ4_DSTATE_hd;
  } else {
    rtDW.Integ4_kd = 2.5E-6 * rtb_Product1_cs + rtDW.Integ4_DSTATE_hd;
  }

  /* End of DiscreteIntegrator: '<S652>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */

  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S634>/sin(wt)' */
  if (rtDW.systemEnable_n5 != 0) {
    rtDW.lastSin_cp = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_k1 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_n5 = 0;
  }

  /* Product: '<S634>/Product' incorporates:
   *  Sin: '<S634>/sin(wt)'
   */
  rtb_Product_pk = ((rtDW.lastSin_cp * 0.99999822347173384 + rtDW.lastCos_k1 *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_k1 * 0.99999822347173384 - rtDW.lastSin_cp *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1[50];

  /* DiscreteIntegrator: '<S654>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_oo != 0) {
    rtDW.Integ4_id = rtDW.Integ4_DSTATE_pa;
  } else {
    rtDW.Integ4_id = 2.5E-6 * rtb_Product_pk + rtDW.Integ4_DSTATE_pa;
  }

  /* End of DiscreteIntegrator: '<S654>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */

  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S514>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_co != 0) {
    rtDW.Integ4_ddl = rtDW.Integ4_DSTATE_px;
  } else {
    rtDW.Integ4_ddl = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_DSTATE_px;
  }

  /* End of DiscreteIntegrator: '<S514>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S515>/S-Function' incorporates:
   *  Constant: '<S514>/K1'
   */

  /* Level2 S-Function Block: '<S515>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S510>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_pb != 0) {
    rtDW.Integ4_pt = rtDW.Integ4_DSTATE_exz;
  } else {
    rtDW.Integ4_pt = 2.5E-6 * rtb_phi + rtDW.Integ4_DSTATE_exz;
  }

  /* End of DiscreteIntegrator: '<S510>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S511>/S-Function' incorporates:
   *  Constant: '<S510>/K1'
   */

  /* Level2 S-Function Block: '<S511>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S512>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bzw != 0) {
    rtDW.Integ4_pf = rtDW.Integ4_DSTATE_hs;
  } else {
    rtDW.Integ4_pf = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_DSTATE_hs;
  }

  /* End of DiscreteIntegrator: '<S512>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S513>/S-Function' incorporates:
   *  Constant: '<S512>/K1'
   */

  /* Level2 S-Function Block: '<S513>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnOutputs(rts,0);
  }

  /* Update for S-Function (sfun_spssw_discc): '<S830>/State-Space' incorporates:
   *  Constant: '<S342>/DC'
   */

  /* S-Function block: <S830>/State-Space */
  {
    const real_T *As = (real_T*)rtDW.StateSpace_PWORK.AS;
    const real_T *Bs = (real_T*)rtDW.StateSpace_PWORK.BS;
    real_T *xtmp = (real_T*)rtDW.StateSpace_PWORK.XTMP;
    real_T accum;

    /* Calculate new states... */
    accum = 0.0;
    accum += *(As++) * rtDW.StateSpace_DSTATE;
    accum += *(Bs++) * 500.0;
    xtmp[0] = accum;
    rtDW.StateSpace_DSTATE = xtmp[0];
  }

  /* Update for Sin: '<Root>/Vload' */
  lastSin_o3_tmp = rtDW.lastSin;
  rtDW.lastSin = rtDW.lastSin * 0.99999998766299447 + rtDW.lastCos *
    0.00015707963203352558;
  rtDW.lastCos = rtDW.lastCos * 0.99999998766299447 - lastSin_o3_tmp *
    0.00015707963203352558;

  /* Signum: '<S339>/Sign' incorporates:
   *  DiscreteIntegrator: '<S334>/Discrete-Time Integrator'
   */
  if (rtDW.DiscreteTimeIntegrator_DSTATE < 0.0) {
    lastSin_o3_tmp = -1.0;
  } else if (rtDW.DiscreteTimeIntegrator_DSTATE > 0.0) {
    lastSin_o3_tmp = 1.0;
  } else if (rtDW.DiscreteTimeIntegrator_DSTATE == 0.0) {
    lastSin_o3_tmp = 0.0;
  } else {
    lastSin_o3_tmp = (rtNaN);
  }

  /* End of Signum: '<S339>/Sign' */

  /* Update for DiscreteIntegrator: '<S334>/Discrete-Time Integrator' incorporates:
   *  Constant: '<Root>/Load Torque'
   *  Gain: '<S334>/Gain2'
   *  Gain: '<S339>/Gain'
   *  Gain: '<S339>/Gain1'
   *  Product: '<S334>/Product1'
   *  Sum: '<S334>/Sum'
   *  Sum: '<S339>/Sum'
   *  UnitDelay: '<S334>/KE filter'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE += ((rtDW.StateSpace_o1[67] *
    rtDW.KEfilter_DSTATE - 1000.0) - (0.0 * lastSin_o3_tmp + 0.272 *
    rtDW.DiscreteTimeIntegrator_DSTATE)) * 0.1 * 5.0E-6;

  /* Update for UnitDelay: '<S334>/KE filter' */
  rtDW.KEfilter_DSTATE = rtb_Add4;

  /* Update for S-Function (sfun_spssw_discc): '<S831>/State-Space' incorporates:
   *  Constant: '<S343>/DC'
   *  Constant: '<S835>/SwitchCurrents'
   */

  /* S-Function block: <S831>/State-Space */
  {
    const real_T *As = (real_T*)rtDW.StateSpace_PWORK_n.AS;
    const real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_n.BS;
    real_T *xtmp = (real_T*)rtDW.StateSpace_PWORK_n.XTMP;
    real_T accum;

    /* Calculate new states... */
    {
      int_T i1;
      real_T *xd = &rtDW.StateSpace_DSTATE_d[0];
      for (i1=0; i1 < 40; i1++) {
        accum = 0.0;

        {
          int_T i2;
          real_T *xd = &rtDW.StateSpace_DSTATE_d[0];
          for (i2=0; i2 < 40; i2++) {
            accum += *(As++) * xd[i2];
          }
        }

        {
          int_T i2;
          const real_T *u0 = rtConstP.SwitchCurrents_Value;
          for (i2=0; i2 < 40; i2++) {
            accum += *(Bs++) * u0[i2];
          }

          accum += *(Bs++) * 0.0;
          accum += *(Bs++) * 0.0;
          accum += *(Bs++) * 500.0;
          accum += *(Bs++) * rtDW.Vload;
          accum += *(Bs++) * rtDW.Product;
          accum += *(Bs++) * rtDW.Sum5[0];
          accum += *(Bs++) * rtDW.Sum5[1];
          accum += *(Bs++) * rtDW.Sum5[2];
        }

        xtmp[i1] = accum;
      }
    }

    {
      int_T i1;
      real_T *xd = &rtDW.StateSpace_DSTATE_d[0];
      for (i1=0; i1 < 40; i1++) {
        xd[i1] = xtmp[i1];
      }
    }

    {
      int_T *gState = (int_T*)rtDW.StateSpace_PWORK_n.G_STATE;

      /* Store switch gates values for next step */
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) rtDW.Product4;
      *(gState++) = (int_T) rtDW.Product4_o;
      *(gState++) = (int_T) rtDW.Product4_k[0];
      *(gState++) = (int_T) rtDW.Product4_k[1];
      *(gState++) = (int_T) rtDW.Product4_k[2];
      *(gState++) = (int_T) rtDW.Product4_k[3];
      *(gState++) = (int_T) rtDW.Product4_e[0];
      *(gState++) = (int_T) rtDW.Product4_e[1];
      *(gState++) = (int_T) rtDW.Product4_c[0];
      *(gState++) = (int_T) rtDW.Product4_c[1];
      *(gState++) = (int_T) rtDW.Product4_c[2];
      *(gState++) = (int_T) rtDW.Product4_c[3];
      *(gState++) = (int_T) rtDW.Product4_d[0];
      *(gState++) = (int_T) rtDW.Product4_d[1];
      *(gState++) = (int_T) rtDW.Product4_d[2];
      *(gState++) = (int_T) rtDW.Product4_d[3];
      *(gState++) = (int_T) rtDW.Product4_p[0];
      *(gState++) = (int_T) rtDW.Product4_p[1];
      *(gState++) = (int_T) rtDW.Product4_p[2];
      *(gState++) = (int_T) rtDW.Product4_p[3];
      *(gState++) = (int_T) rtDW.Product4_h[0];
      *(gState++) = (int_T) rtDW.Product4_h[1];
      *(gState++) = (int_T) rtDW.Product4_it[0];
      *(gState++) = (int_T) rtDW.Product4_it[1];
      *(gState++) = (int_T) rtDW.Product4_ij[0];
      *(gState++) = (int_T) rtDW.Product4_ij[1];
      *(gState++) = (int_T) rtDW.Product4_a[0];
      *(gState++) = (int_T) rtDW.Product4_a[1];
      *(gState++) = (int_T) rtDW.Product4_az[0];
      *(gState++) = (int_T) rtDW.Product4_az[1];
      *(gState++) = (int_T) rtDW.Product4_j[0];
      *(gState++) = (int_T) rtDW.Product4_j[1];
      *(gState++) = (int_T) rtDW.Product4_i[0];
      *(gState++) = (int_T) rtDW.Product4_i[1];
    }
  }

  /* Update for Sin: '<S404>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_o;
  rtDW.lastSin_o = rtDW.lastSin_o * 0.99999822347173384 + rtDW.lastCos_n *
    0.0018849544759281136;
  rtDW.lastCos_n = rtDW.lastCos_n * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S414>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE = 0U;
  rtDW.Integ4_DSTATE = 2.5E-6 * rtb_Switch2 + rtDW.Integ4;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */
  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S414>/Unit Delay' */
  rtDW.UnitDelay_DSTATE = rtb_Switch2;

  /* Update for UnitDelay: '<S414>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE = rtb_sinwt;

  /* Update for Sin: '<S404>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_j;
  rtDW.lastSin_j = rtDW.lastSin_j * 0.99999822347173384 + rtDW.lastCos_i *
    0.0018849544759281136;
  rtDW.lastCos_i = rtDW.lastCos_i * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S412>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_e = 0U;
  rtDW.Integ4_DSTATE_e = 2.5E-6 * rtb_Product1 + rtDW.Integ4_p;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */
  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S412>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_c = rtb_Product1;

  /* Update for UnitDelay: '<S412>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_l = rtb_Switch_dn;

  /* Update for Sin: '<S405>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_h;
  rtDW.lastSin_h = rtDW.lastSin_h * 0.99999822347173384 + rtDW.lastCos_j *
    0.0018849544759281136;
  rtDW.lastCos_j = rtDW.lastCos_j * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S420>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_c = 0U;
  rtDW.Integ4_DSTATE_d = 2.5E-6 * rtb_Product_jl + rtDW.Integ4_d;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S421>/S-Function' incorporates:
   *  Constant: '<S420>/K1'
   */
  /* Level2 S-Function Block: '<S421>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S420>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_g = rtb_Product_jl;

  /* Update for UnitDelay: '<S420>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_f = rtb_Switch_l2;

  /* Update for Sin: '<S405>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_hi;
  rtDW.lastSin_hi = rtDW.lastSin_hi * 0.99999822347173384 + rtDW.lastCos_o *
    0.0018849544759281136;
  rtDW.lastCos_o = rtDW.lastCos_o * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S418>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i = 0U;
  rtDW.Integ4_DSTATE_dw = 2.5E-6 * rtb_Product1_mv + rtDW.Integ4_h;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S419>/S-Function' incorporates:
   *  Constant: '<S418>/K1'
   */
  /* Level2 S-Function Block: '<S419>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S418>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_e = rtb_Product1_mv;

  /* Update for UnitDelay: '<S418>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_j = rtb_Switch_lk;

  /* Update for Sin: '<S406>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_e;
  rtDW.lastSin_e = rtDW.lastSin_e * 0.99999822347173384 + rtDW.lastCos_f *
    0.0018849544759281136;
  rtDW.lastCos_f = rtDW.lastCos_f * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S426>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n = 0U;
  rtDW.Integ4_DSTATE_p = 2.5E-6 * rtb_Product_e + rtDW.Integ4_a;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S427>/S-Function' incorporates:
   *  Constant: '<S426>/K1'
   */
  /* Level2 S-Function Block: '<S427>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S426>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_l = rtb_Product_e;

  /* Update for UnitDelay: '<S426>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_n = rtb_Switch_ac;

  /* Update for Sin: '<S406>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_k;
  rtDW.lastSin_k = rtDW.lastSin_k * 0.99999822347173384 + rtDW.lastCos_g *
    0.0018849544759281136;
  rtDW.lastCos_g = rtDW.lastCos_g * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S424>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k = 0U;
  rtDW.Integ4_DSTATE_pr = 2.5E-6 * rtb_Product1_gec + rtDW.Integ4_c;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */
  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S424>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_eo = rtb_Product1_gec;

  /* Update for UnitDelay: '<S424>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_h = rtb_Switch_ma;

  /* Update for Sin: '<S428>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ob;
  rtDW.lastSin_ob = rtDW.lastSin_ob * 0.99999822347173384 + rtDW.lastCos_k *
    0.0018849544759281136;
  rtDW.lastCos_k = rtDW.lastCos_k * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S438>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_g = 0U;
  rtDW.Integ4_DSTATE_o = 2.5E-6 * rtb_Product_bk + rtDW.Integ4_ae;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S439>/S-Function' incorporates:
   *  Constant: '<S438>/K1'
   */
  /* Level2 S-Function Block: '<S439>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S438>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_h = rtb_Product_bk;

  /* Update for UnitDelay: '<S438>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_a = rtb_Switch_jl;

  /* Update for Sin: '<S428>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_f;
  rtDW.lastSin_f = rtDW.lastSin_f * 0.99999822347173384 + rtDW.lastCos_e *
    0.0018849544759281136;
  rtDW.lastCos_e = rtDW.lastCos_e * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S436>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ex = 0U;
  rtDW.Integ4_DSTATE_i = 2.5E-6 * rtb_Product1_or + rtDW.Integ4_k;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S437>/S-Function' incorporates:
   *  Constant: '<S436>/K1'
   */
  /* Level2 S-Function Block: '<S437>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S436>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_f = rtb_Product1_or;

  /* Update for UnitDelay: '<S436>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_av = rtb_Switch_b;

  /* Update for Sin: '<S429>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_h0;
  rtDW.lastSin_h0 = rtDW.lastSin_h0 * 0.99999822347173384 + rtDW.lastCos_ov *
    0.0018849544759281136;
  rtDW.lastCos_ov = rtDW.lastCos_ov * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S444>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kl = 0U;
  rtDW.Integ4_DSTATE_g = 2.5E-6 * rtb_Product_gi + rtDW.Integ4_dh;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */
  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S444>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_b = rtb_Product_gi;

  /* Update for UnitDelay: '<S444>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m = rtb_Switch_iv;

  /* Update for Sin: '<S429>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_a;
  rtDW.lastSin_a = rtDW.lastSin_a * 0.99999822347173384 + rtDW.lastCos_h *
    0.0018849544759281136;
  rtDW.lastCos_h = rtDW.lastCos_h * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S442>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_l = 0U;
  rtDW.Integ4_DSTATE_m = 2.5E-6 * rtb_Product1_nj + rtDW.Integ4_b;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */
  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S442>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_lm = rtb_Product1_nj;

  /* Update for UnitDelay: '<S442>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o = rtb_Switch_n;

  /* Update for Sin: '<S430>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fx;
  rtDW.lastSin_fx = rtDW.lastSin_fx * 0.99999822347173384 + rtDW.lastCos_c *
    0.0018849544759281136;
  rtDW.lastCos_c = rtDW.lastCos_c * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S450>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k2 = 0U;
  rtDW.Integ4_DSTATE_j = 2.5E-6 * rtb_Product_o + rtDW.Integ4_hq;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */
  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S450>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_i = rtb_Product_o;

  /* Update for UnitDelay: '<S450>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jl = rtb_Switch_bl;

  /* Update for Sin: '<S430>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_f2;
  rtDW.lastSin_f2 = rtDW.lastSin_f2 * 0.99999822347173384 + rtDW.lastCos_ni *
    0.0018849544759281136;
  rtDW.lastCos_ni = rtDW.lastCos_ni * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S448>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_j = 0U;
  rtDW.Integ4_DSTATE_l = 2.5E-6 * rtb_Product1_he + rtDW.Integ4_j;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */
  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S448>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_p = rtb_Product1_he;

  /* Update for UnitDelay: '<S448>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ha = rtb_Switch_p;

  /* Update for Sin: '<S779>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fm;
  rtDW.lastSin_fm = rtDW.lastSin_fm * 0.99999822347173384 + rtDW.lastCos_e4 *
    0.0018849544759281136;
  rtDW.lastCos_e4 = rtDW.lastCos_e4 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S789>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o = 0U;
  rtDW.Integ4_DSTATE_os = 2.5E-6 * rtb_Product_kx + rtDW.Integ4_f;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S790>/S-Function' incorporates:
   *  Constant: '<S789>/K1'
   */
  /* Level2 S-Function Block: '<S790>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S789>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_o = rtb_Product_kx;

  /* Update for UnitDelay: '<S789>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ay = rtb_Switch_f;

  /* Update for Sin: '<S779>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_f5;
  rtDW.lastSin_f5 = rtDW.lastSin_f5 * 0.99999822347173384 + rtDW.lastCos_l *
    0.0018849544759281136;
  rtDW.lastCos_l = rtDW.lastCos_l * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S787>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_km = 0U;
  rtDW.Integ4_DSTATE_lo = 2.5E-6 * rtb_Product1_fm + rtDW.Integ4_aa;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S788>/S-Function' incorporates:
   *  Constant: '<S787>/K1'
   */
  /* Level2 S-Function Block: '<S788>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S787>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_a = rtb_Product1_fm;

  /* Update for UnitDelay: '<S787>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_e = rtb_Switch_o5;

  /* Update for Sin: '<S780>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fmt;
  rtDW.lastSin_fmt = rtDW.lastSin_fmt * 0.99999822347173384 + rtDW.lastCos_ns *
    0.0018849544759281136;
  rtDW.lastCos_ns = rtDW.lastCos_ns * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S795>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_f = 0U;
  rtDW.Integ4_DSTATE_n = 2.5E-6 * rtb_Product_h5 + rtDW.Integ4_f0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S796>/S-Function' incorporates:
   *  Constant: '<S795>/K1'
   */
  /* Level2 S-Function Block: '<S796>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S795>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ln = rtb_Product_h5;

  /* Update for UnitDelay: '<S795>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_c = rtb_Switch_c;

  /* Update for Sin: '<S780>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_d;
  rtDW.lastSin_d = rtDW.lastSin_d * 0.99999822347173384 + rtDW.lastCos_a *
    0.0018849544759281136;
  rtDW.lastCos_a = rtDW.lastCos_a * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S793>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fy = 0U;
  rtDW.Integ4_DSTATE_lc = 2.5E-6 * rtb_Product1_ku + rtDW.Integ4_i;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S794>/S-Function' incorporates:
   *  Constant: '<S793>/K1'
   */
  /* Level2 S-Function Block: '<S794>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S793>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_n = rtb_Product1_ku;

  /* Update for UnitDelay: '<S793>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ag = rtb_Switch_o;

  /* Update for Sin: '<S781>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_d1;
  rtDW.lastSin_d1 = rtDW.lastSin_d1 * 0.99999822347173384 + rtDW.lastCos_d *
    0.0018849544759281136;
  rtDW.lastCos_d = rtDW.lastCos_d * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S801>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n0 = 0U;
  rtDW.Integ4_DSTATE_o0 = 2.5E-6 * rtb_Product_gk + rtDW.Integ4_l;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S802>/S-Function' incorporates:
   *  Constant: '<S801>/K1'
   */
  /* Level2 S-Function Block: '<S802>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S801>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_gs = rtb_Product_gk;

  /* Update for UnitDelay: '<S801>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_cr = rtb_Switch_jj;

  /* Update for Sin: '<S781>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_l;
  rtDW.lastSin_l = rtDW.lastSin_l * 0.99999822347173384 + rtDW.lastCos_l0 *
    0.0018849544759281136;
  rtDW.lastCos_l0 = rtDW.lastCos_l0 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S799>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_d = 0U;
  rtDW.Integ4_DSTATE_pu = 2.5E-6 * rtb_Product1_b + rtDW.Integ4_g;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S800>/S-Function' incorporates:
   *  Constant: '<S799>/K1'
   */
  /* Level2 S-Function Block: '<S800>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S799>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_p3 = rtb_Product1_b;

  /* Update for UnitDelay: '<S799>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_p = rtb_Switch_a;

  /* Update for DiscreteIntegrator: '<S380>/Integ4' incorporates:
   *  Product: '<Root>/Product'
   */
  rtDW.Integ4_SYSTEM_ENABLE_a = 0U;
  rtDW.Integ4_DSTATE_jc = 2.5E-6 * rtb_phi + rtDW.Integ4_m;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S381>/S-Function' incorporates:
   *  Constant: '<S380>/K1'
   */
  /* Level2 S-Function Block: '<S381>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S380>/Unit Delay' incorporates:
   *  Product: '<Root>/Product'
   */
  rtDW.UnitDelay_DSTATE_bm = rtb_phi;

  /* Update for UnitDelay: '<S380>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m0 = rtb_Switch_o4;

  /* Update for DiscreteIntegrator: '<S382>/Integ4' incorporates:
   *  Product: '<Root>/Product1'
   */
  rtDW.Integ4_SYSTEM_ENABLE_h = 0U;
  rtDW.Integ4_DSTATE_id = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_fr;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S383>/S-Function' incorporates:
   *  Constant: '<S382>/K1'
   */
  /* Level2 S-Function Block: '<S383>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S382>/Unit Delay' incorporates:
   *  Product: '<Root>/Product1'
   */
  rtDW.UnitDelay_DSTATE_cr = rtb_Product1_g_tmp;

  /* Update for UnitDelay: '<S382>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_g = rtb_Switch_e0;

  /* Update for DiscreteIntegrator: '<S384>/Integ4' incorporates:
   *  Product: '<Root>/Product2'
   */
  rtDW.Integ4_SYSTEM_ENABLE_m = 0U;
  rtDW.Integ4_DSTATE_h = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_mt;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S385>/S-Function' incorporates:
   *  Constant: '<S384>/K1'
   */
  /* Level2 S-Function Block: '<S385>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S384>/Unit Delay' incorporates:
   *  Product: '<Root>/Product2'
   */
  rtDW.UnitDelay_DSTATE_m = rtb_Product2_tmp;

  /* Update for UnitDelay: '<S384>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ags = rtb_Switch_mg;

  /* Update for DiscreteIntegrator: '<S386>/Integ4' incorporates:
   *  Product: '<Root>/Product3'
   */
  rtDW.Integ4_SYSTEM_ENABLE_o0 = 0U;
  rtDW.Integ4_DSTATE_oi = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_ge;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S387>/S-Function' incorporates:
   *  Constant: '<S386>/K1'
   */
  /* Level2 S-Function Block: '<S387>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S386>/Unit Delay' incorporates:
   *  Product: '<Root>/Product3'
   */
  rtDW.UnitDelay_DSTATE_ez = rtb_Product3_h_tmp;

  /* Update for UnitDelay: '<S386>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lg = rtb_Switch_i2;

  /* Update for Sin: '<S388>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_m;
  rtDW.lastSin_m = rtDW.lastSin_m * 0.99999822347173384 + rtDW.lastCos_ovt *
    0.0018849544759281136;
  rtDW.lastCos_ovt = rtDW.lastCos_ovt * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S394>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_b = 0U;
  rtDW.Integ4_DSTATE_pg = 2.5E-6 * rtb_Product_f + rtDW.Integ4_lf;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S395>/S-Function' incorporates:
   *  Constant: '<S394>/K1'
   */
  /* Level2 S-Function Block: '<S395>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S394>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_aq = rtb_Product_f;

  /* Update for UnitDelay: '<S394>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jx = rtb_Switch_d;

  /* Update for Sin: '<S388>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fl;
  rtDW.lastSin_fl = rtDW.lastSin_fl * 0.99999822347173384 + rtDW.lastCos_nl *
    0.0018849544759281136;
  rtDW.lastCos_nl = rtDW.lastCos_nl * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S392>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_en = 0U;
  rtDW.Integ4_DSTATE_oi0 = 2.5E-6 * rtb_Product1_eo + rtDW.Integ4_bp;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S393>/S-Function' incorporates:
   *  Constant: '<S392>/K1'
   */
  /* Level2 S-Function Block: '<S393>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S392>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_cn = rtb_Product1_eo;

  /* Update for UnitDelay: '<S392>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_k = rtb_Switch_eo;

  /* Update for Sin: '<S389>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_p;
  rtDW.lastSin_p = rtDW.lastSin_p * 0.99999822347173384 + rtDW.lastCos_fl *
    0.0018849544759281136;
  rtDW.lastCos_fl = rtDW.lastCos_fl * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S400>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a3 = 0U;
  rtDW.Integ4_DSTATE_io = 2.5E-6 * rtb_Product_h4 + rtDW.Integ4_n;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S401>/S-Function' incorporates:
   *  Constant: '<S400>/K1'
   */
  /* Level2 S-Function Block: '<S401>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S400>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_j = rtb_Product_h4;

  /* Update for UnitDelay: '<S400>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lz = rtb_Switch_os;

  /* Update for Sin: '<S389>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_e1;
  rtDW.lastSin_e1 = rtDW.lastSin_e1 * 0.99999822347173384 + rtDW.lastCos_h5 *
    0.0018849544759281136;
  rtDW.lastCos_h5 = rtDW.lastCos_h5 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S398>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kb = 0U;
  rtDW.Integ4_DSTATE_hw = 2.5E-6 * rtb_Product1_d + rtDW.Integ4_o;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S399>/S-Function' incorporates:
   *  Constant: '<S398>/K1'
   */
  /* Level2 S-Function Block: '<S399>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S398>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_hl = rtb_Product1_d;

  /* Update for UnitDelay: '<S398>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_i = rtb_Switch_j;

  /* Update for Sin: '<S454>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_am;
  rtDW.lastSin_am = rtDW.lastSin_am * 0.99999822347173384 + rtDW.lastCos_ny *
    0.0018849544759281136;
  rtDW.lastCos_ny = rtDW.lastCos_ny * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S464>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cl = 0U;
  rtDW.Integ4_DSTATE_nf = 2.5E-6 * rtb_phi_b + rtDW.Integ4_mta;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S465>/S-Function' incorporates:
   *  Constant: '<S464>/K1'
   */
  /* Level2 S-Function Block: '<S465>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S464>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_hw = rtb_phi_b;

  /* Update for UnitDelay: '<S464>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_gx = rtb_Switch_m;

  /* Update for Sin: '<S454>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_jo;
  rtDW.lastSin_jo = rtDW.lastSin_jo * 0.99999822347173384 + rtDW.lastCos_on *
    0.0018849544759281136;
  rtDW.lastCos_on = rtDW.lastCos_on * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S462>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i2 = 0U;
  rtDW.Integ4_DSTATE_j5 = 2.5E-6 * rtb_Product1_jc + rtDW.Integ4_oc;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S463>/S-Function' incorporates:
   *  Constant: '<S462>/K1'
   */
  /* Level2 S-Function Block: '<S463>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S462>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ai = rtb_Product1_jc;

  /* Update for UnitDelay: '<S462>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_d = rtb_Switch_dc;

  /* Update for Sin: '<S455>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_pp;
  rtDW.lastSin_pp = rtDW.lastSin_pp * 0.99999822347173384 + rtDW.lastCos_ob *
    0.0018849544759281136;
  rtDW.lastCos_ob = rtDW.lastCos_ob * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S470>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bc = 0U;
  rtDW.Integ4_DSTATE_a = 2.5E-6 * rtb_Product_aa + rtDW.Integ4_do;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S471>/S-Function' incorporates:
   *  Constant: '<S470>/K1'
   */
  /* Level2 S-Function Block: '<S471>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S470>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_lw = rtb_Product_aa;

  /* Update for UnitDelay: '<S470>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m5 = rtb_Switch_e;

  /* Update for Sin: '<S455>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_i;
  rtDW.lastSin_i = rtDW.lastSin_i * 0.99999822347173384 + rtDW.lastCos_b *
    0.0018849544759281136;
  rtDW.lastCos_b = rtDW.lastCos_b * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S468>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gs = 0U;
  rtDW.Integ4_DSTATE_k = 2.5E-6 * rtb_Product1_j + rtDW.Integ4_nk;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */
  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S468>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ei = rtb_Product1_j;

  /* Update for UnitDelay: '<S468>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_b = rtb_Switch_h;

  /* Update for Sin: '<S456>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_hb;
  rtDW.lastSin_hb = rtDW.lastSin_hb * 0.99999822347173384 + rtDW.lastCos_i4 *
    0.0018849544759281136;
  rtDW.lastCos_i4 = rtDW.lastCos_i4 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S476>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jz = 0U;
  rtDW.Integ4_DSTATE_kd = 2.5E-6 * rtb_Product_p + rtDW.Integ4_pl;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S477>/S-Function' incorporates:
   *  Constant: '<S476>/K1'
   */
  /* Level2 S-Function Block: '<S477>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S476>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_jz = rtb_Product_p;

  /* Update for UnitDelay: '<S476>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_a1 = rtb_Switch_on;

  /* Update for Sin: '<S456>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fw;
  rtDW.lastSin_fw = rtDW.lastSin_fw * 0.99999822347173384 + rtDW.lastCos_p *
    0.0018849544759281136;
  rtDW.lastCos_p = rtDW.lastCos_p * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S474>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bm = 0U;
  rtDW.Integ4_DSTATE_me = 2.5E-6 * rtb_Product1_nw + rtDW.Integ4_nkx;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */
  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S474>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_b2 = rtb_Product1_nw;

  /* Update for UnitDelay: '<S474>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ea = rtb_Switch_cd;

  /* Update for Sin: '<S478>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_dz;
  rtDW.lastSin_dz = rtDW.lastSin_dz * 0.99999822347173384 + rtDW.lastCos_b4 *
    0.0018849544759281136;
  rtDW.lastCos_b4 = rtDW.lastCos_b4 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S488>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ke = 0U;
  rtDW.Integ4_DSTATE_ip = 2.5E-6 * rtb_Product_bo + rtDW.Integ4_mr;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S489>/S-Function' incorporates:
   *  Constant: '<S488>/K1'
   */
  /* Level2 S-Function Block: '<S489>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S488>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_fp = rtb_Product_bo;

  /* Update for UnitDelay: '<S488>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ma = rtb_Switch_l;

  /* Update for Sin: '<S478>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_jd;
  rtDW.lastSin_jd = rtDW.lastSin_jd * 0.99999822347173384 + rtDW.lastCos_ih *
    0.0018849544759281136;
  rtDW.lastCos_ih = rtDW.lastCos_ih * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S486>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oh = 0U;
  rtDW.Integ4_DSTATE_dq = 2.5E-6 * rtb_Product1_ls + rtDW.Integ4_dg;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S487>/S-Function' incorporates:
   *  Constant: '<S486>/K1'
   */
  /* Level2 S-Function Block: '<S487>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S486>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_gf = rtb_Product1_ls;

  /* Update for UnitDelay: '<S486>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_e2 = rtb_Switch_id;

  /* Update for Sin: '<S479>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_n;
  rtDW.lastSin_n = rtDW.lastSin_n * 0.99999822347173384 + rtDW.lastCos_hr *
    0.0018849544759281136;
  rtDW.lastCos_hr = rtDW.lastCos_hr * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S494>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_lx = 0U;
  rtDW.Integ4_DSTATE_le = 2.5E-6 * rtb_Product_i + rtDW.Integ4_e;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */
  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S494>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_d = rtb_Product_i;

  /* Update for UnitDelay: '<S494>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_gb = rtb_Switch_lq;

  /* Update for Sin: '<S479>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_o2;
  rtDW.lastSin_o2 = rtDW.lastSin_o2 * 0.99999822347173384 + rtDW.lastCos_dm *
    0.0018849544759281136;
  rtDW.lastCos_dm = rtDW.lastCos_dm * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S492>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_of = 0U;
  rtDW.Integ4_DSTATE_ox = 2.5E-6 * rtb_Product1_ce + rtDW.Integ4_g4;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */
  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S492>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_hz = rtb_Product1_ce;

  /* Update for UnitDelay: '<S492>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_dz = rtb_Switch_p0;

  /* Update for Sin: '<S480>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_e2;
  rtDW.lastSin_e2 = rtDW.lastSin_e2 * 0.99999822347173384 + rtDW.lastCos_m *
    0.0018849544759281136;
  rtDW.lastCos_m = rtDW.lastCos_m * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S500>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_p = 0U;
  rtDW.Integ4_DSTATE_gb = 2.5E-6 * rtb_Product_lv + rtDW.Integ4_ao;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */
  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S500>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_cm = rtb_Product_lv;

  /* Update for UnitDelay: '<S500>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jz = rtb_Switch_k;

  /* Update for Sin: '<S480>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_dm;
  rtDW.lastSin_dm = rtDW.lastSin_dm * 0.99999822347173384 + rtDW.lastCos_ie *
    0.0018849544759281136;
  rtDW.lastCos_ie = rtDW.lastCos_ie * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S498>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_on = 0U;
  rtDW.Integ4_DSTATE_ia = 2.5E-6 * rtb_Product1_iha + rtDW.Integ4_mk;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */
  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S498>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_lx = rtb_Product1_iha;

  /* Update for UnitDelay: '<S498>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_pq = rtb_Switch_kp;

  /* Update for UnitDelay: '<S5>/Unit Delay2' */
  rtDW.UnitDelay2_DSTATE = rtb_Add;

  /* Update for UnitDelay: '<S71>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_dm = rtb_phi_f;

  /* Update for UnitDelay: '<S238>/Delay_x1' incorporates:
   *  Gain: '<S239>/A11'
   *  Gain: '<S239>/A12'
   *  Sum: '<S238>/A*x1(k) + B*u1(k) '
   *  Sum: '<S239>/sum2'
   *  UnitDelay: '<S238>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_o = (0.99893981644628616 * rtDW.Delay_x1_DSTATE_o +
    4.7724132384231262E-6 * rtDW.Delay_x2_DSTATE_i) + rtb_Fcn1;

  /* Update for UnitDelay: '<S238>/Delay_x2' incorporates:
   *  Sum: '<S238>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_i = rtb_UnitDelay7 + rtb_B21_h;

  /* Update for UnitDelay: '<S5>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE = rtDW.StateSpace_o1[55];

  /* Update for UnitDelay: '<S72>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ok = rtb_UnitDelay5;

  /* Update for UnitDelay: '<S317>/Delay_x1' incorporates:
   *  Gain: '<S318>/A11'
   *  Gain: '<S318>/A12'
   *  Sum: '<S317>/A*x1(k) + B*u1(k) '
   *  Sum: '<S318>/sum2'
   *  UnitDelay: '<S317>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_py = (0.99893981644628616 * rtDW.Delay_x1_DSTATE_py +
    4.7724132384231262E-6 * rtDW.Delay_x2_DSTATE_c) + rtb_B11_h;

  /* Update for UnitDelay: '<S317>/Delay_x2' incorporates:
   *  Sum: '<S317>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_c = rtb_RelationalOperator3_d + rtb_B21_n;

  /* Update for UnitDelay: '<S5>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE = rtb_UnitDelay6;

  /* Update for UnitDelay: '<S5>/Unit Delay7' */
  rtDW.UnitDelay7_DSTATE = rtDW.StateSpace_o1[70];

  /* Update for UnitDelay: '<S5>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0[0] = rtDW.StateSpace_o1[62];

  /* Update for UnitDelay: '<S5>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE[0] = rtDW.StateSpace_o1[59];

  /* Update for UnitDelay: '<S5>/Unit Delay3' */
  rtDW.UnitDelay3_DSTATE[0] = rtDW.StateSpace_o1[42];

  /* Update for UnitDelay: '<S5>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ds[0] = rtDW.StateSpace_o1[48];

  /* Update for UnitDelay: '<S5>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0[1] = rtDW.StateSpace_o1[63];

  /* Update for UnitDelay: '<S5>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE[1] = rtDW.StateSpace_o1[60];

  /* Update for UnitDelay: '<S5>/Unit Delay3' */
  rtDW.UnitDelay3_DSTATE[1] = rtDW.StateSpace_o1[43];

  /* Update for UnitDelay: '<S5>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ds[1] = rtDW.StateSpace_o1[49];

  /* Update for UnitDelay: '<S5>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0[2] = rtDW.StateSpace_o1[64];

  /* Update for UnitDelay: '<S5>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE[2] = rtDW.StateSpace_o1[61];

  /* Update for UnitDelay: '<S5>/Unit Delay3' */
  rtDW.UnitDelay3_DSTATE[2] = rtDW.StateSpace_o1[44];

  /* Update for UnitDelay: '<S5>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ds[2] = rtDW.StateSpace_o1[50];

  /* Update for Sin: '<S5>/Uref1' */
  lastSin_o3_tmp = rtDW.lastSin_b;
  rtDW.lastSin_b = rtDW.lastSin_b * 0.99999822347173384 + rtDW.lastCos_he *
    0.0018849544759281136;
  rtDW.lastCos_he = rtDW.lastCos_he * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for Sin: '<S5>/Uref2' */
  lastSin_o3_tmp = rtDW.lastSin_o3;
  rtDW.lastSin_o3 = rtDW.lastSin_o3 * 0.99999876629970352 + rtDW.lastCos_nyp *
    0.0015707956808308789;
  rtDW.lastCos_nyp = rtDW.lastCos_nyp * 0.99999876629970352 - lastSin_o3_tmp *
    0.0015707956808308789;

  /* Update for DiscreteIntegrator: '<S516>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o3 = 0U;
  rtDW.Integ4_DSTATE_oe = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_c1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */
  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S584>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_g;
  rtDW.lastSin_g = rtDW.lastSin_g * 0.99999822347173384 + rtDW.lastCos_ko *
    0.0018849544759281136;
  rtDW.lastCos_ko = rtDW.lastCos_ko * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S592>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_og = 0U;
  rtDW.Integ4_DSTATE_n5 = 2.5E-6 * rtb_DataTypeConversion1_g + rtDW.Integ4_is;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S593>/S-Function' incorporates:
   *  Constant: '<S592>/K1'
   */
  /* Level2 S-Function Block: '<S593>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S584>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ne;
  rtDW.lastSin_ne = rtDW.lastSin_ne * 0.99999822347173384 + rtDW.lastCos_n3 *
    0.0018849544759281136;
  rtDW.lastCos_n3 = rtDW.lastCos_n3 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S594>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gy = 0U;
  rtDW.Integ4_DSTATE_c = 2.5E-6 * rtb_Uref2 + rtDW.Integ4_np;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S595>/S-Function' incorporates:
   *  Constant: '<S594>/K1'
   */
  /* Level2 S-Function Block: '<S595>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S585>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_am5;
  rtDW.lastSin_am5 = rtDW.lastSin_am5 * 0.99999822347173384 + rtDW.lastCos_gn *
    0.0018849544759281136;
  rtDW.lastCos_gn = rtDW.lastCos_gn * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S598>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nt = 0U;
  rtDW.Integ4_DSTATE_cd = 2.5E-6 * rtb_Block4 + rtDW.Integ4_nw;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */
  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S585>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_on;
  rtDW.lastSin_on = rtDW.lastSin_on * 0.99999822347173384 + rtDW.lastCos_gs *
    0.0018849544759281136;
  rtDW.lastCos_gs = rtDW.lastCos_gs * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S600>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ax = 0U;
  rtDW.Integ4_DSTATE_lz = 2.5E-6 * rtb_Product_od + rtDW.Integ4_pz;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S601>/S-Function' incorporates:
   *  Constant: '<S600>/K1'
   */
  /* Level2 S-Function Block: '<S601>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S586>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_h5;
  rtDW.lastSin_h5 = rtDW.lastSin_h5 * 0.99999822347173384 + rtDW.lastCos_pj *
    0.0018849544759281136;
  rtDW.lastCos_pj = rtDW.lastCos_pj * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S604>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ob = 0U;
  rtDW.Integ4_DSTATE_ne = 2.5E-6 * rtb_Product1_c + rtDW.Integ4_i0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */
  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S586>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_n1;
  rtDW.lastSin_n1 = rtDW.lastSin_n1 * 0.99999822347173384 + rtDW.lastCos_ihc *
    0.0018849544759281136;
  rtDW.lastCos_ihc = rtDW.lastCos_ihc * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S606>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pc = 0U;
  rtDW.Integ4_DSTATE_df = 2.5E-6 * rtb_Product_mv + rtDW.Integ4_j1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S607>/S-Function' incorporates:
   *  Constant: '<S606>/K1'
   */
  /* Level2 S-Function Block: '<S607>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S608>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ds;
  rtDW.lastSin_ds = rtDW.lastSin_ds * 0.99999822347173384 + rtDW.lastCos_k2 *
    0.0018849544759281136;
  rtDW.lastCos_k2 = rtDW.lastCos_k2 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S616>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ka = 0U;
  rtDW.Integ4_DSTATE_am = 2.5E-6 * rtb_Product1_it + rtDW.Integ4_di;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S617>/S-Function' incorporates:
   *  Constant: '<S616>/K1'
   */
  /* Level2 S-Function Block: '<S617>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S608>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ft;
  rtDW.lastSin_ft = rtDW.lastSin_ft * 0.99999822347173384 + rtDW.lastCos_le *
    0.0018849544759281136;
  rtDW.lastCos_le = rtDW.lastCos_le * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S618>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ft = 0U;
  rtDW.Integ4_DSTATE_ct = 2.5E-6 * rtb_Product_db + rtDW.Integ4_dd;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S619>/S-Function' incorporates:
   *  Constant: '<S618>/K1'
   */
  /* Level2 S-Function Block: '<S619>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S609>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ik;
  rtDW.lastSin_ik = rtDW.lastSin_ik * 0.99999822347173384 + rtDW.lastCos_gx *
    0.0018849544759281136;
  rtDW.lastCos_gx = rtDW.lastCos_gx * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S622>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_js = 0U;
  rtDW.Integ4_DSTATE_dn = 2.5E-6 * rtb_Product1_pv + rtDW.Integ4_a3;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */
  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S609>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_gg;
  rtDW.lastSin_gg = rtDW.lastSin_gg * 0.99999822347173384 + rtDW.lastCos_kz *
    0.0018849544759281136;
  rtDW.lastCos_kz = rtDW.lastCos_kz * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S624>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jw = 0U;
  rtDW.Integ4_DSTATE_f = 2.5E-6 * rtb_Product_cki + rtDW.Integ4_lc;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */
  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S610>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_c;
  rtDW.lastSin_c = rtDW.lastSin_c * 0.99999822347173384 + rtDW.lastCos_a5 *
    0.0018849544759281136;
  rtDW.lastCos_a5 = rtDW.lastCos_a5 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S628>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h5 = 0U;
  rtDW.Integ4_DSTATE_fv = 2.5E-6 * rtb_Product1_e + rtDW.Integ4_hp;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */
  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S610>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_mp;
  rtDW.lastSin_mp = rtDW.lastSin_mp * 0.99999822347173384 + rtDW.lastCos_pe *
    0.0018849544759281136;
  rtDW.lastCos_pe = rtDW.lastCos_pe * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S630>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k5 = 0U;
  rtDW.Integ4_DSTATE_ex = 2.5E-6 * rtb_Product_jn + rtDW.Integ4_ce;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */
  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S518>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_nh;
  rtDW.lastSin_nh = rtDW.lastSin_nh * 0.99999822347173384 + rtDW.lastCos_kw *
    0.0018849544759281136;
  rtDW.lastCos_kw = rtDW.lastCos_kw * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S522>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bj = 0U;
  rtDW.Integ4_DSTATE_nc = 2.5E-6 * rtb_Product1_i + rtDW.Integ4_mu;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */
  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S518>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_mi;
  rtDW.lastSin_mi = rtDW.lastSin_mi * 0.99999822347173384 + rtDW.lastCos_bb *
    0.0018849544759281136;
  rtDW.lastCos_bb = rtDW.lastCos_bb * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S524>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ba = 0U;
  rtDW.Integ4_DSTATE_nd = 2.5E-6 * rtb_Product_ae + rtDW.Integ4_ddm;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */
  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S519>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_et;
  rtDW.lastSin_et = rtDW.lastSin_et * 0.99999822347173384 + rtDW.lastCos_ju *
    0.0018849544759281136;
  rtDW.lastCos_ju = rtDW.lastCos_ju * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S528>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gl = 0U;
  rtDW.Integ4_DSTATE_li = 2.5E-6 * rtb_Product1_dr + rtDW.Integ4_m1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */
  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S519>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ac;
  rtDW.lastSin_ac = rtDW.lastSin_ac * 0.99999822347173384 + rtDW.lastCos_bd *
    0.0018849544759281136;
  rtDW.lastCos_bd = rtDW.lastCos_bd * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S530>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fs = 0U;
  rtDW.Integ4_DSTATE_j5d = 2.5E-6 * rtb_Product_d + rtDW.Integ4_nr;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */
  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S534>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_at;
  rtDW.lastSin_at = rtDW.lastSin_at * 0.99999822347173384 + rtDW.lastCos_ci *
    0.0018849544759281136;
  rtDW.lastCos_ci = rtDW.lastCos_ci * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S542>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cm = 0U;
  rtDW.Integ4_DSTATE_av = 2.5E-6 * rtb_Product1_co + rtDW.Integ4_ab;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */
  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S534>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_la;
  rtDW.lastSin_la = rtDW.lastSin_la * 0.99999822347173384 + rtDW.lastCos_bbd *
    0.0018849544759281136;
  rtDW.lastCos_bbd = rtDW.lastCos_bbd * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S544>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cc = 0U;
  rtDW.Integ4_DSTATE_leb = 2.5E-6 * rtb_Product_p5i + rtDW.Integ4_cc;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */
  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S535>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_gh;
  rtDW.lastSin_gh = rtDW.lastSin_gh * 0.99999822347173384 + rtDW.lastCos_lz *
    0.0018849544759281136;
  rtDW.lastCos_lz = rtDW.lastCos_lz * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S548>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ix = 0U;
  rtDW.Integ4_DSTATE_b = 2.5E-6 * rtb_Product1_o + rtDW.Integ4_m3;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S549>/S-Function' incorporates:
   *  Constant: '<S548>/K1'
   */
  /* Level2 S-Function Block: '<S549>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S535>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_lo;
  rtDW.lastSin_lo = rtDW.lastSin_lo * 0.99999822347173384 + rtDW.lastCos_gsk *
    0.0018849544759281136;
  rtDW.lastCos_gsk = rtDW.lastCos_gsk * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S550>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jo = 0U;
  rtDW.Integ4_DSTATE_e5 = 2.5E-6 * rtb_Product_d3 + rtDW.Integ4_ocz;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S551>/S-Function' incorporates:
   *  Constant: '<S550>/K1'
   */
  /* Level2 S-Function Block: '<S551>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S536>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fa;
  rtDW.lastSin_fa = rtDW.lastSin_fa * 0.99999822347173384 + rtDW.lastCos_hf *
    0.0018849544759281136;
  rtDW.lastCos_hf = rtDW.lastCos_hf * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S554>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bu = 0U;
  rtDW.Integ4_DSTATE_eb = 2.5E-6 * rtb_Product1_dtt + rtDW.Integ4_frw;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */
  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S536>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_lk;
  rtDW.lastSin_lk = rtDW.lastSin_lk * 0.99999822347173384 + rtDW.lastCos_ig *
    0.0018849544759281136;
  rtDW.lastCos_ig = rtDW.lastCos_ig * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S556>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i0 = 0U;
  rtDW.Integ4_DSTATE_cq = 2.5E-6 * rtb_Product_m + rtDW.Integ4_ah;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S557>/S-Function' incorporates:
   *  Constant: '<S556>/K1'
   */
  /* Level2 S-Function Block: '<S557>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S558>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_gh2;
  rtDW.lastSin_gh2 = rtDW.lastSin_gh2 * 0.99999822347173384 + rtDW.lastCos_ew *
    0.0018849544759281136;
  rtDW.lastCos_ew = rtDW.lastCos_ew * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S566>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_af = 0U;
  rtDW.Integ4_DSTATE_hc = 2.5E-6 * rtb_Product1_kv + rtDW.Integ4_jz;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S567>/S-Function' incorporates:
   *  Constant: '<S566>/K1'
   */
  /* Level2 S-Function Block: '<S567>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S558>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_nr;
  rtDW.lastSin_nr = rtDW.lastSin_nr * 0.99999822347173384 + rtDW.lastCos_op *
    0.0018849544759281136;
  rtDW.lastCos_op = rtDW.lastCos_op * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S568>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ks = 0U;
  rtDW.Integ4_DSTATE_m3 = 2.5E-6 * rtb_Product_k + rtDW.Integ4_oe;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S569>/S-Function' incorporates:
   *  Constant: '<S568>/K1'
   */
  /* Level2 S-Function Block: '<S569>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S559>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_fxm;
  rtDW.lastSin_fxm = rtDW.lastSin_fxm * 0.99999822347173384 + rtDW.lastCos_h0 *
    0.0018849544759281136;
  rtDW.lastCos_h0 = rtDW.lastCos_h0 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S572>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fu = 0U;
  rtDW.Integ4_DSTATE_bo = 2.5E-6 * rtb_Product1_f + rtDW.Integ4_ea;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */
  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S559>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_o2f;
  rtDW.lastSin_o2f = rtDW.lastSin_o2f * 0.99999822347173384 + rtDW.lastCos_niz *
    0.0018849544759281136;
  rtDW.lastCos_niz = rtDW.lastCos_niz * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S574>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ns = 0U;
  rtDW.Integ4_DSTATE_jx = 2.5E-6 * rtb_Product_a + rtDW.Integ4_no;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */
  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S560>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_p0;
  rtDW.lastSin_p0 = rtDW.lastSin_p0 * 0.99999822347173384 + rtDW.lastCos_fu *
    0.0018849544759281136;
  rtDW.lastCos_fu = rtDW.lastCos_fu * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S578>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_or = 0U;
  rtDW.Integ4_DSTATE_g5 = 2.5E-6 * rtb_Product1_a + rtDW.Integ4_ex;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */
  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S560>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_nx;
  rtDW.lastSin_nx = rtDW.lastSin_nx * 0.99999822347173384 + rtDW.lastCos_ez *
    0.0018849544759281136;
  rtDW.lastCos_ez = rtDW.lastCos_ez * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S580>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a0 = 0U;
  rtDW.Integ4_DSTATE_my = 2.5E-6 * rtb_Product_jv + rtDW.Integ4_ij;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */
  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S632>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_eb;
  rtDW.lastSin_eb = rtDW.lastSin_eb * 0.99999822347173384 + rtDW.lastCos_h2 *
    0.0018849544759281136;
  rtDW.lastCos_h2 = rtDW.lastCos_h2 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S640>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ic = 0U;
  rtDW.Integ4_DSTATE_pv = 2.5E-6 * rtb_Product1_n + rtDW.Integ4_fg;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S641>/S-Function' incorporates:
   *  Constant: '<S640>/K1'
   */
  /* Level2 S-Function Block: '<S641>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S632>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_pc;
  rtDW.lastSin_pc = rtDW.lastSin_pc * 0.99999822347173384 + rtDW.lastCos_fuy *
    0.0018849544759281136;
  rtDW.lastCos_fuy = rtDW.lastCos_fuy * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S642>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bz = 0U;
  rtDW.Integ4_DSTATE_ij = 2.5E-6 * rtb_Product_kb + rtDW.Integ4_kv;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S643>/S-Function' incorporates:
   *  Constant: '<S642>/K1'
   */
  /* Level2 S-Function Block: '<S643>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S633>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_ae;
  rtDW.lastSin_ae = rtDW.lastSin_ae * 0.99999822347173384 + rtDW.lastCos_kf *
    0.0018849544759281136;
  rtDW.lastCos_kf = rtDW.lastCos_kf * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S646>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ds = 0U;
  rtDW.Integ4_DSTATE_n2 = 2.5E-6 * rtb_Product1_fb + rtDW.Integ4_ks;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */
  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S633>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_mk;
  rtDW.lastSin_mk = rtDW.lastSin_mk * 0.99999822347173384 + rtDW.lastCos_pk *
    0.0018849544759281136;
  rtDW.lastCos_pk = rtDW.lastCos_pk * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S648>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ow = 0U;
  rtDW.Integ4_DSTATE_dy = 2.5E-6 * rtb_Product_pg + rtDW.Integ4_dl;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */
  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S634>/cos(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_pu;
  rtDW.lastSin_pu = rtDW.lastSin_pu * 0.99999822347173384 + rtDW.lastCos_bdo *
    0.0018849544759281136;
  rtDW.lastCos_bdo = rtDW.lastCos_bdo * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S652>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i1 = 0U;
  rtDW.Integ4_DSTATE_hd = 2.5E-6 * rtb_Product1_cs + rtDW.Integ4_kd;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */
  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S634>/sin(wt)' */
  lastSin_o3_tmp = rtDW.lastSin_cp;
  rtDW.lastSin_cp = rtDW.lastSin_cp * 0.99999822347173384 + rtDW.lastCos_k1 *
    0.0018849544759281136;
  rtDW.lastCos_k1 = rtDW.lastCos_k1 * 0.99999822347173384 - lastSin_o3_tmp *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S654>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oo = 0U;
  rtDW.Integ4_DSTATE_pa = 2.5E-6 * rtb_Product_pk + rtDW.Integ4_id;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */
  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S514>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_co = 0U;
  rtDW.Integ4_DSTATE_px = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_ddl;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S515>/S-Function' incorporates:
   *  Constant: '<S514>/K1'
   */
  /* Level2 S-Function Block: '<S515>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S510>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pb = 0U;
  rtDW.Integ4_DSTATE_exz = 2.5E-6 * rtb_phi + rtDW.Integ4_pt;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S511>/S-Function' incorporates:
   *  Constant: '<S510>/K1'
   */
  /* Level2 S-Function Block: '<S511>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S512>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bzw = 0U;
  rtDW.Integ4_DSTATE_hs = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_pf;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S513>/S-Function' incorporates:
   *  Constant: '<S512>/K1'
   */
  /* Level2 S-Function Block: '<S513>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update absolute time */
  /* The "clockTick0" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick0"
   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick0 and the high bits
   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++rtM->Timing.clockTick0)) {
    ++rtM->Timing.clockTickH0;
  }

  rtM->Timing.t[0] = rtM->Timing.clockTick0 * rtM->Timing.stepSize0 +
    rtM->Timing.clockTickH0 * rtM->Timing.stepSize0 * 4294967296.0;
}

/* Model step function for TID1 */
void power_converters_switching_devices_step1(void) /* Sample time: [5.0E-5s, 0.0s] */
{
  real_T rtb_Gain_o3;
  real_T rtb_Product2_ft;
  real_T rtb_Gain1[3];
  boolean_T rtb_RelationalOperator_dk;
  real_T rtb_Gain_eb;
  real_T rtb_Add3_d;
  boolean_T rtb_RelationalOperator_hg;
  real_T tmp;
  real_T rtb_ComplextoRealImag_o2;
  real_T rtb_DigitalClock;
  real_T rtb_DiscreteTimeIntegrator_k;
  real_T rtb_RateLimiter;
  real_T rtb_Saturation1;
  real_T rtb_sum3;
  real_T rtb_Saturation2;
  real_T rtb_Switch_i;
  real_T rtb_RoundingFunction_l;
  real_T rtb_RoundingFunction_k;
  real_T Initial;
  real_T Initial_a;
  real_T Divide_e;
  int32_T i;
  real_T rtb_yk_h_idx_1;
  real_T rtb_yk_h_idx_0;
  real_T rtb_sum3_h_idx_1;
  real_T rtb_sum3_h_idx_0;
  real_T rtb_sum3_hq_idx_1;
  real_T rtb_yk_m_idx_0;
  real_T rtb_sum3_hq_idx_0;
  real_T rtb_RealImagtoComplex_re;
  real_T rtb_RealImagtoComplex_im;

  /* Gain: '<S185>/Gain' incorporates:
   *  Constant: '<S71>/Vdc_ref_3L'
   *  RateTransition: '<S71>/Rate Transition5'
   *  Sum: '<S185>/Sum'
   */
  rtb_Gain_o3 = (rtDW.RateTransition5_Buffer - 1000.0) * 0.001;

  /* Sum: '<S242>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S242>/Discrete-Time Integrator'
   *  Gain: '<S242>/Kp4'
   */
  rtb_Product2_ft = 2.5 * rtb_Gain_o3 + rtDW.DiscreteTimeIntegrator_DSTATE_i;

  /* Saturate: '<S242>/Saturation2' */
  if (rtb_Product2_ft > 1.5) {
    rtb_Product2_ft = 1.5;
  } else {
    if (rtb_Product2_ft < -1.5) {
      rtb_Product2_ft = -1.5;
    }
  }

  /* End of Saturate: '<S242>/Saturation2' */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S244>/Gain1' incorporates:
     *  Gain: '<S244>/Gain3'
     *  Gain: '<S71>/I->pu2'
     *  RateTransition: '<S71>/Rate Transition6'
     */
    rtb_Gain1[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (0.030618621784789721 * rtDW.RateTransition6_Buffer[2]) +
      (rtConstP.pooled30[i + 3] * (0.030618621784789721 *
      rtDW.RateTransition6_Buffer[1]) + 0.030618621784789721 *
       rtDW.RateTransition6_Buffer[0] * rtConstP.pooled30[i]));
  }

  /* RelationalOperator: '<S193>/Relational Operator' incorporates:
   *  Constant: '<S193>/Constant4'
   */
  rtb_RelationalOperator_dk = (rtDW.DiscreteTimeIntegrator_DSTATE_c >
    6.2831853071795862);

  /* InitialCondition: '<S193>/Initial' incorporates:
   *  Constant: '<S193>/Constant4'
   *  Sum: '<S193>/Subtract'
   */
  if (rtDW.Initial_FirstOutputTime) {
    rtDW.Initial_FirstOutputTime = false;
    Initial = 0.0;
  } else {
    Initial = rtDW.DiscreteTimeIntegrator_DSTATE_c - 6.2831853071795862;
  }

  /* End of InitialCondition: '<S193>/Initial' */

  /* DiscreteIntegrator: '<S193>/Discrete-Time Integrator' */
  if (rtb_RelationalOperator_dk && (rtDW.DiscreteTimeIntegrator_PrevRese <= 0))
  {
    rtDW.DiscreteTimeIntegrator_DSTATE_c = Initial;
  }

  /* Update for RateTransition: '<S71>/Rate Transition4' incorporates:
   *  DiscreteIntegrator: '<S193>/Discrete-Time Integrator'
   */
  rtDW.RateTransition4_Buffer0_o = rtDW.DiscreteTimeIntegrator_DSTATE_c;

  /* Outputs for Enabled SubSystem: '<S243>/Subsystem1' */
  /* DiscreteIntegrator: '<S193>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_c,
             &rtDW.Fcn_g3, &rtDW.Fcn1_gm);

  /* End of Outputs for SubSystem: '<S243>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S243>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_p, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_jl,
                    &rtDW.Fcn1_on);

  /* End of Outputs for SubSystem: '<S243>/Subsystem - pi//2 delay' */

  /* Sum: '<S234>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S234>/D*u(k)'
   *  Gain: '<S237>/C11'
   *  Gain: '<S237>/C12'
   *  Sum: '<S237>/sum2'
   *  Switch: '<S243>/Switch'
   *  UnitDelay: '<S234>/Delay_x1'
   *  UnitDelay: '<S234>/Delay_x2'
   */
  rtb_yk_m_idx_0 = (4438.1999107119682 * rtDW.Delay_x1_DSTATE[0] +
                    0.074961614832529166 * rtDW.Delay_x2_DSTATE[0]) +
    0.037480807416264583 * rtDW.Fcn_jl;
  Initial = (4438.1999107119682 * rtDW.Delay_x1_DSTATE[1] + 0.074961614832529166
             * rtDW.Delay_x2_DSTATE[1]) + 0.037480807416264583 * rtDW.Fcn1_on;

  /* Outport: '<Root>/Out11' */
  //rtY.3LId[0] = rtb_Product2_ft;
  //rtY.3LId[1] = rtb_yk_m_idx_0;
  rtY._3LId[0] = rtb_Product2_ft;
  rtY._3LId[1] = rtb_yk_m_idx_0;

  /* Outport: '<Root>/Out12' */
  //rtY.3LIq = Initial;
  rtY._3LIq = Initial;

  /* Outport: '<Root>/Out13' incorporates:
   *  Math: '<S71>/Math Function'
   *  RateTransition: '<S71>/Rate Transition1'
   */
  //rtY.3Lm = rt_hypotd_snf(rtDW.RateTransition1_Buffer[0],
  //  rtDW.RateTransition1_Buffer[1]);
  rtY._3Lm = rt_hypotd_snf(rtDW.RateTransition1_Buffer[0],
    rtDW.RateTransition1_Buffer[1]);

  /* Gain: '<S261>/Gain' incorporates:
   *  Constant: '<S72>/Vdc_ref_stat'
   *  RateTransition: '<S72>/Rate Transition5'
   *  Sum: '<S261>/Sum'
   */
  rtb_Gain_eb = (rtDW.RateTransition5_Buffer_a - 2400.0) *
    0.00041666666666666669;

  /* Sum: '<S321>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S321>/Discrete-Time Integrator'
   *  Gain: '<S321>/Kp4'
   */
  rtb_Add3_d = 10.0 * rtb_Gain_eb + rtDW.DiscreteTimeIntegrator_DSTATE_j;

  /* Saturate: '<S321>/Saturation2' */
  if (rtb_Add3_d > 1.5) {
    rtb_Add3_d = 1.5;
  } else {
    if (rtb_Add3_d < -1.5) {
      rtb_Add3_d = -1.5;
    }
  }

  /* End of Saturate: '<S321>/Saturation2' */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S323>/Gain1' incorporates:
     *  Gain: '<S323>/Gain3'
     *  Gain: '<S72>/I->pu2'
     *  RateTransition: '<S72>/Rate Transition6'
     */
    rtb_Gain1[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (0.015309310892394861 * rtDW.RateTransition6_Buffer_d[2]) +
      (rtConstP.pooled30[i + 3] * (0.015309310892394861 *
      rtDW.RateTransition6_Buffer_d[1]) + 0.015309310892394861 *
       rtDW.RateTransition6_Buffer_d[0] * rtConstP.pooled30[i]));
  }

  /* RelationalOperator: '<S272>/Relational Operator' incorporates:
   *  Constant: '<S272>/Constant4'
   */
  rtb_RelationalOperator_hg = (rtDW.DiscreteTimeIntegrator_DSTATE_o >
    6.2831853071795862);

  /* InitialCondition: '<S272>/Initial' incorporates:
   *  Constant: '<S272>/Constant4'
   *  Sum: '<S272>/Subtract'
   */
  if (rtDW.Initial_FirstOutputTime_m) {
    rtDW.Initial_FirstOutputTime_m = false;
    Initial_a = 0.0;
  } else {
    Initial_a = rtDW.DiscreteTimeIntegrator_DSTATE_o - 6.2831853071795862;
  }

  /* End of InitialCondition: '<S272>/Initial' */

  /* DiscreteIntegrator: '<S272>/Discrete-Time Integrator' */
  if (rtb_RelationalOperator_hg && (rtDW.DiscreteTimeIntegrator_PrevRe_g <= 0))
  {
    rtDW.DiscreteTimeIntegrator_DSTATE_o = Initial_a;
  }

  /* Update for RateTransition: '<S72>/Rate Transition4' incorporates:
   *  DiscreteIntegrator: '<S272>/Discrete-Time Integrator'
   */
  rtDW.RateTransition4_Buffer0 = rtDW.DiscreteTimeIntegrator_DSTATE_o;

  /* Outputs for Enabled SubSystem: '<S322>/Subsystem1' */
  /* DiscreteIntegrator: '<S272>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_j,
             &rtDW.Fcn1_i);

  /* End of Outputs for SubSystem: '<S322>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S322>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_n, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_d,
                    &rtDW.Fcn1_j);

  /* End of Outputs for SubSystem: '<S322>/Subsystem - pi//2 delay' */

  /* Sum: '<S313>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S313>/D*u(k)'
   *  Gain: '<S316>/C11'
   *  Gain: '<S316>/C12'
   *  Sum: '<S316>/sum2'
   *  Switch: '<S322>/Switch'
   *  UnitDelay: '<S313>/Delay_x1'
   *  UnitDelay: '<S313>/Delay_x2'
   */
  rtb_yk_h_idx_0 = (4438.1999107119682 * rtDW.Delay_x1_DSTATE_p[0] +
                    0.074961614832529166 * rtDW.Delay_x2_DSTATE_d[0]) +
    0.037480807416264583 * rtDW.Fcn_d;
  rtb_yk_h_idx_1 = (4438.1999107119682 * rtDW.Delay_x1_DSTATE_p[1] +
                    0.074961614832529166 * rtDW.Delay_x2_DSTATE_d[1]) +
    0.037480807416264583 * rtDW.Fcn1_j;

  /* Outport: '<Root>/Out26' */
  rtY.statId[0] = rtb_Add3_d;
  rtY.statId[1] = rtb_yk_h_idx_0;

  /* Outputs for Enabled SubSystem: '<S193>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S194>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S272>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S273>/Enable'
   */
  /* Step: '<Root>/Statcom Qref (var)' incorporates:
   *  DigitalClock: '<S203>/Digital  Clock'
   *  DigitalClock: '<S206>/Digital  Clock'
   *  DigitalClock: '<S219>/Digital  Clock'
   *  DigitalClock: '<S268>/Digital  Clock'
   *  DigitalClock: '<S282>/Digital  Clock'
   *  DigitalClock: '<S285>/Digital  Clock'
   *  DigitalClock: '<S298>/Digital  Clock'
   *  Step: '<Root>/wref_motor'
   */
  Divide_e = rtM->Timing.t[1];

  /* End of Outputs for SubSystem: '<S272>/Automatic Gain Control' */
  /* End of Outputs for SubSystem: '<S193>/Automatic Gain Control' */
  if (Divide_e < 0.6) {
    i = -1000000;
  } else {
    i = 1500000;
  }

  /* End of Step: '<Root>/Statcom Qref (var)' */

  /* Gain: '<S72>/Mvar->pu' */
  Initial_a = 5.0E-7 * (real_T)i;

  /* RateLimiter: '<S256>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = Initial_a - rtDW.PrevY;
  if (rtb_DiscreteTimeIntegrator_k > 0.006) {
    Initial_a = rtDW.PrevY + 0.006;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.006) {
      Initial_a = rtDW.PrevY + -0.006;
    }
  }

  rtDW.PrevY = Initial_a;

  /* End of RateLimiter: '<S256>/Rate Limiter' */

  /* Fcn: '<S256>/Mag_V ' incorporates:
   *  Switch: '<S322>/Switch'
   */
  tmp = rtDW.Fcn_d * rtDW.Fcn_d + rtDW.Fcn1_j * rtDW.Fcn1_j;
  if (tmp < 0.0) {
    tmp = -sqrt(-tmp);
  } else {
    tmp = sqrt(tmp);
  }

  /* DiscreteIntegrator: '<S268>/Integ4' incorporates:
   *  Fcn: '<S256>/Mag_V '
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ei != 0) {
    rtDW.Integ4_j0 = rtDW.Integ4_DSTATE_gg;
  } else {
    rtDW.Integ4_j0 = 2.5E-5 * tmp + rtDW.Integ4_DSTATE_gg;
  }

  /* End of DiscreteIntegrator: '<S268>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S269>/S-Function' incorporates:
   *  Constant: '<S268>/K1'
   */

  /* Level2 S-Function Block: '<S269>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S268>/Switch' incorporates:
   *  Constant: '<S268>/K1'
   *  Constant: '<S268>/K2'
   *  Fcn: '<S256>/Mag_V '
   *  Gain: '<S268>/Gain'
   *  Gain: '<S268>/Gain1'
   *  Product: '<S268>/Product'
   *  RelationalOperator: '<S268>/Relational Operator'
   *  Sum: '<S268>/Sum1'
   *  Sum: '<S268>/Sum5'
   *  Sum: '<S268>/Sum7'
   *  UnitDelay: '<S268>/Unit Delay'
   *  UnitDelay: '<S268>/Unit Delay1'
   */
  if (Divide_e >= 0.0167) {
    rtb_Switch_i = (rtDW.Integ4_j0 - rtDW.SFunction_m) * 60.0 +
      (-0.0013333333333333522 * tmp - 0.00066666666666670459 *
       rtDW.UnitDelay_DSTATE_pj);
  } else {
    rtb_Switch_i = rtDW.UnitDelay1_DSTATE_ai;
  }

  /* End of Switch: '<S268>/Switch' */

  /* Saturate: '<S256>/Saturation' */
  if (rtb_Switch_i <= 2.2204460492503131E-16) {
    rtb_DigitalClock = 2.2204460492503131E-16;
  } else {
    rtb_DigitalClock = rtb_Switch_i;
  }

  /* End of Saturate: '<S256>/Saturation' */

  /* Gain: '<S256>/Deg->Rad1' incorporates:
   *  Product: '<S256>/Product'
   */
  rtb_ComplextoRealImag_o2 = -(Initial_a / rtb_DigitalClock);

  /* Saturate: '<S256>/-1<Iq<+1' */
  if (rtb_ComplextoRealImag_o2 > 1.0) {
    rtb_ComplextoRealImag_o2 = 1.0;
  } else {
    if (rtb_ComplextoRealImag_o2 < -1.0) {
      rtb_ComplextoRealImag_o2 = -1.0;
    }
  }

  /* End of Saturate: '<S256>/-1<Iq<+1' */

  /* Outport: '<Root>/Out27' */
  rtY.statIq[0] = rtb_ComplextoRealImag_o2;
  rtY.statIq[1] = rtb_yk_h_idx_1;

  /* Outport: '<Root>/Out28' incorporates:
   *  Math: '<S72>/Math Function'
   *  RateTransition: '<S72>/Rate Transition1'
   */
  rtY.statm = rt_hypotd_snf(rtDW.RateTransition1_Buffer_n[0],
    rtDW.RateTransition1_Buffer_n[1]);

  /* Step: '<Root>/wref_motor' */
  if (Divide_e < 0.5) {
    Initial_a = 1200.0;
  } else {
    Initial_a = 800.0;
  }

  /* RateLimiter: '<S63>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = Initial_a - rtDW.PrevY_k;
  if (rtb_DiscreteTimeIntegrator_k > 0.1) {
    Initial_a = rtDW.PrevY_k + 0.1;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.1) {
      Initial_a = rtDW.PrevY_k + -0.1;
    }
  }

  rtDW.PrevY_k = Initial_a;

  /* End of RateLimiter: '<S63>/Rate Limiter' */

  /* Sum: '<S63>/Sum7' incorporates:
   *  RateTransition: '<S63>/Rate Transition1'
   */
  Initial_a -= rtDW.RateTransition1_Buffer_b;

  /* Sum: '<S74>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S74>/Discrete-Time Integrator'
   *  Gain: '<S74>/Kp4'
   */
  rtb_DigitalClock = 15.0 * Initial_a + rtDW.DiscreteTimeIntegrator_DSTAT_oe;

  /* Saturate: '<S74>/Saturation2' */
  if (rtb_DigitalClock > 1000.0) {
    rtb_DigitalClock = 1000.0;
  } else {
    if (rtb_DigitalClock < -1000.0) {
      rtb_DigitalClock = -1000.0;
    }
  }

  /* End of Saturate: '<S74>/Saturation2' */

  /* RateLimiter: '<S63>/Rate Limiter1' */
  rtb_DiscreteTimeIntegrator_k = rtb_DigitalClock - rtDW.PrevY_n;
  if (rtb_DiscreteTimeIntegrator_k > 1.0) {
    rtb_DigitalClock = rtDW.PrevY_n + 1.0;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -1.0) {
      rtb_DigitalClock = rtDW.PrevY_n + -1.0;
    }
  }

  rtDW.PrevY_n = rtb_DigitalClock;

  /* End of RateLimiter: '<S63>/Rate Limiter1' */

  /* Outport: '<Root>/Out34' incorporates:
   *  RateTransition: '<Root>/Rate Transition1'
   */
  rtY.Imotor[0] = rtb_DigitalClock;
  rtY.Imotor[1] = rtDW.RateTransition1_Buffer_p;

  /* Outport: '<Root>/Out35' incorporates:
   *  RateTransition: '<Root>/Rate Transition2'
   */
  rtY.D_motor = rtDW.RateTransition2_Buffer;

  /* Outputs for Enabled SubSystem: '<S272>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S273>/Enable'
   */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S308>/Gain1' incorporates:
     *  Gain: '<S257>/V->pu1'
     *  Gain: '<S289>/Gain1'
     *  Gain: '<S302>/Gain1'
     *  Gain: '<S308>/Gain3'
     *  RateTransition: '<S72>/Rate Transition2'
     */
    rtb_Gain1[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (4.8989794855663556E-5 * rtDW.RateTransition2_Buffer_g[2]) +
      (rtConstP.pooled30[i + 3] * (4.8989794855663556E-5 *
      rtDW.RateTransition2_Buffer_g[1]) + 4.8989794855663556E-5 *
       rtDW.RateTransition2_Buffer_g[0] * rtConstP.pooled30[i]));
  }

  /* End of Outputs for SubSystem: '<S272>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S307>/Subsystem1' */
  /* Gain: '<S308>/Gain1' incorporates:
   *  DiscreteIntegrator: '<S272>/Discrete-Time Integrator'
   */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_m,
             &rtDW.Fcn1_k);

  /* End of Outputs for SubSystem: '<S307>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S307>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_g, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_g,
                    &rtDW.Fcn1_c);

  /* End of Outputs for SubSystem: '<S307>/Subsystem - pi//2 delay' */

  /* Sum: '<S255>/Sum' */
  rtb_DiscreteTimeIntegrator_k = rtb_Add3_d - rtb_yk_h_idx_0;

  /* Gain: '<S255>/Rtot_pu3' incorporates:
   *  UnitDelay: '<S272>/Unit Delay'
   */
  rtb_RateLimiter = 0.016666666666666666 * rtDW.UnitDelay_DSTATE_cn4;

  /* Sum: '<S265>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S265>/Discrete-Time Integrator'
   *  Gain: '<S265>/Kp4'
   */
  rtb_RealImagtoComplex_re = 0.35 * rtb_DiscreteTimeIntegrator_k +
    rtDW.DiscreteTimeIntegrator_DSTAT_ju;

  /* Saturate: '<S265>/Saturation2' */
  if (rtb_RealImagtoComplex_re > 1.5) {
    rtb_RealImagtoComplex_re = 1.5;
  } else {
    if (rtb_RealImagtoComplex_re < -1.5) {
      rtb_RealImagtoComplex_re = -1.5;
    }
  }

  /* End of Saturate: '<S265>/Saturation2' */

  /* Sum: '<S255>/Add1' incorporates:
   *  Constant: '<S255>/Constant2'
   *  Gain: '<S255>/Gain'
   *  Product: '<S255>/Product1'
   *  Switch: '<S307>/Switch'
   */
  rtb_yk_h_idx_0 = ((rtDW.Fcn_g + rtb_RealImagtoComplex_re) +
                    0.0031999999999999997 * rtb_Add3_d) -
    rtb_ComplextoRealImag_o2 * 0.18 * rtb_RateLimiter;

  /* Sum: '<S255>/Sum1' */
  rtb_yk_h_idx_1 = rtb_ComplextoRealImag_o2 - rtb_yk_h_idx_1;

  /* Gain: '<S255>/Gain1' */
  rtb_ComplextoRealImag_o2 *= 0.0031999999999999997;

  /* Product: '<S255>/Product2' incorporates:
   *  Constant: '<S255>/Constant1'
   */
  rtb_Add3_d = rtb_Add3_d * 0.18 * rtb_RateLimiter;

  /* Sum: '<S266>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S266>/Discrete-Time Integrator'
   *  Gain: '<S266>/Kp4'
   */
  rtb_RealImagtoComplex_re = 0.35 * rtb_yk_h_idx_1 +
    rtDW.DiscreteTimeIntegrator_DSTATE_k;

  /* Saturate: '<S266>/Saturation2' */
  if (rtb_RealImagtoComplex_re > 1.5) {
    rtb_RealImagtoComplex_re = 1.5;
  } else {
    if (rtb_RealImagtoComplex_re < -1.5) {
      rtb_RealImagtoComplex_re = -1.5;
    }
  }

  /* End of Saturate: '<S266>/Saturation2' */

  /* RealImagToComplex: '<S264>/Real-Imag to Complex' incorporates:
   *  Sum: '<S255>/Add3'
   *  Switch: '<S307>/Switch'
   */
  rtb_RealImagtoComplex_im = ((rtDW.Fcn1_c + rtb_RealImagtoComplex_re) +
    rtb_ComplextoRealImag_o2) + rtb_Add3_d;

  /* Sum: '<S264>/Sum2' incorporates:
   *  ComplexToMagnitudeAngle: '<S264>/Complex to Magnitude-Angle'
   *  Constant: '<S264>/Constant3'
   *  RealImagToComplex: '<S264>/Real-Imag to Complex'
   */
  rtb_RateLimiter = rt_atan2d_snf(rtb_RealImagtoComplex_im, rtb_yk_h_idx_0) +
    0.018849555921538759;

  /* MagnitudeAngleToComplex: '<S264>/Magnitude-Angle to Complex' incorporates:
   *  ComplexToMagnitudeAngle: '<S264>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S264>/Real-Imag to Complex'
   */
  rtb_RealImagtoComplex_im = rt_hypotd_snf(rtb_yk_h_idx_0,
    rtb_RealImagtoComplex_im);
  rtb_RealImagtoComplex_re = rtb_RealImagtoComplex_im * cos(rtb_RateLimiter);
  rtb_RealImagtoComplex_im *= sin(rtb_RateLimiter);

  /* Gain: '<S265>/Kp5' */
  rtb_Add3_d = 80.0 * rtb_DiscreteTimeIntegrator_k;

  /* Saturate: '<S255>/Saturation' incorporates:
   *  ComplexToRealImag: '<S264>/Complex to Real-Imag'
   */
  if (rtb_RealImagtoComplex_re > 1.5) {
    /* Update for RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[0] = 1.5;
  } else if (rtb_RealImagtoComplex_re < -1.5) {
    /* Update for RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[0] = -1.5;
  } else {
    /* Update for RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[0] = rtb_RealImagtoComplex_re;
  }

  if (rtb_RealImagtoComplex_im > 1.5) {
    /* Update for RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[1] = 1.5;
  } else if (rtb_RealImagtoComplex_im < -1.5) {
    /* Update for RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[1] = -1.5;
  } else {
    /* Update for RateTransition: '<S72>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[1] = rtb_RealImagtoComplex_im;
  }

  /* End of Saturate: '<S255>/Saturation' */

  /* Outputs for Enabled SubSystem: '<S272>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S273>/Enable'
   */
  if (!rtDW.AutomaticGainControl_MODE) {
    /* Enable for DiscreteIntegrator: '<S282>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_oq = 1U;

    /* Enable for DiscreteIntegrator: '<S285>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ez = 1U;
    rtDW.AutomaticGainControl_MODE = true;
  }

  /* Outputs for Enabled SubSystem: '<S288>/Subsystem1' */
  /* DiscreteIntegrator: '<S272>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_o,
             &rtDW.Fcn_m5, &rtDW.Fcn1_g1);

  /* End of Outputs for SubSystem: '<S288>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S288>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_i, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_c,
                    &rtDW.Fcn1_d);

  /* End of Outputs for SubSystem: '<S288>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S282>/Integ4' incorporates:
   *  Switch: '<S288>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_oq != 0) {
    rtDW.Integ4_cs = rtDW.Integ4_DSTATE_md;
  } else {
    rtDW.Integ4_cs = 2.5E-5 * rtDW.Fcn_c + rtDW.Integ4_DSTATE_md;
  }

  /* End of DiscreteIntegrator: '<S282>/Integ4' */

  /* Saturate: '<S282>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_cn4 > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_cn4 < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_cn4;
  }

  /* End of Saturate: '<S282>/To avoid division  by zero' */

  /* Fcn: '<S282>/Number of samples per cycle' */
  rtb_yk_h_idx_0 = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S282>/Rounding Function' */
  rtb_RoundingFunction_l = ceil(rtb_yk_h_idx_0);

  /* Gain: '<S282>/Gain' */
  rtDW.Delay_f = 5.0E-5 * rtb_RoundingFunction_l;

  /* S-Function (sfun_discreteVariableDelay): '<S284>/S-Function' */

  /* Level2 S-Function Block: '<S284>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S282>/Switch' incorporates:
   *  Constant: '<S282>/Constant'
   *  Gain: '<S283>/Gain1'
   *  Product: '<S282>/Product'
   *  Product: '<S283>/Product2'
   *  Product: '<S283>/Product4'
   *  Product: '<S283>/Product5'
   *  RelationalOperator: '<S282>/Relational Operator'
   *  Sum: '<S282>/Sum5'
   *  Sum: '<S282>/Sum7'
   *  Sum: '<S283>/Sum1'
   *  Sum: '<S283>/Sum4'
   *  Switch: '<S288>/Switch'
   *  UnitDelay: '<S272>/Unit Delay'
   *  UnitDelay: '<S282>/Unit Delay1'
   *  UnitDelay: '<S283>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S283>/Sum5' */
    rtb_RoundingFunction_l = rtb_yk_h_idx_0 - rtb_RoundingFunction_l;
    rtb_RoundingFunction_l = ((rtDW.Fcn_c - rtDW.UnitDelay_DSTATE_kr) *
      rtb_RoundingFunction_l * 0.5 + rtDW.Fcn_c) * (rtb_RoundingFunction_l /
      rtb_yk_h_idx_0) + (rtDW.Integ4_cs - rtDW.SFunction_d4) *
      rtDW.UnitDelay_DSTATE_cn4;
  } else {
    rtb_RoundingFunction_l = rtDW.UnitDelay1_DSTATE_hp;
  }

  /* End of Switch: '<S282>/Switch' */

  /* DiscreteIntegrator: '<S285>/Integ4' incorporates:
   *  Switch: '<S288>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ez != 0) {
    rtDW.Integ4_ha = rtDW.Integ4_DSTATE_e5y;
  } else {
    rtDW.Integ4_ha = 2.5E-5 * rtDW.Fcn1_d + rtDW.Integ4_DSTATE_e5y;
  }

  /* End of DiscreteIntegrator: '<S285>/Integ4' */

  /* Saturate: '<S285>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_cn4 > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_cn4 < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_cn4;
  }

  /* End of Saturate: '<S285>/To avoid division  by zero' */

  /* Fcn: '<S285>/Number of samples per cycle' */
  rtb_yk_h_idx_0 = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S285>/Rounding Function' */
  rtb_RoundingFunction_k = ceil(rtb_yk_h_idx_0);

  /* Gain: '<S285>/Gain' */
  rtDW.Delay_l = 5.0E-5 * rtb_RoundingFunction_k;

  /* S-Function (sfun_discreteVariableDelay): '<S287>/S-Function' */

  /* Level2 S-Function Block: '<S287>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S285>/Switch' incorporates:
   *  Constant: '<S285>/Constant'
   *  Gain: '<S286>/Gain1'
   *  Product: '<S285>/Product'
   *  Product: '<S286>/Product2'
   *  Product: '<S286>/Product4'
   *  Product: '<S286>/Product5'
   *  RelationalOperator: '<S285>/Relational Operator'
   *  Sum: '<S285>/Sum5'
   *  Sum: '<S285>/Sum7'
   *  Sum: '<S286>/Sum1'
   *  Sum: '<S286>/Sum4'
   *  Switch: '<S288>/Switch'
   *  UnitDelay: '<S272>/Unit Delay'
   *  UnitDelay: '<S285>/Unit Delay1'
   *  UnitDelay: '<S286>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S286>/Sum5' */
    rtb_RoundingFunction_k = rtb_yk_h_idx_0 - rtb_RoundingFunction_k;
    rtb_RoundingFunction_k = ((rtDW.Fcn1_d - rtDW.UnitDelay_DSTATE_ko) *
      rtb_RoundingFunction_k * 0.5 + rtDW.Fcn1_d) * (rtb_RoundingFunction_k /
      rtb_yk_h_idx_0) + (rtDW.Integ4_ha - rtDW.SFunction_e5) *
      rtDW.UnitDelay_DSTATE_cn4;
  } else {
    rtb_RoundingFunction_k = rtDW.UnitDelay1_DSTATE_j3;
  }

  /* End of Switch: '<S285>/Switch' */

  /* ComplexToMagnitudeAngle: '<S278>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S278>/Real-Imag to Complex'
   */
  rtb_yk_h_idx_0 = rt_hypotd_snf(rtb_RoundingFunction_l, rtb_RoundingFunction_k);

  /* Saturate: '<S273>/Saturation' */
  if (rtb_yk_h_idx_0 <= 2.2204460492503131E-16) {
    rtb_yk_h_idx_0 = 2.2204460492503131E-16;
  }

  /* End of Saturate: '<S273>/Saturation' */

  /* Math: '<S273>/Math Function'
   *
   * About '<S273>/Math Function':
   *  Operator: reciprocal
   */
  rtDW.MathFunction = 1.0 / rtb_yk_h_idx_0;

  /* Update for DiscreteIntegrator: '<S282>/Integ4' incorporates:
   *  Switch: '<S288>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_oq = 0U;
  rtDW.Integ4_DSTATE_md = 2.5E-5 * rtDW.Fcn_c + rtDW.Integ4_cs;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S284>/S-Function' */
  /* Level2 S-Function Block: '<S284>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S283>/Unit Delay' incorporates:
   *  Switch: '<S288>/Switch'
   */
  rtDW.UnitDelay_DSTATE_kr = rtDW.Fcn_c;

  /* Update for UnitDelay: '<S282>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_hp = rtb_RoundingFunction_l;

  /* Update for DiscreteIntegrator: '<S285>/Integ4' incorporates:
   *  Switch: '<S288>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_ez = 0U;
  rtDW.Integ4_DSTATE_e5y = 2.5E-5 * rtDW.Fcn1_d + rtDW.Integ4_ha;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S287>/S-Function' */
  /* Level2 S-Function Block: '<S287>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S286>/Unit Delay' incorporates:
   *  Switch: '<S288>/Switch'
   */
  rtDW.UnitDelay_DSTATE_ko = rtDW.Fcn1_d;

  /* Update for UnitDelay: '<S285>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_j3 = rtb_RoundingFunction_k;

  /* End of Outputs for SubSystem: '<S272>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S301>/Subsystem1' */
  /* DiscreteIntegrator: '<S272>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_o,
             &rtb_yk_h_idx_0, &rtDW.Fcn1_g);

  /* End of Outputs for SubSystem: '<S301>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S301>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_pj, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtb_yk_h_idx_0,
                    &rtDW.Fcn1_b);

  /* End of Outputs for SubSystem: '<S301>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S298>/Integ4' incorporates:
   *  Switch: '<S301>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_nm != 0) {
    rtDW.Integ4_ll = rtDW.Integ4_DSTATE_ad;
  } else {
    rtDW.Integ4_ll = 2.5E-5 * rtDW.Fcn1_b + rtDW.Integ4_DSTATE_ad;
  }

  /* End of DiscreteIntegrator: '<S298>/Integ4' */

  /* Saturate: '<S298>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_cn4 > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_cn4 < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_cn4;
  }

  /* End of Saturate: '<S298>/To avoid division  by zero' */

  /* Fcn: '<S298>/Number of samples per cycle' */
  rtb_RoundingFunction_l = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S298>/Rounding Function' */
  rtb_RoundingFunction_k = ceil(rtb_RoundingFunction_l);

  /* Gain: '<S298>/Gain' */
  rtDW.Delay = 5.0E-5 * rtb_RoundingFunction_k;

  /* S-Function (sfun_discreteVariableDelay): '<S300>/S-Function' */

  /* Level2 S-Function Block: '<S300>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S298>/Switch' incorporates:
   *  Constant: '<S298>/Constant'
   *  Gain: '<S299>/Gain1'
   *  Product: '<S298>/Product'
   *  Product: '<S299>/Product2'
   *  Product: '<S299>/Product4'
   *  Product: '<S299>/Product5'
   *  RelationalOperator: '<S298>/Relational Operator'
   *  Sum: '<S298>/Sum5'
   *  Sum: '<S298>/Sum7'
   *  Sum: '<S299>/Sum1'
   *  Sum: '<S299>/Sum4'
   *  Switch: '<S301>/Switch'
   *  UnitDelay: '<S272>/Unit Delay'
   *  UnitDelay: '<S298>/Unit Delay1'
   *  UnitDelay: '<S299>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S299>/Sum5' */
    rtb_RoundingFunction_k = rtb_RoundingFunction_l - rtb_RoundingFunction_k;
    rtb_RoundingFunction_l = ((rtDW.Fcn1_b - rtDW.UnitDelay_DSTATE_c3) *
      rtb_RoundingFunction_k * 0.5 + rtDW.Fcn1_b) * (rtb_RoundingFunction_k /
      rtb_RoundingFunction_l) + (rtDW.Integ4_ll - rtDW.SFunction_ia) *
      rtDW.UnitDelay_DSTATE_cn4;
  } else {
    rtb_RoundingFunction_l = rtDW.UnitDelay1_DSTATE_o0e;
  }

  /* End of Switch: '<S298>/Switch' */

  /* Product: '<S272>/Divide' */
  rtb_RoundingFunction_k = rtb_RoundingFunction_l * rtDW.MathFunction;

  /* Sum: '<S274>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S274>/Discrete-Time Integrator'
   *  DiscreteTransferFcn: '<S274>/Discrete Derivative '
   *  Gain: '<S274>/Kp4'
   */
  rtb_yk_h_idx_0 = (90.0 * rtb_RoundingFunction_k +
                    rtDW.DiscreteTimeIntegrator_DSTATE_n) + -0.0 *
    rtDW.DiscreteDerivative_states;

  /* Saturate: '<S274>/Saturation1' */
  if (rtb_yk_h_idx_0 <= 0.0) {
    rtb_Saturation1 = 0.0;
  } else {
    rtb_Saturation1 = rtb_yk_h_idx_0;
  }

  /* End of Saturate: '<S274>/Saturation1' */

  /* Gain: '<S272>/Gain10' */
  rtb_yk_h_idx_0 = 0.15915494309189535 * rtb_Saturation1;

  /* RateLimiter: '<S272>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = rtb_yk_h_idx_0 - rtDW.PrevY_l;
  if (rtb_DiscreteTimeIntegrator_k > 0.00060000000000000006) {
    rtb_yk_h_idx_0 = rtDW.PrevY_l + 0.00060000000000000006;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.00060000000000000006) {
      rtb_yk_h_idx_0 = rtDW.PrevY_l + -0.00060000000000000006;
    }
  }

  rtDW.PrevY_l = rtb_yk_h_idx_0;

  /* End of RateLimiter: '<S272>/Rate Limiter' */

  /* Sum: '<S295>/sum3' incorporates:
   *  Gain: '<S295>/A21'
   *  Gain: '<S295>/A22'
   *  UnitDelay: '<S294>/Delay_x1'
   *  UnitDelay: '<S294>/Delay_x2'
   */
  rtb_sum3 = -1.226881692709296 * rtDW.Delay_x1_DSTATE_l + 0.988925236714054 *
    rtDW.Delay_x2_DSTATE_j;

  /* Sum: '<S314>/sum3' incorporates:
   *  Gain: '<S314>/A21'
   *  Gain: '<S314>/A22'
   *  UnitDelay: '<S313>/Delay_x1'
   *  UnitDelay: '<S313>/Delay_x2'
   */
  rtb_sum3_h_idx_0 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE_p[0] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE_d[0];
  rtb_sum3_h_idx_1 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE_p[1] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE_d[1];

  /* Sum: '<S63>/Sum6' incorporates:
   *  RateTransition: '<S63>/Rate Transition3'
   */
  rtb_DigitalClock -= rtDW.RateTransition3_Buffer;

  /* Sum: '<S73>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S73>/Discrete-Time Integrator'
   *  Gain: '<S73>/Kp4'
   */
  rtb_Saturation2 = 0.0015 * rtb_DigitalClock +
    rtDW.DiscreteTimeIntegrator_DSTAT_om;

  /* Saturate: '<S73>/Saturation2' */
  if (rtb_Saturation2 > 1.0) {
    rtb_Saturation2 = 1.0;
  } else {
    if (rtb_Saturation2 < 0.0) {
      rtb_Saturation2 = 0.0;
    }
  }

  /* End of Saturate: '<S73>/Saturation2' */

  /* Outputs for Enabled SubSystem: '<S193>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S194>/Enable'
   */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S229>/Gain1' incorporates:
     *  Gain: '<S181>/V->pu1'
     *  Gain: '<S210>/Gain1'
     *  Gain: '<S223>/Gain1'
     *  Gain: '<S229>/Gain3'
     *  RateTransition: '<S71>/Rate Transition2'
     */
    rtb_Gain1[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (4.8989794855663556E-5 * rtDW.RateTransition2_Buffer_i[2]) +
      (rtConstP.pooled30[i + 3] * (4.8989794855663556E-5 *
      rtDW.RateTransition2_Buffer_i[1]) + 4.8989794855663556E-5 *
       rtDW.RateTransition2_Buffer_i[0] * rtConstP.pooled30[i]));
  }

  /* End of Outputs for SubSystem: '<S193>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S228>/Subsystem1' */
  /* Gain: '<S229>/Gain1' incorporates:
   *  DiscreteIntegrator: '<S193>/Discrete-Time Integrator'
   */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_b,
             &rtDW.Fcn1_n);

  /* End of Outputs for SubSystem: '<S228>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S228>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_k, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_o,
                    &rtDW.Fcn1_om);

  /* End of Outputs for SubSystem: '<S228>/Subsystem - pi//2 delay' */

  /* Sum: '<S180>/Sum' */
  rtb_RateLimiter = rtb_Product2_ft - rtb_yk_m_idx_0;

  /* Gain: '<S180>/Rtot_pu3' incorporates:
   *  UnitDelay: '<S193>/Unit Delay'
   */
  rtb_ComplextoRealImag_o2 = 0.016666666666666666 * rtDW.UnitDelay_DSTATE_fu;

  /* Sum: '<S189>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S189>/Discrete-Time Integrator'
   *  Gain: '<S189>/Kp4'
   */
  rtb_RealImagtoComplex_re = 0.1 * rtb_RateLimiter +
    rtDW.DiscreteTimeIntegrator_DSTATE_e;

  /* Saturate: '<S189>/Saturation2' */
  if (rtb_RealImagtoComplex_re > 1.5) {
    rtb_RealImagtoComplex_re = 1.5;
  } else {
    if (rtb_RealImagtoComplex_re < -1.5) {
      rtb_RealImagtoComplex_re = -1.5;
    }
  }

  /* End of Saturate: '<S189>/Saturation2' */

  /* Sum: '<S180>/Add1' incorporates:
   *  Constant: '<S180>/Constant2'
   *  Constant: '<S71>/Iref'
   *  Gain: '<S180>/Gain'
   *  Product: '<S180>/Product1'
   *  Switch: '<S228>/Switch'
   */
  rtb_DiscreteTimeIntegrator_k = ((rtDW.Fcn_o + rtb_RealImagtoComplex_re) +
    0.0033333333333333335 * rtb_Product2_ft) - 0.0 * rtb_ComplextoRealImag_o2;

  /* Product: '<S180>/Product2' incorporates:
   *  Constant: '<S180>/Constant1'
   */
  rtb_Product2_ft = rtb_Product2_ft * 0.1 * rtb_ComplextoRealImag_o2;

  /* Sum: '<S190>/Sum6' incorporates:
   *  Constant: '<S71>/Iref'
   *  DiscreteIntegrator: '<S190>/Discrete-Time Integrator'
   *  Gain: '<S190>/Kp4'
   *  Sum: '<S180>/Sum1'
   */
  rtb_RealImagtoComplex_re = (0.0 - Initial) * 0.1 +
    rtDW.DiscreteTimeIntegrator_DSTATE_l;

  /* Saturate: '<S190>/Saturation2' */
  if (rtb_RealImagtoComplex_re > 1.5) {
    rtb_RealImagtoComplex_re = 1.5;
  } else {
    if (rtb_RealImagtoComplex_re < -1.5) {
      rtb_RealImagtoComplex_re = -1.5;
    }
  }

  /* End of Saturate: '<S190>/Saturation2' */

  /* RealImagToComplex: '<S188>/Real-Imag to Complex' incorporates:
   *  Sum: '<S180>/Add3'
   *  Switch: '<S228>/Switch'
   */
  rtb_RealImagtoComplex_im = (rtDW.Fcn1_om + rtb_RealImagtoComplex_re) +
    rtb_Product2_ft;

  /* Sum: '<S188>/Sum2' incorporates:
   *  ComplexToMagnitudeAngle: '<S188>/Complex to Magnitude-Angle'
   *  Constant: '<S188>/Constant3'
   *  RealImagToComplex: '<S188>/Real-Imag to Complex'
   */
  rtb_ComplextoRealImag_o2 = rt_atan2d_snf(rtb_RealImagtoComplex_im,
    rtb_DiscreteTimeIntegrator_k) + -0.50474921967676;

  /* MagnitudeAngleToComplex: '<S188>/Magnitude-Angle to Complex' incorporates:
   *  ComplexToMagnitudeAngle: '<S188>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S188>/Real-Imag to Complex'
   */
  rtb_RealImagtoComplex_im = rt_hypotd_snf(rtb_DiscreteTimeIntegrator_k,
    rtb_RealImagtoComplex_im);
  rtb_RealImagtoComplex_re = rtb_RealImagtoComplex_im * cos
    (rtb_ComplextoRealImag_o2);
  rtb_RealImagtoComplex_im *= sin(rtb_ComplextoRealImag_o2);

  /* Gain: '<S189>/Kp5' */
  rtb_Product2_ft = 8.0 * rtb_RateLimiter;

  /* Outputs for Enabled SubSystem: '<S193>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S194>/Enable'
   */
  if (!rtDW.AutomaticGainControl_MODE_p) {
    /* Enable for DiscreteIntegrator: '<S203>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ck = 1U;

    /* Enable for DiscreteIntegrator: '<S206>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ly = 1U;
    rtDW.AutomaticGainControl_MODE_p = true;
  }

  /* Outputs for Enabled SubSystem: '<S209>/Subsystem1' */
  /* DiscreteIntegrator: '<S193>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_a,
             &rtDW.Fcn1_l);

  /* End of Outputs for SubSystem: '<S209>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S209>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_au, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_p,
                    &rtDW.Fcn1_h);

  /* End of Outputs for SubSystem: '<S209>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S203>/Integ4' incorporates:
   *  Switch: '<S209>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ck != 0) {
    rtDW.Integ4_cu = rtDW.Integ4_DSTATE_o3;
  } else {
    rtDW.Integ4_cu = 2.5E-5 * rtDW.Fcn_p + rtDW.Integ4_DSTATE_o3;
  }

  /* End of DiscreteIntegrator: '<S203>/Integ4' */

  /* Saturate: '<S203>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_fu > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_fu < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_fu;
  }

  /* End of Saturate: '<S203>/To avoid division  by zero' */

  /* Fcn: '<S203>/Number of samples per cycle' */
  rtb_RateLimiter = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S203>/Rounding Function' */
  rtb_DiscreteTimeIntegrator_k = ceil(rtb_RateLimiter);

  /* Gain: '<S203>/Gain' */
  rtDW.Delay_ou = 5.0E-5 * rtb_DiscreteTimeIntegrator_k;

  /* S-Function (sfun_discreteVariableDelay): '<S205>/S-Function' */

  /* Level2 S-Function Block: '<S205>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S203>/Switch' incorporates:
   *  Constant: '<S203>/Constant'
   *  Gain: '<S204>/Gain1'
   *  Product: '<S203>/Product'
   *  Product: '<S204>/Product2'
   *  Product: '<S204>/Product4'
   *  Product: '<S204>/Product5'
   *  RelationalOperator: '<S203>/Relational Operator'
   *  Sum: '<S203>/Sum5'
   *  Sum: '<S203>/Sum7'
   *  Sum: '<S204>/Sum1'
   *  Sum: '<S204>/Sum4'
   *  Switch: '<S209>/Switch'
   *  UnitDelay: '<S193>/Unit Delay'
   *  UnitDelay: '<S203>/Unit Delay1'
   *  UnitDelay: '<S204>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S204>/Sum5' */
    rtb_DiscreteTimeIntegrator_k = rtb_RateLimiter -
      rtb_DiscreteTimeIntegrator_k;
    rtb_DiscreteTimeIntegrator_k = ((rtDW.Fcn_p - rtDW.UnitDelay_DSTATE_c2) *
      rtb_DiscreteTimeIntegrator_k * 0.5 + rtDW.Fcn_p) *
      (rtb_DiscreteTimeIntegrator_k / rtb_RateLimiter) + (rtDW.Integ4_cu -
      rtDW.SFunction_lp) * rtDW.UnitDelay_DSTATE_fu;
  } else {
    rtb_DiscreteTimeIntegrator_k = rtDW.UnitDelay1_DSTATE_ia;
  }

  /* End of Switch: '<S203>/Switch' */

  /* DiscreteIntegrator: '<S206>/Integ4' incorporates:
   *  Switch: '<S209>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ly != 0) {
    rtDW.Integ4_dh0 = rtDW.Integ4_DSTATE_ei;
  } else {
    rtDW.Integ4_dh0 = 2.5E-5 * rtDW.Fcn1_h + rtDW.Integ4_DSTATE_ei;
  }

  /* End of DiscreteIntegrator: '<S206>/Integ4' */

  /* Saturate: '<S206>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_fu > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_fu < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_fu;
  }

  /* End of Saturate: '<S206>/To avoid division  by zero' */

  /* Fcn: '<S206>/Number of samples per cycle' */
  rtb_RateLimiter = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S206>/Rounding Function' */
  rtb_ComplextoRealImag_o2 = ceil(rtb_RateLimiter);

  /* Gain: '<S206>/Gain' */
  rtDW.Delay_lg = 5.0E-5 * rtb_ComplextoRealImag_o2;

  /* S-Function (sfun_discreteVariableDelay): '<S208>/S-Function' */

  /* Level2 S-Function Block: '<S208>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S206>/Switch' incorporates:
   *  Constant: '<S206>/Constant'
   *  Gain: '<S207>/Gain1'
   *  Product: '<S206>/Product'
   *  Product: '<S207>/Product2'
   *  Product: '<S207>/Product4'
   *  Product: '<S207>/Product5'
   *  RelationalOperator: '<S206>/Relational Operator'
   *  Sum: '<S206>/Sum5'
   *  Sum: '<S206>/Sum7'
   *  Sum: '<S207>/Sum1'
   *  Sum: '<S207>/Sum4'
   *  Switch: '<S209>/Switch'
   *  UnitDelay: '<S193>/Unit Delay'
   *  UnitDelay: '<S206>/Unit Delay1'
   *  UnitDelay: '<S207>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S207>/Sum5' */
    rtb_ComplextoRealImag_o2 = rtb_RateLimiter - rtb_ComplextoRealImag_o2;
    rtb_ComplextoRealImag_o2 = ((rtDW.Fcn1_h - rtDW.UnitDelay_DSTATE_m0) *
      rtb_ComplextoRealImag_o2 * 0.5 + rtDW.Fcn1_h) * (rtb_ComplextoRealImag_o2 /
      rtb_RateLimiter) + (rtDW.Integ4_dh0 - rtDW.SFunction_ca) *
      rtDW.UnitDelay_DSTATE_fu;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay1_DSTATE_ou;
  }

  /* End of Switch: '<S206>/Switch' */

  /* ComplexToMagnitudeAngle: '<S199>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S199>/Real-Imag to Complex'
   */
  rtb_RateLimiter = rt_hypotd_snf(rtb_DiscreteTimeIntegrator_k,
    rtb_ComplextoRealImag_o2);

  /* Saturate: '<S194>/Saturation' */
  if (rtb_RateLimiter <= 2.2204460492503131E-16) {
    rtb_RateLimiter = 2.2204460492503131E-16;
  }

  /* End of Saturate: '<S194>/Saturation' */

  /* Math: '<S194>/Math Function'
   *
   * About '<S194>/Math Function':
   *  Operator: reciprocal
   */
  rtDW.MathFunction_h = 1.0 / rtb_RateLimiter;

  /* Update for DiscreteIntegrator: '<S203>/Integ4' incorporates:
   *  Switch: '<S209>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_ck = 0U;
  rtDW.Integ4_DSTATE_o3 = 2.5E-5 * rtDW.Fcn_p + rtDW.Integ4_cu;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S205>/S-Function' */
  /* Level2 S-Function Block: '<S205>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S204>/Unit Delay' incorporates:
   *  Switch: '<S209>/Switch'
   */
  rtDW.UnitDelay_DSTATE_c2 = rtDW.Fcn_p;

  /* Update for UnitDelay: '<S203>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ia = rtb_DiscreteTimeIntegrator_k;

  /* Update for DiscreteIntegrator: '<S206>/Integ4' incorporates:
   *  Switch: '<S209>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_ly = 0U;
  rtDW.Integ4_DSTATE_ei = 2.5E-5 * rtDW.Fcn1_h + rtDW.Integ4_dh0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S208>/S-Function' */
  /* Level2 S-Function Block: '<S208>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S207>/Unit Delay' incorporates:
   *  Switch: '<S209>/Switch'
   */
  rtDW.UnitDelay_DSTATE_m0 = rtDW.Fcn1_h;

  /* Update for UnitDelay: '<S206>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ou = rtb_ComplextoRealImag_o2;

  /* End of Outputs for SubSystem: '<S193>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S222>/Subsystem1' */
  /* DiscreteIntegrator: '<S193>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1[0], rtDW.DiscreteTimeIntegrator_DSTATE_c,
             &rtb_yk_m_idx_0, &rtDW.Fcn1_n1);

  /* End of Outputs for SubSystem: '<S222>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S222>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_a, &rtb_Gain1[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtb_yk_m_idx_0,
                    &rtDW.Fcn1_f);

  /* End of Outputs for SubSystem: '<S222>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S219>/Integ4' incorporates:
   *  Switch: '<S222>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_nr != 0) {
    rtDW.Integ4_nt = rtDW.Integ4_DSTATE_o5;
  } else {
    rtDW.Integ4_nt = 2.5E-5 * rtDW.Fcn1_f + rtDW.Integ4_DSTATE_o5;
  }

  /* End of DiscreteIntegrator: '<S219>/Integ4' */

  /* Saturate: '<S219>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_fu > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_fu < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_fu;
  }

  /* End of Saturate: '<S219>/To avoid division  by zero' */

  /* Fcn: '<S219>/Number of samples per cycle' */
  rtb_DiscreteTimeIntegrator_k = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S219>/Rounding Function' */
  rtb_ComplextoRealImag_o2 = ceil(rtb_DiscreteTimeIntegrator_k);

  /* Gain: '<S219>/Gain' */
  rtDW.Delay_o = 5.0E-5 * rtb_ComplextoRealImag_o2;

  /* S-Function (sfun_discreteVariableDelay): '<S221>/S-Function' */

  /* Level2 S-Function Block: '<S221>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S219>/Switch' incorporates:
   *  Constant: '<S219>/Constant'
   *  Gain: '<S220>/Gain1'
   *  Product: '<S219>/Product'
   *  Product: '<S220>/Product2'
   *  Product: '<S220>/Product4'
   *  Product: '<S220>/Product5'
   *  RelationalOperator: '<S219>/Relational Operator'
   *  Sum: '<S219>/Sum5'
   *  Sum: '<S219>/Sum7'
   *  Sum: '<S220>/Sum1'
   *  Sum: '<S220>/Sum4'
   *  Switch: '<S222>/Switch'
   *  UnitDelay: '<S193>/Unit Delay'
   *  UnitDelay: '<S219>/Unit Delay1'
   *  UnitDelay: '<S220>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S220>/Sum5' */
    rtb_ComplextoRealImag_o2 = rtb_DiscreteTimeIntegrator_k -
      rtb_ComplextoRealImag_o2;
    rtb_ComplextoRealImag_o2 = ((rtDW.Fcn1_f - rtDW.UnitDelay_DSTATE_k) *
      rtb_ComplextoRealImag_o2 * 0.5 + rtDW.Fcn1_f) * (rtb_ComplextoRealImag_o2 /
      rtb_DiscreteTimeIntegrator_k) + (rtDW.Integ4_nt - rtDW.SFunction_gd) *
      rtDW.UnitDelay_DSTATE_fu;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay1_DSTATE_lv;
  }

  /* End of Switch: '<S219>/Switch' */

  /* Product: '<S193>/Divide' */
  Divide_e = rtb_ComplextoRealImag_o2 * rtDW.MathFunction_h;

  /* Sum: '<S195>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S195>/Discrete-Time Integrator'
   *  DiscreteTransferFcn: '<S195>/Discrete Derivative '
   *  Gain: '<S195>/Kp4'
   */
  rtb_RateLimiter = (90.0 * Divide_e + rtDW.DiscreteTimeIntegrator_DSTATE_p) +
    -0.0 * rtDW.DiscreteDerivative_states_l;

  /* Saturate: '<S195>/Saturation1' */
  if (rtb_RateLimiter <= 0.0) {
    rtb_yk_m_idx_0 = 0.0;
  } else {
    rtb_yk_m_idx_0 = rtb_RateLimiter;
  }

  /* End of Saturate: '<S195>/Saturation1' */

  /* Gain: '<S193>/Gain10' */
  rtb_RateLimiter = 0.15915494309189535 * rtb_yk_m_idx_0;

  /* RateLimiter: '<S193>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = rtb_RateLimiter - rtDW.PrevY_a;
  if (rtb_DiscreteTimeIntegrator_k > 0.00060000000000000006) {
    rtb_RateLimiter = rtDW.PrevY_a + 0.00060000000000000006;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.00060000000000000006) {
      rtb_RateLimiter = rtDW.PrevY_a + -0.00060000000000000006;
    }
  }

  rtDW.PrevY_a = rtb_RateLimiter;

  /* End of RateLimiter: '<S193>/Rate Limiter' */

  /* Sum: '<S216>/sum3' incorporates:
   *  Gain: '<S216>/A21'
   *  Gain: '<S216>/A22'
   *  UnitDelay: '<S215>/Delay_x1'
   *  UnitDelay: '<S215>/Delay_x2'
   */
  rtb_DiscreteTimeIntegrator_k = -1.226881692709296 * rtDW.Delay_x1_DSTATE_g +
    0.988925236714054 * rtDW.Delay_x2_DSTATE_ie;

  /* Sum: '<S235>/sum3' incorporates:
   *  Gain: '<S235>/A21'
   *  Gain: '<S235>/A22'
   *  UnitDelay: '<S234>/Delay_x1'
   *  UnitDelay: '<S234>/Delay_x2'
   */
  rtb_sum3_hq_idx_0 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE[0] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE[0];
  rtb_sum3_hq_idx_1 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE[1] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE[1];

  /* Update for DiscreteIntegrator: '<S242>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S242>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_i += 275.0 * rtb_Gain_o3 * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_i >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_i = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_i <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_i = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S242>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S193>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_c += 5.0E-5 * rtb_yk_m_idx_0;
  rtDW.DiscreteTimeIntegrator_PrevRese = (int8_T)rtb_RelationalOperator_dk;

  /* Update for UnitDelay: '<S234>/Delay_x1' incorporates:
   *  Gain: '<S235>/A11'
   *  Gain: '<S235>/A12'
   *  Gain: '<S236>/B11'
   *  Sum: '<S234>/A*x1(k) + B*u1(k) '
   *  Sum: '<S235>/sum2'
   *  Switch: '<S243>/Switch'
   *  UnitDelay: '<S234>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE[0] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE[0] +
    3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE[0]) + 1.6257039888904968E-5 *
    rtDW.Fcn_jl;

  /* Update for UnitDelay: '<S234>/Delay_x2' incorporates:
   *  Gain: '<S236>/B21'
   *  Sum: '<S234>/A*x2(k) + B*u2(k)'
   *  Switch: '<S243>/Switch'
   */
  rtDW.Delay_x2_DSTATE[0] = 0.65028159555619647 * rtDW.Fcn_jl +
    rtb_sum3_hq_idx_0;

  /* Saturate: '<S180>/Saturation' */
  if (rtb_RealImagtoComplex_re > 1.5) {
    /* Update for RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[0] = 1.5;
  } else if (rtb_RealImagtoComplex_re < -1.5) {
    /* Update for RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[0] = -1.5;
  } else {
    /* Update for RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[0] = rtb_RealImagtoComplex_re;
  }

  /* Update for UnitDelay: '<S234>/Delay_x1' incorporates:
   *  Gain: '<S235>/A11'
   *  Gain: '<S235>/A12'
   *  Gain: '<S236>/B11'
   *  Sum: '<S234>/A*x1(k) + B*u1(k) '
   *  Sum: '<S235>/sum2'
   *  Switch: '<S243>/Switch'
   *  UnitDelay: '<S234>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE[1] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE[1] +
    3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE[1]) + 1.6257039888904968E-5 *
    rtDW.Fcn1_on;

  /* Update for UnitDelay: '<S234>/Delay_x2' incorporates:
   *  Gain: '<S236>/B21'
   *  Sum: '<S234>/A*x2(k) + B*u2(k)'
   *  Switch: '<S243>/Switch'
   */
  rtDW.Delay_x2_DSTATE[1] = 0.65028159555619647 * rtDW.Fcn1_on +
    rtb_sum3_hq_idx_1;

  /* Saturate: '<S180>/Saturation' */
  if (rtb_RealImagtoComplex_im > 1.5) {
    /* Update for RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[1] = 1.5;
  } else if (rtb_RealImagtoComplex_im < -1.5) {
    /* Update for RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[1] = -1.5;
  } else {
    /* Update for RateTransition: '<S71>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[1] = rtb_RealImagtoComplex_im;
  }

  /* Update for DiscreteIntegrator: '<S321>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S321>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_j += 800.0 * rtb_Gain_eb * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_j >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_j = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_j <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_j = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S321>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S272>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_o += 5.0E-5 * rtb_Saturation1;
  rtDW.DiscreteTimeIntegrator_PrevRe_g = (int8_T)rtb_RelationalOperator_hg;

  /* Update for UnitDelay: '<S313>/Delay_x1' incorporates:
   *  Gain: '<S314>/A11'
   *  Gain: '<S314>/A12'
   *  Gain: '<S315>/B11'
   *  Sum: '<S313>/A*x1(k) + B*u1(k) '
   *  Sum: '<S314>/sum2'
   *  Switch: '<S322>/Switch'
   *  UnitDelay: '<S313>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_p[0] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE_p[0] +
    3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE_d[0]) + 1.6257039888904968E-5 *
    rtDW.Fcn_d;

  /* Update for UnitDelay: '<S313>/Delay_x2' incorporates:
   *  Gain: '<S315>/B21'
   *  Sum: '<S313>/A*x2(k) + B*u2(k)'
   *  Switch: '<S322>/Switch'
   */
  rtDW.Delay_x2_DSTATE_d[0] = 0.65028159555619647 * rtDW.Fcn_d +
    rtb_sum3_h_idx_0;

  /* Update for UnitDelay: '<S313>/Delay_x1' incorporates:
   *  Gain: '<S314>/A11'
   *  Gain: '<S314>/A12'
   *  Gain: '<S315>/B11'
   *  Sum: '<S313>/A*x1(k) + B*u1(k) '
   *  Sum: '<S314>/sum2'
   *  Switch: '<S322>/Switch'
   *  UnitDelay: '<S313>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_p[1] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE_p[1] +
    3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE_d[1]) + 1.6257039888904968E-5 *
    rtDW.Fcn1_j;

  /* Update for UnitDelay: '<S313>/Delay_x2' incorporates:
   *  Gain: '<S315>/B21'
   *  Sum: '<S313>/A*x2(k) + B*u2(k)'
   *  Switch: '<S322>/Switch'
   */
  rtDW.Delay_x2_DSTATE_d[1] = 0.65028159555619647 * rtDW.Fcn1_j +
    rtb_sum3_h_idx_1;

  /* Update for DiscreteIntegrator: '<S268>/Integ4' incorporates:
   *  Fcn: '<S256>/Mag_V '
   */
  rtDW.Integ4_SYSTEM_ENABLE_ei = 0U;
  rtDW.Integ4_DSTATE_gg = 2.5E-5 * tmp + rtDW.Integ4_j0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S269>/S-Function' incorporates:
   *  Constant: '<S268>/K1'
   */
  /* Level2 S-Function Block: '<S269>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S268>/Unit Delay' incorporates:
   *  Fcn: '<S256>/Mag_V '
   */
  rtDW.UnitDelay_DSTATE_pj = tmp;

  /* Update for UnitDelay: '<S268>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ai = rtb_Switch_i;

  /* Update for DiscreteIntegrator: '<S74>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S74>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTAT_oe += 50.0 * Initial_a * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTAT_oe >= 1000.0) {
    rtDW.DiscreteTimeIntegrator_DSTAT_oe = 1000.0;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTAT_oe <= -1000.0) {
      rtDW.DiscreteTimeIntegrator_DSTAT_oe = -1000.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S74>/Discrete-Time Integrator' */

  /* Update for RateTransition: '<S63>/Rate Transition2' */
  rtDW.RateTransition2_Buffer0 = rtb_Saturation2;

  /* Update for DiscreteIntegrator: '<S265>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTAT_ju += 5.0E-5 * rtb_Add3_d;
  if (rtDW.DiscreteTimeIntegrator_DSTAT_ju >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTAT_ju = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTAT_ju <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTAT_ju = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S265>/Discrete-Time Integrator' */

  /* Update for UnitDelay: '<S272>/Unit Delay' incorporates:
   *  Gain: '<S294>/D*u(k)'
   *  Gain: '<S297>/C11'
   *  Gain: '<S297>/C12'
   *  Sum: '<S294>/C*X(k)+D*u(k)'
   *  Sum: '<S297>/sum2'
   *  UnitDelay: '<S294>/Delay_x1'
   *  UnitDelay: '<S294>/Delay_x2'
   */
  rtDW.UnitDelay_DSTATE_cn4 = (1.233694313470147 * rtDW.Delay_x1_DSTATE_l +
    3.06720423177324E-5 * rtDW.Delay_x2_DSTATE_j) + 1.53360211588662E-5 *
    rtb_yk_h_idx_0;

  /* Update for DiscreteIntegrator: '<S266>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S266>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_k += 80.0 * rtb_yk_h_idx_1 * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_k >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_k = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_k <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_k = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S266>/Discrete-Time Integrator' */

  /* Update for DiscreteTransferFcn: '<S274>/Discrete Derivative ' */
  rtDW.DiscreteDerivative_states = (rtb_RoundingFunction_k - -5.0E-5 *
    rtDW.DiscreteDerivative_states) / 0.0001;

  /* Update for DiscreteIntegrator: '<S274>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_n += 0.08 * rtb_RoundingFunction_k;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_n >= (rtInf)) {
    rtDW.DiscreteTimeIntegrator_DSTATE_n = (rtInf);
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_n <= 0.0) {
      rtDW.DiscreteTimeIntegrator_DSTATE_n = 0.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S274>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S298>/Integ4' incorporates:
   *  Switch: '<S301>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_nm = 0U;
  rtDW.Integ4_DSTATE_ad = 2.5E-5 * rtDW.Fcn1_b + rtDW.Integ4_ll;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S300>/S-Function' */
  /* Level2 S-Function Block: '<S300>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S299>/Unit Delay' incorporates:
   *  Switch: '<S301>/Switch'
   */
  rtDW.UnitDelay_DSTATE_c3 = rtDW.Fcn1_b;

  /* Update for UnitDelay: '<S298>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0e = rtb_RoundingFunction_l;

  /* Update for UnitDelay: '<S294>/Delay_x1' incorporates:
   *  Gain: '<S295>/A11'
   *  Gain: '<S295>/A12'
   *  Gain: '<S296>/B11'
   *  Sum: '<S294>/A*x1(k) + B*u1(k) '
   *  Sum: '<S295>/sum2'
   *  UnitDelay: '<S294>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_l = (0.99996932795768223 * rtDW.Delay_x1_DSTATE_l +
    4.9723130917851353E-5 * rtDW.Delay_x2_DSTATE_j) + 2.4861565458925677E-5 *
    rtb_yk_h_idx_0;

  /* Update for UnitDelay: '<S294>/Delay_x2' incorporates:
   *  Gain: '<S296>/B21'
   *  Sum: '<S294>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_j = 0.994462618357027 * rtb_yk_h_idx_0 + rtb_sum3;

  /* Update for DiscreteIntegrator: '<S73>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S73>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTAT_om += 0.25 * rtb_DigitalClock * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTAT_om >= 1.0) {
    rtDW.DiscreteTimeIntegrator_DSTAT_om = 1.0;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTAT_om <= 0.0) {
      rtDW.DiscreteTimeIntegrator_DSTAT_om = 0.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S73>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S189>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_e += 5.0E-5 * rtb_Product2_ft;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_e >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_e = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_e <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_e = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S189>/Discrete-Time Integrator' */

  /* Update for UnitDelay: '<S193>/Unit Delay' incorporates:
   *  Gain: '<S215>/D*u(k)'
   *  Gain: '<S218>/C11'
   *  Gain: '<S218>/C12'
   *  Sum: '<S215>/C*X(k)+D*u(k)'
   *  Sum: '<S218>/sum2'
   *  UnitDelay: '<S215>/Delay_x1'
   *  UnitDelay: '<S215>/Delay_x2'
   */
  rtDW.UnitDelay_DSTATE_fu = (1.233694313470147 * rtDW.Delay_x1_DSTATE_g +
    3.06720423177324E-5 * rtDW.Delay_x2_DSTATE_ie) + 1.53360211588662E-5 *
    rtb_RateLimiter;

  /* Update for DiscreteIntegrator: '<S190>/Discrete-Time Integrator' incorporates:
   *  Constant: '<S71>/Iref'
   *  Gain: '<S190>/Kp5'
   *  Sum: '<S180>/Sum1'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_l += (0.0 - Initial) * 8.0 * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_l >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_l = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_l <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_l = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S190>/Discrete-Time Integrator' */

  /* Update for DiscreteTransferFcn: '<S195>/Discrete Derivative ' */
  rtDW.DiscreteDerivative_states_l = (Divide_e - -5.0E-5 *
    rtDW.DiscreteDerivative_states_l) / 0.0001;

  /* Update for DiscreteIntegrator: '<S195>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_p += 0.08 * Divide_e;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_p >= (rtInf)) {
    rtDW.DiscreteTimeIntegrator_DSTATE_p = (rtInf);
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_p <= 0.0) {
      rtDW.DiscreteTimeIntegrator_DSTATE_p = 0.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S195>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S219>/Integ4' incorporates:
   *  Switch: '<S222>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_nr = 0U;
  rtDW.Integ4_DSTATE_o5 = 2.5E-5 * rtDW.Fcn1_f + rtDW.Integ4_nt;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S221>/S-Function' */
  /* Level2 S-Function Block: '<S221>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S220>/Unit Delay' incorporates:
   *  Switch: '<S222>/Switch'
   */
  rtDW.UnitDelay_DSTATE_k = rtDW.Fcn1_f;

  /* Update for UnitDelay: '<S219>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lv = rtb_ComplextoRealImag_o2;

  /* Update for UnitDelay: '<S215>/Delay_x1' incorporates:
   *  Gain: '<S216>/A11'
   *  Gain: '<S216>/A12'
   *  Gain: '<S217>/B11'
   *  Sum: '<S215>/A*x1(k) + B*u1(k) '
   *  Sum: '<S216>/sum2'
   *  UnitDelay: '<S215>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_g = (0.99996932795768223 * rtDW.Delay_x1_DSTATE_g +
    4.9723130917851353E-5 * rtDW.Delay_x2_DSTATE_ie) + 2.4861565458925677E-5 *
    rtb_RateLimiter;

  /* Update for UnitDelay: '<S215>/Delay_x2' incorporates:
   *  Gain: '<S217>/B21'
   *  Sum: '<S215>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_ie = 0.994462618357027 * rtb_RateLimiter +
    rtb_DiscreteTimeIntegrator_k;

  /* Update absolute time */
  /* The "clockTick1" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick1"
   * and "Timing.stepSize1". Size of "clockTick1" ensures timer will not
   * overflow during the application lifespan selected.
   */
  rtM->Timing.t[1] =
    (++rtM->Timing.clockTick1) * rtM->Timing.stepSize1;
}

/* Model initialize function */
void power_converters_switching_devices_initialize(void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));
  rtsiSetSolverName(&rtM->solverInfo,"FixedStepDiscrete");
  rtM->solverInfoPtr = (&rtM->solverInfo);

  /* Initialize timing info */
  {
    int_T *mdlTsMap = rtM->Timing.sampleTimeTaskIDArray;
    mdlTsMap[0] = 0;
    mdlTsMap[1] = 1;
    rtM->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);
    rtM->Timing.sampleTimes = (&rtM->Timing.sampleTimesArray[0]);
    rtM->Timing.offsetTimes = (&rtM->Timing.offsetTimesArray[0]);

    /* task periods */
    rtM->Timing.sampleTimes[0] = (5.0E-6);
    rtM->Timing.sampleTimes[1] = (5.0E-5);

    /* task offsets */
    rtM->Timing.offsetTimes[0] = (0.0);
    rtM->Timing.offsetTimes[1] = (0.0);
  }

  rtmSetTPtr(rtM, &rtM->Timing.tArray[0]);

  {
    int_T *mdlSampleHits = rtM->Timing.sampleHitArray;
    int_T *mdlPerTaskSampleHits = rtM->Timing.perTaskSampleHitsArray;
    rtM->Timing.perTaskSampleHits = (&mdlPerTaskSampleHits[0]);
    mdlSampleHits[0] = 1;
    rtM->Timing.sampleHits = (&mdlSampleHits[0]);
  }

  rtmSetTFinal(rtM, -1);
  rtM->Timing.stepSize0 = 5.0E-6;
  rtM->Timing.stepSize1 = 5.0E-5;
  rtM->solverInfoPtr = (&rtM->solverInfo);
  rtM->Timing.stepSize = (5.0E-6);
  rtsiSetFixedStepSize(&rtM->solverInfo, 5.0E-6);
  rtsiSetSolverMode(&rtM->solverInfo, SOLVER_MODE_MULTITASKING);

  /* child S-Function registration */
  {
    RTWSfcnInfo *sfcnInfo = &rtM->NonInlinedSFcns.sfcnInfo;
    rtM->sfcnInfo = (sfcnInfo);
    rtssSetErrorStatusPtr(sfcnInfo, ((const char_T **)(&rtmGetErrorStatus(rtM))));
    rtssSetNumRootSampTimesPtr(sfcnInfo, &rtM->Sizes.numSampTimes);
    rtM->NonInlinedSFcns.taskTimePtrs[0] = &(rtmGetTPtr(rtM)[0]);
    rtM->NonInlinedSFcns.taskTimePtrs[1] = &(rtmGetTPtr(rtM)[1]);
    rtssSetTPtrPtr(sfcnInfo,rtM->NonInlinedSFcns.taskTimePtrs);
    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(rtM));
    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(rtM));
    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(rtM));
    rtssSetStepSizePtr(sfcnInfo, &rtM->Timing.stepSize);
    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(rtM));
    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &rtM->derivCacheNeedsReset);
    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &rtM->zCCacheNeedsReset);
    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,
      &rtM->CTOutputIncnstWithState);
    rtssSetSampleHitsPtr(sfcnInfo, &rtM->Timing.sampleHits);
    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &rtM->Timing.perTaskSampleHits);
    rtssSetSimModePtr(sfcnInfo, &rtM->simMode);
    rtssSetSolverInfoPtr(sfcnInfo, &rtM->solverInfoPtr);
  }

  rtM->Sizes.numSFcns = (93);

  /* register each child */
  {
    (void) memset((void *)&rtM->NonInlinedSFcns.childSFunctions[0], 0,
                  93*sizeof(SimStruct));
    rtM->childSfunctions = (&rtM->NonInlinedSFcns.childSFunctionPtrs[0]);

    {
      int_T i;
      for (i = 0; i < 93; i++) {
        rtM->childSfunctions[i] = (&rtM->NonInlinedSFcns.childSFunctions[i]);
      }
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S83>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[0];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn0.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn0.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn0.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[0]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[0]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[0]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[0]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[0]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[0]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[0]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn0.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn0.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn0.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn0.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_im;
          sfcnUPtrs[1] = &rtDW.Integ4_im[1];
          sfcnUPtrs[2] = &rtDW.Integ4_im[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn0.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn0.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn0.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn0.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_nt));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen 2L/PWMgen - Averaging/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn0.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hh);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_l2[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jk[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn0.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn0.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hh);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_l2[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jk[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S85>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[1];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn1.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn1.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn1.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[1]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[1]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[1]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[1]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[1]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[1]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[1]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn1.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn1.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn1.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn1.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_iy;
          sfcnUPtrs[1] = &rtDW.Integ4_iy[1];
          sfcnUPtrs[2] = &rtDW.Integ4_iy[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn1.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn1.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn1.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn1.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_id));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen 2L/PWMgen - Averaging/Mean3/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn1.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ov);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mqk[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nr[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn1.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn1.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ov);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mqk[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nr[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S111>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[2];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn2.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn2.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn2.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[2]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[2]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[2]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[2]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[2]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[2]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[2]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn2.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn2.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn2.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn2.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_md;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn2.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn2.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn2.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn2.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ap));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen 2Q/Subsystem/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn2.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hgx);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_fd);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_d2);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn2.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn2.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hgx);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_fd);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_d2);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S121>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[3];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn3.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn3.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn3.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[3]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[3]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[3]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[3]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[3]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[3]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[3]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn3.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn3.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn3.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn3.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_lh;
          sfcnUPtrs[1] = &rtDW.Integ4_lh[1];
          sfcnUPtrs[2] = &rtDW.Integ4_lh[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn3.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn3.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn3.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn3.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_bl));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen 3L/PWMgen - Averaging/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn3.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_me);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_iu[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hs[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn3.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn3.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_me);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_iu[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hs[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S123>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[4];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn4.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn4.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn4.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[4]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[4]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[4]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[4]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[4]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[4]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[4]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn4.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn4.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn4.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn4.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_fe;
          sfcnUPtrs[1] = &rtDW.Integ4_fe[1];
          sfcnUPtrs[2] = &rtDW.Integ4_fe[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn4.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn4.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn4.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn4.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_fj));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen 3L/PWMgen - Averaging/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn4.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_np);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_m1b[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bd[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn4.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn4.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_np);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_m1b[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bd[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S133>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[5];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn5.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn5.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn5.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[5]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[5]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[5]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[5]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[5]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[5]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[5]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn5.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn5.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn5.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn5.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_hv;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn5.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn5.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn5.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn5.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bv));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen Boost/PWM Gen/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn5.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nz1);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_pa);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_db);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn5.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn5.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nz1);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_pa);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_db);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S141>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[6];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn6.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn6.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn6.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[6]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[6]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[6]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[6]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[6]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[6]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[6]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn6.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn6.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn6.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn6.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_jx;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn6.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn6.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn6.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn6.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bi));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen Buck/PWM Gen/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn6.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_gs);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_khs);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_je);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn6.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn6.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_gs);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_khs);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_je);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S151>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[7];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn7.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn7.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn7.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[7]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[7]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[7]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[7]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[7]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[7]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[7]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn7.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn7.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn7.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn7.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn7.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn7.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn7.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn7.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_eh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen FB/PWM gen/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn7.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fn);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pv4);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn7.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn7.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fn);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pv4);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S153>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[8];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn8.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn8.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn8.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[8]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[8]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[8]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[8]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[8]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[8]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[8]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn8.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn8.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn8.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn8.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_jq;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn8.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn8.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn8.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn8.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_be1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen FB/PWM gen/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn8.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lp2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mt);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_c3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn8.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn8.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lp2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mt);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_c3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S169>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[9];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn9.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn9.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn9.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[9]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[9]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[9]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[9]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[9]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[9]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[9]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn9.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn9.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn9.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn9.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_l1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn9.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn9.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn9.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn9.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bz));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/PWM Gen HB/Subsystem/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn9.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h4);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_pe);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn9.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn9.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h4);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_pe);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S205>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[10];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn10.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn10.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn10.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[10]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[10]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[10]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[10]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[10]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[10]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[10]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn10.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn10.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn10.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn10.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_cu;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn10.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_ou;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn10.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn10.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn10.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_lp));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Rectifier Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn10.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_abb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_kh);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jd);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn10.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn10.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_abb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_kh);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jd);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S208>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[11];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn11.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn11.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn11.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[11]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[11]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[11]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[11]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[11]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[11]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[11]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn11.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn11.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn11.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn11.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dh0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn11.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_lg;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn11.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn11.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn11.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ca));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Rectifier Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn11.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_az);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_e3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_lw);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn11.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn11.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_az);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_e3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_lw);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S284>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[12];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn12.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn12.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn12.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[12]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[12]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[12]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[12]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[12]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[12]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[12]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn12.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn12.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn12.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn12.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_cs;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn12.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_f;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn12.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn12.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn12.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_d4));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Statcom Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn12.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_kk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_lz);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn12.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn12.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_kk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_lz);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S287>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[13];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn13.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn13.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn13.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[13]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[13]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[13]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[13]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[13]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[13]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[13]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn13.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn13.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn13.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn13.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ha;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn13.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_l;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn13.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn13.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn13.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_e5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Statcom Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn13.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_pl);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cl);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ft);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn13.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn13.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_pl);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cl);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ft);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S415>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[14];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn14.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn14.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn14.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[14]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[14]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[14]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[14]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[14]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[14]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[14]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn14.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn14.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn14.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn14.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn14.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn14.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn14.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn14.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn14.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn14.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn14.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S413>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[15];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn15.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn15.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn15.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[15]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[15]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[15]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[15]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[15]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[15]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[15]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn15.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn15.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn15.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn15.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_p;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn15.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn15.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn15.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn15.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn15.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_f);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_m);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_b);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn15.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn15.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_f);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_m);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_b);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S421>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[16];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn16.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn16.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn16.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[16]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[16]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[16]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[16]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[16]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[16]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[16]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn16.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn16.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn16.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn16.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_d;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn16.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn16.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn16.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn16.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_em));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn16.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_o);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_l);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_i);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn16.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn16.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_o);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_l);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_i);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S419>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[17];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn17.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn17.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn17.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[17]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[17]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[17]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[17]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[17]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[17]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[17]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn17.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn17.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn17.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn17.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_h;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn17.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn17.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn17.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn17.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn17.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_m);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_b);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn17.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn17.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_m);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_b);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S427>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[18];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn18.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn18.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn18.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[18]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[18]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[18]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[18]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[18]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[18]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[18]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn18.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn18.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn18.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn18.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_a;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn18.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn18.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn18.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn18.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn18.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_l);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_c);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_f);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn18.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn18.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_l);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_c);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_f);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S425>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[19];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn19.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn19.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn19.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[19]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[19]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[19]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[19]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[19]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[19]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[19]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn19.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn19.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn19.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn19.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_c;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn19.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn19.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn19.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn19.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn19.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_f2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bh);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bi);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn19.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn19.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_f2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bh);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bi);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S439>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[20];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn20.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn20.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn20.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[20]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[20]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[20]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[20]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[20]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[20]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[20]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn20.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn20.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn20.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn20.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ae;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn20.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn20.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn20.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn20.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn20.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_n);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_e);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_o);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn20.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn20.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_n);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_e);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_o);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S437>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[21];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn21.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn21.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn21.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[21]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[21]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[21]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[21]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[21]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[21]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[21]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn21.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn21.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn21.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn21.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_k;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn21.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn21.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn21.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn21.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn21.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_p);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_a);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bf);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn21.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn21.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_p);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_a);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bf);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S445>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[22];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn22.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn22.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn22.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[22]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[22]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[22]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[22]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[22]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[22]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[22]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn22.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn22.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn22.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn22.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dh;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn22.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn22.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn22.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn22.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn22.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_j);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_at);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_a);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn22.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn22.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_j);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_at);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_a);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S443>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[23];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn23.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn23.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn23.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[23]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[23]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[23]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[23]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[23]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[23]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[23]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn23.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn23.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn23.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn23.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_b;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn23.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn23.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn23.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn23.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gi));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn23.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ps);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_n);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_j);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn23.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn23.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ps);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_n);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_j);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S451>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[24];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn24.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn24.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn24.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[24]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[24]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[24]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[24]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[24]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[24]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[24]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn24.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn24.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn24.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn24.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_hq;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn24.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn24.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn24.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn24.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_lu));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn24.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_la);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_li);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_m);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn24.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn24.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_la);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_li);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_m);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S449>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[25];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn25.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn25.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn25.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[25]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[25]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[25]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[25]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[25]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[25]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[25]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn25.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn25.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn25.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn25.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_j;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn25.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn25.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn25.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn25.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_hd));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn25.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_o4);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_k);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fu);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn25.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn25.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_o4);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_k);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fu);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S790>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[26];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn26.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn26.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn26.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[26]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[26]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[26]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[26]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[26]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[26]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[26]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn26.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn26.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn26.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn26.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_f;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn26.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn26.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn26.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn26.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ez));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/V1 meas/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn26.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_i);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_j);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ii);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn26.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn26.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_i);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_j);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ii);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S788>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[27];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn27.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn27.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn27.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[27]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[27]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[27]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[27]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[27]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[27]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[27]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn27.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn27.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn27.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn27.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_aa;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn27.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn27.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn27.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn27.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/V1 meas/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn27.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_b);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_lt);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ib);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn27.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn27.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_b);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_lt);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ib);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S796>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[28];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn28.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn28.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn28.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[28]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[28]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[28]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[28]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[28]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[28]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[28]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn28.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn28.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn28.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn28.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_f0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn28.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn28.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn28.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn28.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_dm));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/V1 meas/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn28.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_k0);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_at);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn28.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn28.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_k0);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_at);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S794>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[29];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn29.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn29.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn29.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[29]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[29]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[29]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[29]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[29]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[29]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[29]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn29.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn29.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn29.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn29.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_i;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn29.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn29.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn29.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn29.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gs));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/V1 meas/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn29.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_g);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mp);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_og);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn29.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn29.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_g);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mp);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_og);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S802>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[30];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn30.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn30.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn30.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[30]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[30]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[30]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[30]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[30]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[30]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[30]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn30.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn30.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn30.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn30.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_l;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn30.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn30.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn30.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn30.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_dy));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/V1 meas/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn30.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_jh);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_af);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn30.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn30.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_jh);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_af);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S800>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[31];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn31.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn31.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn31.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[31]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[31]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[31]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[31]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[31]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[31]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[31]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn31.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn31.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn31.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn31.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_g;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn31.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn31.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn31.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn31.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/V1 meas/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn31.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hg);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_o);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ac);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn31.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn31.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hg);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_o);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ac);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S381>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[32];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn32.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn32.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn32.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[32]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[32]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[32]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[32]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[32]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[32]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[32]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn32.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn32.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn32.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn32.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn32.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn32.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn32.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn32.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn32.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fx);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_i);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_g);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn32.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn32.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fx);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_i);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_g);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S383>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[33];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn33.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn33.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn33.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[33]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[33]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[33]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[33]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[33]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[33]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[33]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn33.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn33.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn33.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn33.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_fr;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn33.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn33.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn33.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn33.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ct));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn33.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_n0);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ci);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_oa);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn33.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn33.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_n0);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ci);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_oa);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S385>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[34];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn34.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn34.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn34.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[34]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[34]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[34]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[34]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[34]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[34]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[34]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn34.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn34.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn34.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn34.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mt;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn34.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn34.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn34.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn34.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn34.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_d);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_h);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_m3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn34.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn34.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_d);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_h);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_m3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S387>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[35];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn35.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn35.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn35.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[35]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[35]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[35]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[35]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[35]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[35]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[35]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn35.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn35.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn35.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn35.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ge;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn35.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled69;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn35.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn35.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn35.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Mean3/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn35.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled70);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nd);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_os);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_e);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn35.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn35.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nd);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_os);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_e);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S395>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[36];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn36.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn36.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn36.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[36]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[36]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[36]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[36]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[36]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[36]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[36]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn36.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn36.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn36.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn36.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_lf;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn36.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn36.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn36.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn36.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power/Fourier/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn36.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_pe);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_f);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_c);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn36.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn36.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_pe);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_f);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_c);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S393>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[37];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn37.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn37.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn37.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[37]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[37]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[37]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[37]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[37]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[37]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[37]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn37.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn37.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn37.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn37.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_bp;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn37.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn37.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn37.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn37.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c5r));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power/Fourier/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn37.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_a);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ow);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ki);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn37.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn37.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_a);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ow);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ki);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S401>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[38];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn38.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn38.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn38.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[38]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[38]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[38]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[38]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[38]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[38]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[38]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn38.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn38.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn38.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn38.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_n;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn38.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn38.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn38.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn38.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_h1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power/Fourier1/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn38.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lf);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ny);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_p);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn38.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn38.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lf);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ny);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_p);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S399>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[39];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn39.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn39.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn39.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[39]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[39]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[39]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[39]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[39]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[39]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[39]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn39.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn39.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn39.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn39.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_o;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn39.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn39.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn39.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn39.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power/Fourier1/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn39.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_e);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_my);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_h);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn39.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn39.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_e);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_my);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_h);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S465>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[40];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn40.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn40.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn40.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[40]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[40]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[40]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[40]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[40]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[40]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[40]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn40.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn40.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn40.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn40.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mta;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn40.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn40.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn40.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn40.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn40.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h1);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_d);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_l);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn40.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn40.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h1);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_d);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_l);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S463>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[41];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn41.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn41.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn41.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[41]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[41]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[41]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[41]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[41]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[41]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[41]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn41.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn41.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn41.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn41.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_oc;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn41.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn41.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn41.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn41.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ge));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn41.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_k);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_d4);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ml);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn41.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn41.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_k);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_d4);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ml);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S471>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[42];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn42.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn42.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn42.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[42]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[42]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[42]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[42]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[42]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[42]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[42]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn42.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn42.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn42.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn42.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_do;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn42.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn42.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn42.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn42.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_jm));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn42.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_mo);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_g);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k4);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn42.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn42.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_mo);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_g);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k4);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S469>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[43];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn43.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn43.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn43.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[43]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[43]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[43]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[43]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[43]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[43]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[43]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn43.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn43.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn43.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn43.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nk;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn43.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn43.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn43.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn43.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_et));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn43.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_mn);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ip);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_kd);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn43.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn43.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_mn);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ip);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_kd);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S477>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[44];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn44.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn44.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn44.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[44]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[44]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[44]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[44]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[44]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[44]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[44]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn44.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn44.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn44.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn44.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pl;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn44.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn44.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn44.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn44.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ko));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn44.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fu);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_gi);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ge);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn44.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn44.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fu);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_gi);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ge);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S475>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[45];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn45.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn45.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn45.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[45]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[45]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[45]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[45]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[45]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[45]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[45]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn45.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn45.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn45.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn45.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nkx;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn45.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn45.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn45.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn45.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ey));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn45.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_eb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_eq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_by);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn45.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn45.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_eb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_eq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_by);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S489>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[46];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn46.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn46.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn46.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[46]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[46]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[46]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[46]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[46]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[46]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[46]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn46.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn46.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn46.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn46.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mr;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn46.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn46.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn46.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn46.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_iz));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn46.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_mi);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ln);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_d);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn46.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn46.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_mi);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ln);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_d);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S487>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[47];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn47.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn47.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn47.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[47]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[47]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[47]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[47]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[47]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[47]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[47]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn47.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn47.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn47.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn47.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dg;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn47.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn47.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn47.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn47.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ff));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn47.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_eu);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_od);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_f3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn47.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn47.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_eu);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_od);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_f3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S495>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[48];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn48.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn48.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn48.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[48]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[48]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[48]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[48]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[48]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[48]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[48]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn48.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn48.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn48.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn48.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_e;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn48.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn48.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn48.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn48.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn48.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_db);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nf);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hm);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn48.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn48.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_db);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nf);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hm);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S493>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[49];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn49.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn49.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn49.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[49]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[49]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[49]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[49]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[49]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[49]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[49]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn49.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn49.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn49.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn49.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_g4;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn49.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn49.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn49.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn49.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gv));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn49.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_kh);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_hg);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_m4);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn49.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn49.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_kh);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_hg);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_m4);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S501>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[50];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn50.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn50.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn50.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[50]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[50]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[50]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[50]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[50]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[50]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[50]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn50.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn50.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn50.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn50.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ao;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn50.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn50.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn50.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn50.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_l5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn50.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ok);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_hn);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn50.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn50.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ok);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_hn);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S499>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[51];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn51.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn51.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn51.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[51]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[51]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[51]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[51]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[51]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[51]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[51]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn51.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn51.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn51.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn51.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mk;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn51.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn51.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn51.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn51.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gy));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn51.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_c);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_av);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_lp);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn51.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn51.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_c);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_av);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_lp);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S269>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[52];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn52.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn52.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn52.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[52]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[52]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[52]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[52]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[52]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[52]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[52]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn52.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn52.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn52.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn52.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_j0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn52.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.K1_Value;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn52.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn52.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn52.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Statcom Control System/Iq_ref generation/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn52.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.SFunction_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fc);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cv);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fi);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn52.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn52.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fc);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cv);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fi);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S300>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[53];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn53.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn53.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn53.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[53]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[53]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[53]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[53]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[53]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[53]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[53]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn53.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn53.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn53.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn53.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ll;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn53.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn53.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn53.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn53.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ia));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Statcom Control System/Measurements/PLL (3ph)/Model/Variable Frequency Mean value/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn53.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ks);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nz);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_gw);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn53.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn53.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ks);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nz);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_gw);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S221>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[54];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn54.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn54.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn54.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[54]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[54]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[54]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[54]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[54]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[54]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[54]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn54.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn54.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn54.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn54.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nt;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn54.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_o;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn54.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn54.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn54.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gd));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Control Systems/Rectifier Control System/Measurements/PLL (3ph)/Model/Variable Frequency Mean value/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn54.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_io);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_g3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_n);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn54.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn54.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_io);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_g3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_n);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S517>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[55];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn55.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn55.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn55.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[55]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[55]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[55]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[55]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[55]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[55]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[55]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn55.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn55.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn55.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn55.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_c1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn55.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled69;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn55.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn55.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn55.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_b5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Mean3/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn55.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled70);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_g0);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_g2);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_eq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn55.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn55.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_g0);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_g2);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_eq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S593>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[56];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn56.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn56.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn56.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[56]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[56]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[56]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[56]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[56]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[56]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[56]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn56.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn56.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn56.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn56.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_is;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn56.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn56.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn56.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn56.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_do));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn56.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_md);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bfq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn56.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn56.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_md);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bfq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S595>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[57];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn57.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn57.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn57.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[57]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[57]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[57]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[57]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[57]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[57]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[57]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn57.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn57.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn57.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn57.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_np;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn57.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn57.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn57.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn57.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ks));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn57.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_k3);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_lg);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ll);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn57.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn57.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_k3);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_lg);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ll);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S599>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[58];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn58.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn58.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn58.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[58]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[58]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[58]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[58]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[58]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[58]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[58]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn58.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn58.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn58.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn58.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nw;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn58.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn58.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn58.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn58.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_kof));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn58.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_dl);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cj);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ky);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn58.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn58.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_dl);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cj);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ky);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S601>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[59];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn59.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn59.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn59.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[59]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[59]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[59]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[59]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[59]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[59]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[59]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn59.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn59.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn59.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn59.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pz;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn59.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn59.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn59.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn59.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_oc));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn59.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nq);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_jj);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cy);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn59.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn59.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nq);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_jj);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cy);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S605>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[60];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn60.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn60.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn60.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[60]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[60]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[60]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[60]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[60]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[60]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[60]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn60.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn60.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn60.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn60.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_i0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn60.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn60.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn60.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn60.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ok));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn60.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hw);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_e1);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cu);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn60.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn60.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hw);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_e1);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cu);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S607>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[61];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn61.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn61.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn61.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[61]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[61]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[61]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[61]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[61]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[61]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[61]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn61.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn61.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn61.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn61.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_j1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn61.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn61.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn61.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn61.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_i1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn61.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_jg);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ll);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pj);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn61.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn61.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_jg);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ll);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pj);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S617>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[62];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn62.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn62.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn62.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[62]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[62]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[62]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[62]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[62]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[62]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[62]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn62.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn62.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn62.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn62.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_di;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn62.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn62.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn62.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn62.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_fd));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn62.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_pu);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_k2);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn62.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn62.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_pu);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_k2);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S619>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[63];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn63.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn63.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn63.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[63]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[63]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[63]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[63]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[63]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[63]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[63]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn63.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn63.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn63.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn63.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dd;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn63.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn63.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn63.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn63.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ig));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn63.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ku);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_gn);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn63.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn63.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ku);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_gn);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S623>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[64];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn64.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn64.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn64.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[64]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[64]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[64]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[64]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[64]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[64]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[64]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn64.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn64.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn64.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn64.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_a3;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn64.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn64.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn64.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn64.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_jc));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn64.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_kw);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nt);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn64.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn64.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_kw);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nt);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S625>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[65];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn65.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn65.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn65.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[65]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[65]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[65]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[65]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[65]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[65]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[65]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn65.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn65.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn65.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn65.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_lc;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn65.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn65.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn65.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn65.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn65.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ii);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bo);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nk);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn65.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn65.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ii);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bo);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nk);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S629>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[66];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn66.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn66.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn66.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[66]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[66]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[66]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[66]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[66]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[66]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[66]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn66.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn66.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn66.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn66.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_hp;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn66.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn66.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn66.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn66.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_cu));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn66.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_os);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_o3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jf);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn66.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn66.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_os);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_o3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jf);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S631>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[67];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn67.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn67.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn67.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[67]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[67]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[67]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[67]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[67]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[67]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[67]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn67.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn67.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn67.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn67.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ce;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn67.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn67.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn67.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn67.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ck));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn67.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_l2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ht);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ag);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn67.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn67.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_l2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ht);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ag);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S523>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[68];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn68.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn68.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn68.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[68]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[68]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[68]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[68]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[68]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[68]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[68]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn68.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn68.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn68.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn68.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mu;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn68.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn68.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn68.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn68.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_me));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power/Fourier/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn68.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ez);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ba);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cc);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn68.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn68.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ez);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ba);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cc);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S525>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[69];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn69.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn69.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn69.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[69]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[69]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[69]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[69]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[69]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[69]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[69]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn69.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn69.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn69.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn69.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ddm;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn69.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn69.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn69.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn69.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_mk));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power/Fourier/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn69.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h3);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_p);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ea);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn69.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn69.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h3);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_p);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ea);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S529>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[70];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn70.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn70.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn70.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[70]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[70]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[70]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[70]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[70]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[70]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[70]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn70.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn70.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn70.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn70.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn70.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn70.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn70.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn70.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_i11));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power/Fourier1/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn70.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_bg);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_da);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bh);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn70.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn70.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_bg);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_da);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bh);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S531>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[71];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn71.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn71.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn71.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[71]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[71]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[71]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[71]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[71]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[71]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[71]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn71.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn71.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn71.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn71.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nr;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn71.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn71.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn71.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn71.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ib));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power/Fourier1/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn71.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_jq);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_m1);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fn);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn71.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn71.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_jq);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_m1);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fn);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S543>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[72];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn72.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn72.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn72.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[72]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[72]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[72]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[72]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[72]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[72]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[72]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn72.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn72.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn72.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn72.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ab;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn72.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn72.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn72.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn72.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_kf));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn72.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_dv);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bz);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_km);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn72.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn72.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_dv);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bz);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_km);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S545>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[73];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn73.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn73.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn73.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[73]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[73]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[73]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[73]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[73]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[73]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[73]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn73.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn73.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn73.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn73.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_cc;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn73.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn73.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn73.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn73.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_nj));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn73.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_g0s);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_llq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pi);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn73.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn73.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_g0s);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_llq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pi);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S549>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[74];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn74.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn74.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn74.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[74]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[74]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[74]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[74]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[74]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[74]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[74]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn74.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn74.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn74.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn74.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m3;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn74.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn74.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn74.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn74.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ix));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn74.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_be);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ks);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k4k);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn74.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn74.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_be);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ks);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k4k);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S551>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[75];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn75.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn75.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn75.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[75]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[75]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[75]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[75]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[75]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[75]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[75]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn75.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn75.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn75.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn75.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ocz;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn75.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn75.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn75.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn75.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_b3));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn75.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ab);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_gl);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ju);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn75.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn75.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ab);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_gl);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ju);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S555>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[76];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn76.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn76.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn76.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[76]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[76]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[76]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[76]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[76]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[76]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[76]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn76.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn76.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn76.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn76.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_frw;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn76.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn76.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn76.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn76.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_be));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn76.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_cp);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ik);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_kx);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn76.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn76.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_cp);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ik);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_kx);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S557>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[77];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn77.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn77.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn77.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[77]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[77]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[77]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[77]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[77]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[77]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[77]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn77.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn77.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn77.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn77.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ah;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn77.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn77.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn77.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn77.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_cs));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn77.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_i2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cd);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_j3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn77.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn77.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_i2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cd);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_j3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S567>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[78];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn78.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn78.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn78.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[78]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[78]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[78]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[78]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[78]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[78]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[78]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn78.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn78.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn78.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn78.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_jz;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn78.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn78.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn78.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn78.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_kz));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn78.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lp);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_a3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_dd);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn78.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn78.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lp);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_a3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_dd);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S569>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[79];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn79.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn79.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn79.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[79]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[79]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[79]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[79]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[79]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[79]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[79]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn79.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn79.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn79.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn79.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_oe;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn79.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn79.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn79.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn79.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ns));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn79.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ct);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nzb);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_p2);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn79.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn79.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ct);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nzb);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_p2);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S573>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[80];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn80.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn80.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn80.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[80]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[80]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[80]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[80]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[80]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[80]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[80]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn80.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn80.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn80.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn80.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ea;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn80.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn80.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn80.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn80.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_f3));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn80.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_kb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_l3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pw);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn80.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn80.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_kb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_l3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pw);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S575>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[81];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn81.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn81.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn81.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[81]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[81]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[81]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[81]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[81]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[81]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[81]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn81.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn81.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn81.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn81.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_no;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn81.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn81.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn81.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn81.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_hx));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn81.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nz);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_gw);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_dh);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn81.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn81.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nz);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_gw);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_dh);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S579>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[82];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn82.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn82.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn82.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[82]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[82]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[82]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[82]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[82]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[82]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[82]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn82.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn82.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn82.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn82.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ex;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn82.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn82.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn82.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn82.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn82.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hp);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cs);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn82.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn82.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hp);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cs);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S581>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[83];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn83.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn83.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn83.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[83]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[83]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[83]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[83]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[83]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[83]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[83]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn83.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn83.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn83.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn83.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ij;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn83.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn83.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn83.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn83.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_mr));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn83.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ay);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_oh);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_n5);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn83.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn83.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ay);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_oh);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_n5);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S641>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[84];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn84.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn84.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn84.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[84]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[84]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[84]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[84]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[84]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[84]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[84]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn84.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn84.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn84.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn84.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_fg;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn84.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn84.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn84.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn84.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_j4));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/V1 meas/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn84.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nv);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_i5);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_dx);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn84.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn84.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nv);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_i5);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_dx);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S643>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[85];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn85.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn85.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn85.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[85]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[85]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[85]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[85]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[85]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[85]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[85]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn85.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn85.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn85.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn85.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_kv;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn85.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn85.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn85.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn85.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/V1 meas/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn85.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fc1);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nc);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ce);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn85.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn85.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fc1);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nc);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ce);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S647>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[86];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn86.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn86.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn86.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[86]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[86]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[86]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[86]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[86]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[86]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[86]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn86.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn86.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn86.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn86.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ks;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn86.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn86.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn86.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn86.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_h1o));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/V1 meas/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn86.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_dva);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ed);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fnk);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn86.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn86.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_dva);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ed);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fnk);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S649>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[87];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn87.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn87.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn87.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[87]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[87]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[87]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[87]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[87]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[87]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[87]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn87.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn87.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn87.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn87.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dl;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn87.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn87.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn87.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn87.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ds));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/V1 meas/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn87.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ox);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_avv);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn87.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn87.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ox);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_avv);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S653>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[88];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn88.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn88.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn88.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[88]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[88]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[88]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[88]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[88]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[88]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[88]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn88.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn88.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn88.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn88.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_kd;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn88.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn88.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn88.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn88.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_in));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/V1 meas/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn88.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_bj);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k41);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn88.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn88.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_bj);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k41);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S655>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[89];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn89.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn89.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn89.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[89]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[89]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[89]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[89]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[89]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[89]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[89]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn89.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn89.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn89.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn89.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_id;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn89.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn89.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn89.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn89.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ev));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/V1 meas/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn89.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lr);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_dk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bfb);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn89.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn89.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lr);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_dk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bfb);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S515>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[90];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn90.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn90.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn90.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[90]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[90]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[90]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[90]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[90]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[90]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[90]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn90.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn90.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn90.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn90.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ddl;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn90.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn90.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn90.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn90.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ga));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn90.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_e3);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_aa);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_kq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn90.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn90.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_e3);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_aa);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_kq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S511>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[91];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn91.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn91.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn91.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[91]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[91]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[91]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[91]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[91]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[91]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[91]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn91.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn91.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn91.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn91.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pt;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn91.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn91.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn91.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn91.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_lh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn91.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fch);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_f3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn91.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn91.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fch);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_f3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_devices/<S513>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[92];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn92.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn92.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn92.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[92]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[92]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[92]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[92]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[92]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[92]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[92]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn92.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn92.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn92.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn92.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pf;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn92.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled59;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn92.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn92.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn92.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_p2));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_devices/Scopes/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn92.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled60);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lq);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_hj);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_n1);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn92.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn92.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lq);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_hj);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_n1);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }
  }

  /* Start for S-Function (sfun_spssw_discc): '<S830>/State-Space' incorporates:
   *  Constant: '<S342>/DC'
   */

  /* S-Function block: <S830>/State-Space */
  {
    rtDW.StateSpace_PWORK.AS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.BS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.CS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.DS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.DX_COL = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.TMP2 = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.BD_COL = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.TMP1 = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.XTMP = (real_T*)calloc(1, sizeof(real_T));
  }

  /* Start for S-Function (sfun_spssw_discc): '<S831>/State-Space' incorporates:
   *  Constant: '<S343>/DC'
   *  Constant: '<S835>/SwitchCurrents'
   */

  /* S-Function block: <S831>/State-Space */
  {
    rtDW.StateSpace_PWORK_n.AS = (real_T*)calloc(40 * 40, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.BS = (real_T*)calloc(40 * 48, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.CS = (real_T*)calloc(71 * 40, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.DS = (real_T*)calloc(71 * 48, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.DX_COL = (real_T*)calloc(71, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.TMP2 = (real_T*)calloc(48, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.BD_COL = (real_T*)calloc(40, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.TMP1 = (real_T*)calloc(40, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.XTMP = (real_T*)calloc(40, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.SWITCH_STATUS = (int_T*)calloc(42, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.SW_CHG = (int_T*)calloc(42, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.G_STATE = (int_T*)calloc(42, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.Y_SWITCH = (real_T*)calloc(42, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.SWITCH_TYPES = (int_T*)calloc(42, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.IDX_OUT_SW = (int_T*)calloc(42, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.SWITCH_STATUS_INIT = (int_T*)calloc(42, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.USWLAST = (real_T*)calloc(42, sizeof(real_T));
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */
  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */
  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S421>/S-Function' incorporates:
   *  Constant: '<S420>/K1'
   */
  /* Level2 S-Function Block: '<S421>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S419>/S-Function' incorporates:
   *  Constant: '<S418>/K1'
   */
  /* Level2 S-Function Block: '<S419>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S427>/S-Function' incorporates:
   *  Constant: '<S426>/K1'
   */
  /* Level2 S-Function Block: '<S427>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */
  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S439>/S-Function' incorporates:
   *  Constant: '<S438>/K1'
   */
  /* Level2 S-Function Block: '<S439>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S437>/S-Function' incorporates:
   *  Constant: '<S436>/K1'
   */
  /* Level2 S-Function Block: '<S437>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */
  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */
  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */
  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */
  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S790>/S-Function' incorporates:
   *  Constant: '<S789>/K1'
   */
  /* Level2 S-Function Block: '<S790>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S788>/S-Function' incorporates:
   *  Constant: '<S787>/K1'
   */
  /* Level2 S-Function Block: '<S788>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S796>/S-Function' incorporates:
   *  Constant: '<S795>/K1'
   */
  /* Level2 S-Function Block: '<S796>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S794>/S-Function' incorporates:
   *  Constant: '<S793>/K1'
   */
  /* Level2 S-Function Block: '<S794>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S802>/S-Function' incorporates:
   *  Constant: '<S801>/K1'
   */
  /* Level2 S-Function Block: '<S802>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S800>/S-Function' incorporates:
   *  Constant: '<S799>/K1'
   */
  /* Level2 S-Function Block: '<S800>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S381>/S-Function' incorporates:
   *  Constant: '<S380>/K1'
   */
  /* Level2 S-Function Block: '<S381>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S383>/S-Function' incorporates:
   *  Constant: '<S382>/K1'
   */
  /* Level2 S-Function Block: '<S383>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S385>/S-Function' incorporates:
   *  Constant: '<S384>/K1'
   */
  /* Level2 S-Function Block: '<S385>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S387>/S-Function' incorporates:
   *  Constant: '<S386>/K1'
   */
  /* Level2 S-Function Block: '<S387>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S395>/S-Function' incorporates:
   *  Constant: '<S394>/K1'
   */
  /* Level2 S-Function Block: '<S395>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S393>/S-Function' incorporates:
   *  Constant: '<S392>/K1'
   */
  /* Level2 S-Function Block: '<S393>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S401>/S-Function' incorporates:
   *  Constant: '<S400>/K1'
   */
  /* Level2 S-Function Block: '<S401>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S399>/S-Function' incorporates:
   *  Constant: '<S398>/K1'
   */
  /* Level2 S-Function Block: '<S399>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S465>/S-Function' incorporates:
   *  Constant: '<S464>/K1'
   */
  /* Level2 S-Function Block: '<S465>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S463>/S-Function' incorporates:
   *  Constant: '<S462>/K1'
   */
  /* Level2 S-Function Block: '<S463>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S471>/S-Function' incorporates:
   *  Constant: '<S470>/K1'
   */
  /* Level2 S-Function Block: '<S471>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */
  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S477>/S-Function' incorporates:
   *  Constant: '<S476>/K1'
   */
  /* Level2 S-Function Block: '<S477>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */
  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S489>/S-Function' incorporates:
   *  Constant: '<S488>/K1'
   */
  /* Level2 S-Function Block: '<S489>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S487>/S-Function' incorporates:
   *  Constant: '<S486>/K1'
   */
  /* Level2 S-Function Block: '<S487>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */
  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */
  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */
  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */
  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for InitialCondition: '<S193>/Initial' */
  rtDW.Initial_FirstOutputTime = true;

  /* Start for InitialCondition: '<S272>/Initial' */
  rtDW.Initial_FirstOutputTime_m = true;

  /* Start for S-Function (sfun_discreteVariableDelay): '<S269>/S-Function' incorporates:
   *  Constant: '<S268>/K1'
   */
  /* Level2 S-Function Block: '<S269>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for RateTransition: '<S63>/Rate Transition2' */
  rtDW.RateTransition2 = 0.7;

  /* Start for Enabled SubSystem: '<S67>/PWM Gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */
  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S67>/PWM Gen' */

  /* Start for Enabled SubSystem: '<S68>/PWM Gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S141>/S-Function' incorporates:
   *  Constant: '<S140>/K1'
   */
  /* Level2 S-Function Block: '<S141>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S68>/PWM Gen' */

  /* Start for Enabled SubSystem: '<S64>/PWMgen - Averaging' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S83>/S-Function' incorporates:
   *  Constant: '<S82>/K1'
   */
  /* Level2 S-Function Block: '<S83>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S85>/S-Function' incorporates:
   *  Constant: '<S84>/K1'
   */
  /* Level2 S-Function Block: '<S85>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S64>/PWMgen - Averaging' */

  /* Start for Enabled SubSystem: '<S272>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S284>/S-Function' */
  /* Level2 S-Function Block: '<S284>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S287>/S-Function' */
  /* Level2 S-Function Block: '<S287>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S272>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S300>/S-Function' */
  /* Level2 S-Function Block: '<S300>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for Enabled SubSystem: '<S65>/Subsystem' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S111>/S-Function' incorporates:
   *  Constant: '<S110>/K1'
   */
  /* Level2 S-Function Block: '<S111>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S65>/Subsystem' */

  /* Start for Enabled SubSystem: '<S66>/PWMgen - Averaging' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S121>/S-Function' incorporates:
   *  Constant: '<S120>/K1'
   */
  /* Level2 S-Function Block: '<S121>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */
  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S66>/PWMgen - Averaging' */

  /* Start for Enabled SubSystem: '<S193>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S205>/S-Function' */
  /* Level2 S-Function Block: '<S205>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S208>/S-Function' */
  /* Level2 S-Function Block: '<S208>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S193>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S221>/S-Function' */
  /* Level2 S-Function Block: '<S221>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for Enabled SubSystem: '<S70>/Subsystem' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S169>/S-Function' incorporates:
   *  Constant: '<S168>/K1'
   */
  /* Level2 S-Function Block: '<S169>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S70>/Subsystem' */

  /* Start for Enabled SubSystem: '<S69>/PWM gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S151>/S-Function' incorporates:
   *  Constant: '<S150>/K1'
   */
  /* Level2 S-Function Block: '<S151>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */
  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S69>/PWM gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */
  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S593>/S-Function' incorporates:
   *  Constant: '<S592>/K1'
   */
  /* Level2 S-Function Block: '<S593>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S595>/S-Function' incorporates:
   *  Constant: '<S594>/K1'
   */
  /* Level2 S-Function Block: '<S595>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */
  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S601>/S-Function' incorporates:
   *  Constant: '<S600>/K1'
   */
  /* Level2 S-Function Block: '<S601>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */
  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S607>/S-Function' incorporates:
   *  Constant: '<S606>/K1'
   */
  /* Level2 S-Function Block: '<S607>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S617>/S-Function' incorporates:
   *  Constant: '<S616>/K1'
   */
  /* Level2 S-Function Block: '<S617>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S619>/S-Function' incorporates:
   *  Constant: '<S618>/K1'
   */
  /* Level2 S-Function Block: '<S619>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */
  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */
  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */
  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */
  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */
  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */
  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */
  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */
  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */
  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */
  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S549>/S-Function' incorporates:
   *  Constant: '<S548>/K1'
   */
  /* Level2 S-Function Block: '<S549>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S551>/S-Function' incorporates:
   *  Constant: '<S550>/K1'
   */
  /* Level2 S-Function Block: '<S551>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */
  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S557>/S-Function' incorporates:
   *  Constant: '<S556>/K1'
   */
  /* Level2 S-Function Block: '<S557>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S567>/S-Function' incorporates:
   *  Constant: '<S566>/K1'
   */
  /* Level2 S-Function Block: '<S567>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S569>/S-Function' incorporates:
   *  Constant: '<S568>/K1'
   */
  /* Level2 S-Function Block: '<S569>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */
  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */
  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */
  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */
  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S641>/S-Function' incorporates:
   *  Constant: '<S640>/K1'
   */
  /* Level2 S-Function Block: '<S641>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S643>/S-Function' incorporates:
   *  Constant: '<S642>/K1'
   */
  /* Level2 S-Function Block: '<S643>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */
  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */
  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */
  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */
  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S515>/S-Function' incorporates:
   *  Constant: '<S514>/K1'
   */
  /* Level2 S-Function Block: '<S515>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S511>/S-Function' incorporates:
   *  Constant: '<S510>/K1'
   */
  /* Level2 S-Function Block: '<S511>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S513>/S-Function' incorporates:
   *  Constant: '<S512>/K1'
   */
  /* Level2 S-Function Block: '<S513>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_spssw_discc): '<S830>/State-Space' incorporates:
   *  Constant: '<S342>/DC'
   */
  {
    int32_T i, j;
    real_T *As = (real_T*)rtDW.StateSpace_PWORK.AS;
    real_T *Bs = (real_T*)rtDW.StateSpace_PWORK.BS;
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK.DS;
    real_T *X0 = (real_T*)&rtDW.StateSpace_DSTATE;
    for (i = 0; i < 1; i++) {
      X0[i] = 500001.56250000012;
    }

    /* Copy and transpose A and B */
    for (i=0; i<1; i++) {
      for (j=0; j<1; j++)
        As[i*1 + j] = 0.99999375001953117;
      for (j=0; j<1; j++)
        Bs[i*1 + j] = 0.0062499804688110347;
    }

    /* Copy and transpose C */
    for (i=0; i<1; i++) {
      for (j=0; j<1; j++)
        Cs[i*1 + j] = 4.9999843750488282E-6;
    }

    /* Copy and transpose D */
    for (i=0; i<1; i++) {
      for (j=0; j<1; j++)
        Ds[i*1 + j] = 1.5624951172027588E-8;
    }
  }

  /* InitializeConditions for DiscreteIntegrator: '<S334>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE = 125.66370614359172;

  /* InitializeConditions for UnitDelay: '<S334>/KE filter' */
  rtDW.KEfilter_DSTATE = 2.5;

  /* InitializeConditions for S-Function (sfun_spssw_discc): '<S831>/State-Space' incorporates:
   *  Constant: '<S343>/DC'
   *  Constant: '<S835>/SwitchCurrents'
   */
  {
    int32_T i, j;
    real_T *As = (real_T*)rtDW.StateSpace_PWORK_n.AS;
    real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_n.BS;
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;
    real_T *X0 = (real_T*)&rtDW.StateSpace_DSTATE_d[0];
    for (i = 0; i < 40; i++) {
      X0[i] = (rtConstP.StateSpace_X0_param_o[i]);
    }

    /* Copy and transpose A and B */
    for (i=0; i<40; i++) {
      for (j=0; j<40; j++)
        As[i*40 + j] = (rtConstP.StateSpace_AS_param_h[i + j*40]);
      for (j=0; j<48; j++)
        Bs[i*48 + j] = (rtConstP.StateSpace_BS_param_k[i + j*40]);
    }

    /* Copy and transpose C */
    for (i=0; i<71; i++) {
      for (j=0; j<40; j++)
        Cs[i*40 + j] = (rtConstP.StateSpace_CS_param_i[i + j*71]);
    }

    /* Copy and transpose D */
    for (i=0; i<71; i++) {
      for (j=0; j<48; j++)
        Ds[i*48 + j] = (rtConstP.StateSpace_DS_param_f[i + j*71]);
    }

    {
      /* Switches work vectors */
      int_T *switch_status = (int_T*) rtDW.StateSpace_PWORK_n.SWITCH_STATUS;
      int_T *gState = (int_T*)rtDW.StateSpace_PWORK_n.G_STATE;
      real_T *yswitch = (real_T*)rtDW.StateSpace_PWORK_n.Y_SWITCH;
      int_T *switchTypes = (int_T*)rtDW.StateSpace_PWORK_n.SWITCH_TYPES;
      int_T *idxOutSw = (int_T*)rtDW.StateSpace_PWORK_n.IDX_OUT_SW;
      int_T *switch_status_init = (int_T*)
        rtDW.StateSpace_PWORK_n.SWITCH_STATUS_INIT;

      /* Initialize work vectors */
      switch_status[0] = 0;
      switch_status_init[0] = 0;
      gState[0] = (int_T) 0.0;
      yswitch[0] = 1/0.001;
      switchTypes[0] = (int_T)3.0;
      idxOutSw[0] = ((int_T)0.0) - 1;
      switch_status[1] = 0;
      switch_status_init[1] = 0;
      gState[1] = (int_T) 0.0;
      yswitch[1] = 1/0.001;
      switchTypes[1] = (int_T)3.0;
      idxOutSw[1] = ((int_T)0.0) - 1;
      switch_status[2] = 0;
      switch_status_init[2] = 0;
      gState[2] = (int_T) 0.0;
      yswitch[2] = 1/0.001;
      switchTypes[2] = (int_T)3.0;
      idxOutSw[2] = ((int_T)0.0) - 1;
      switch_status[3] = 0;
      switch_status_init[3] = 0;
      gState[3] = (int_T) 0.0;
      yswitch[3] = 1/0.001;
      switchTypes[3] = (int_T)3.0;
      idxOutSw[3] = ((int_T)0.0) - 1;
      switch_status[4] = 0;
      switch_status_init[4] = 0;
      gState[4] = (int_T) 0.0;
      yswitch[4] = 1/0.001;
      switchTypes[4] = (int_T)3.0;
      idxOutSw[4] = ((int_T)0.0) - 1;
      switch_status[5] = 0;
      switch_status_init[5] = 0;
      gState[5] = (int_T) 0.0;
      yswitch[5] = 1/0.001;
      switchTypes[5] = (int_T)3.0;
      idxOutSw[5] = ((int_T)0.0) - 1;
      switch_status[6] = 0;
      switch_status_init[6] = 0;
      gState[6] = (int_T) 0.0;
      yswitch[6] = 1/0.001;
      switchTypes[6] = (int_T)3.0;
      idxOutSw[6] = ((int_T)0.0) - 1;
      switch_status[7] = 0;
      switch_status_init[7] = 0;
      gState[7] = (int_T) 0.0;
      yswitch[7] = 1/0.001;
      switchTypes[7] = (int_T)3.0;
      idxOutSw[7] = ((int_T)0.0) - 1;
      switch_status[8] = 0;
      switch_status_init[8] = 0;
      gState[8] = (int_T) 0.0;
      yswitch[8] = 1/0.001;
      switchTypes[8] = (int_T)6.0;
      idxOutSw[8] = ((int_T)0.0) - 1;
      switch_status[9] = 0;
      switch_status_init[9] = 0;
      gState[9] = (int_T) 0.0;
      yswitch[9] = 1/0.001;
      switchTypes[9] = (int_T)6.0;
      idxOutSw[9] = ((int_T)0.0) - 1;
      switch_status[10] = 0;
      switch_status_init[10] = 0;
      gState[10] = (int_T) 0.0;
      yswitch[10] = 1/0.001;
      switchTypes[10] = (int_T)7.0;
      idxOutSw[10] = ((int_T)0.0) - 1;
      switch_status[11] = 0;
      switch_status_init[11] = 0;
      gState[11] = (int_T) 0.0;
      yswitch[11] = 1/0.001;
      switchTypes[11] = (int_T)7.0;
      idxOutSw[11] = ((int_T)0.0) - 1;
      switch_status[12] = 0;
      switch_status_init[12] = 0;
      gState[12] = (int_T) 0.0;
      yswitch[12] = 1/0.001;
      switchTypes[12] = (int_T)7.0;
      idxOutSw[12] = ((int_T)0.0) - 1;
      switch_status[13] = 0;
      switch_status_init[13] = 0;
      gState[13] = (int_T) 0.0;
      yswitch[13] = 1/0.001;
      switchTypes[13] = (int_T)7.0;
      idxOutSw[13] = ((int_T)0.0) - 1;
      switch_status[14] = 0;
      switch_status_init[14] = 0;
      gState[14] = (int_T) 0.0;
      yswitch[14] = 1/0.001;
      switchTypes[14] = (int_T)7.0;
      idxOutSw[14] = ((int_T)0.0) - 1;
      switch_status[15] = 0;
      switch_status_init[15] = 0;
      gState[15] = (int_T) 0.0;
      yswitch[15] = 1/0.001;
      switchTypes[15] = (int_T)7.0;
      idxOutSw[15] = ((int_T)0.0) - 1;
      switch_status[16] = 0;
      switch_status_init[16] = 0;
      gState[16] = (int_T) 0.0;
      yswitch[16] = 1/0.001;
      switchTypes[16] = (int_T)7.0;
      idxOutSw[16] = ((int_T)0.0) - 1;
      switch_status[17] = 0;
      switch_status_init[17] = 0;
      gState[17] = (int_T) 0.0;
      yswitch[17] = 1/0.001;
      switchTypes[17] = (int_T)7.0;
      idxOutSw[17] = ((int_T)0.0) - 1;
      switch_status[18] = 0;
      switch_status_init[18] = 0;
      gState[18] = (int_T) 0.0;
      yswitch[18] = 1/0.001;
      switchTypes[18] = (int_T)7.0;
      idxOutSw[18] = ((int_T)0.0) - 1;
      switch_status[19] = 0;
      switch_status_init[19] = 0;
      gState[19] = (int_T) 0.0;
      yswitch[19] = 1/0.001;
      switchTypes[19] = (int_T)7.0;
      idxOutSw[19] = ((int_T)0.0) - 1;
      switch_status[20] = 0;
      switch_status_init[20] = 0;
      gState[20] = (int_T) 0.0;
      yswitch[20] = 1/0.001;
      switchTypes[20] = (int_T)7.0;
      idxOutSw[20] = ((int_T)0.0) - 1;
      switch_status[21] = 0;
      switch_status_init[21] = 0;
      gState[21] = (int_T) 0.0;
      yswitch[21] = 1/0.001;
      switchTypes[21] = (int_T)7.0;
      idxOutSw[21] = ((int_T)0.0) - 1;
      switch_status[22] = 0;
      switch_status_init[22] = 0;
      gState[22] = (int_T) 0.0;
      yswitch[22] = 1/0.001;
      switchTypes[22] = (int_T)7.0;
      idxOutSw[22] = ((int_T)0.0) - 1;
      switch_status[23] = 0;
      switch_status_init[23] = 0;
      gState[23] = (int_T) 0.0;
      yswitch[23] = 1/0.001;
      switchTypes[23] = (int_T)7.0;
      idxOutSw[23] = ((int_T)0.0) - 1;
      switch_status[24] = 0;
      switch_status_init[24] = 0;
      gState[24] = (int_T) 0.0;
      yswitch[24] = 1/0.001;
      switchTypes[24] = (int_T)7.0;
      idxOutSw[24] = ((int_T)0.0) - 1;
      switch_status[25] = 0;
      switch_status_init[25] = 0;
      gState[25] = (int_T) 0.0;
      yswitch[25] = 1/0.001;
      switchTypes[25] = (int_T)7.0;
      idxOutSw[25] = ((int_T)0.0) - 1;
      switch_status[26] = 0;
      switch_status_init[26] = 0;
      gState[26] = (int_T) 0.0;
      yswitch[26] = 1/0.001;
      switchTypes[26] = (int_T)7.0;
      idxOutSw[26] = ((int_T)0.0) - 1;
      switch_status[27] = 0;
      switch_status_init[27] = 0;
      gState[27] = (int_T) 0.0;
      yswitch[27] = 1/0.001;
      switchTypes[27] = (int_T)7.0;
      idxOutSw[27] = ((int_T)0.0) - 1;
      switch_status[28] = 0;
      switch_status_init[28] = 0;
      gState[28] = (int_T) 0.0;
      yswitch[28] = 1/0.001;
      switchTypes[28] = (int_T)7.0;
      idxOutSw[28] = ((int_T)0.0) - 1;
      switch_status[29] = 0;
      switch_status_init[29] = 0;
      gState[29] = (int_T) 0.0;
      yswitch[29] = 1/0.001;
      switchTypes[29] = (int_T)7.0;
      idxOutSw[29] = ((int_T)0.0) - 1;
      switch_status[30] = 0;
      switch_status_init[30] = 0;
      gState[30] = (int_T) 0.0;
      yswitch[30] = 1/0.001;
      switchTypes[30] = (int_T)7.0;
      idxOutSw[30] = ((int_T)0.0) - 1;
      switch_status[31] = 0;
      switch_status_init[31] = 0;
      gState[31] = (int_T) 0.0;
      yswitch[31] = 1/0.001;
      switchTypes[31] = (int_T)7.0;
      idxOutSw[31] = ((int_T)0.0) - 1;
      switch_status[32] = 0;
      switch_status_init[32] = 0;
      gState[32] = (int_T) 0.0;
      yswitch[32] = 1/0.001;
      switchTypes[32] = (int_T)7.0;
      idxOutSw[32] = ((int_T)0.0) - 1;
      switch_status[33] = 0;
      switch_status_init[33] = 0;
      gState[33] = (int_T) 0.0;
      yswitch[33] = 1/0.001;
      switchTypes[33] = (int_T)7.0;
      idxOutSw[33] = ((int_T)0.0) - 1;
      switch_status[34] = 0;
      switch_status_init[34] = 0;
      gState[34] = (int_T) 0.0;
      yswitch[34] = 1/0.001;
      switchTypes[34] = (int_T)7.0;
      idxOutSw[34] = ((int_T)0.0) - 1;
      switch_status[35] = 0;
      switch_status_init[35] = 0;
      gState[35] = (int_T) 0.0;
      yswitch[35] = 1/0.001;
      switchTypes[35] = (int_T)7.0;
      idxOutSw[35] = ((int_T)0.0) - 1;
      switch_status[36] = 0;
      switch_status_init[36] = 0;
      gState[36] = (int_T) 0.0;
      yswitch[36] = 1/0.001;
      switchTypes[36] = (int_T)7.0;
      idxOutSw[36] = ((int_T)0.0) - 1;
      switch_status[37] = 0;
      switch_status_init[37] = 0;
      gState[37] = (int_T) 0.0;
      yswitch[37] = 1/0.001;
      switchTypes[37] = (int_T)7.0;
      idxOutSw[37] = ((int_T)0.0) - 1;
      switch_status[38] = 0;
      switch_status_init[38] = 0;
      gState[38] = (int_T) 0.0;
      yswitch[38] = 1/0.001;
      switchTypes[38] = (int_T)7.0;
      idxOutSw[38] = ((int_T)0.0) - 1;
      switch_status[39] = 0;
      switch_status_init[39] = 0;
      gState[39] = (int_T) 0.0;
      yswitch[39] = 1/0.001;
      switchTypes[39] = (int_T)7.0;
      idxOutSw[39] = ((int_T)0.0) - 1;
      switch_status[40] = 0;
      switch_status_init[40] = 0;
      gState[40] = (int_T) 0.0;
      yswitch[40] = 1/0.001;
      switchTypes[40] = (int_T)7.0;
      idxOutSw[40] = ((int_T)0.0) - 1;
      switch_status[41] = 0;
      switch_status_init[41] = 0;
      gState[41] = (int_T) 0.0;
      yswitch[41] = 1/0.001;
      switchTypes[41] = (int_T)7.0;
      idxOutSw[41] = ((int_T)0.0) - 1;
    }
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */
  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S414>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE = 20412.414523193154;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */
  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S421>/S-Function' incorporates:
   *  Constant: '<S420>/K1'
   */
  /* Level2 S-Function Block: '<S421>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S420>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_f = -10206.207261596574;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S419>/S-Function' incorporates:
   *  Constant: '<S418>/K1'
   */
  /* Level2 S-Function Block: '<S419>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S418>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_j = -17677.669529663694;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S427>/S-Function' incorporates:
   *  Constant: '<S426>/K1'
   */
  /* Level2 S-Function Block: '<S427>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S426>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_n = -10206.207261596574;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */
  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S424>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_h = 17677.669529663694;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S439>/S-Function' incorporates:
   *  Constant: '<S438>/K1'
   */
  /* Level2 S-Function Block: '<S439>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S438>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_a = 50.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S437>/S-Function' incorporates:
   *  Constant: '<S436>/K1'
   */
  /* Level2 S-Function Block: '<S437>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */
  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S444>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m = -24.999999999999989;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */
  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S442>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o = -43.301270189221938;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */
  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S450>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jl = -24.999999999999989;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */
  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S448>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ha = 43.301270189221938;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S790>/S-Function' incorporates:
   *  Constant: '<S789>/K1'
   */
  /* Level2 S-Function Block: '<S790>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S789>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ay = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S788>/S-Function' incorporates:
   *  Constant: '<S787>/K1'
   */
  /* Level2 S-Function Block: '<S788>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S796>/S-Function' incorporates:
   *  Constant: '<S795>/K1'
   */
  /* Level2 S-Function Block: '<S796>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S795>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_c = -0.49999999999999978;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S794>/S-Function' incorporates:
   *  Constant: '<S793>/K1'
   */
  /* Level2 S-Function Block: '<S794>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S793>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ag = -0.86602540378443871;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S802>/S-Function' incorporates:
   *  Constant: '<S801>/K1'
   */
  /* Level2 S-Function Block: '<S802>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S801>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_cr = -0.49999999999999978;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S800>/S-Function' incorporates:
   *  Constant: '<S799>/K1'
   */
  /* Level2 S-Function Block: '<S800>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S799>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_p = 0.86602540378443871;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S381>/S-Function' incorporates:
   *  Constant: '<S380>/K1'
   */
  /* Level2 S-Function Block: '<S381>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S380>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m0 = 400000.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S383>/S-Function' incorporates:
   *  Constant: '<S382>/K1'
   */
  /* Level2 S-Function Block: '<S383>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S382>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_g = -100000.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S385>/S-Function' incorporates:
   *  Constant: '<S384>/K1'
   */
  /* Level2 S-Function Block: '<S385>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S387>/S-Function' incorporates:
   *  Constant: '<S386>/K1'
   */
  /* Level2 S-Function Block: '<S387>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S386>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lg = 300000.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S395>/S-Function' incorporates:
   *  Constant: '<S394>/K1'
   */
  /* Level2 S-Function Block: '<S395>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S394>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jx = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S393>/S-Function' incorporates:
   *  Constant: '<S392>/K1'
   */
  /* Level2 S-Function Block: '<S393>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S401>/S-Function' incorporates:
   *  Constant: '<S400>/K1'
   */
  /* Level2 S-Function Block: '<S401>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S400>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lz = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S399>/S-Function' incorporates:
   *  Constant: '<S398>/K1'
   */
  /* Level2 S-Function Block: '<S399>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S465>/S-Function' incorporates:
   *  Constant: '<S464>/K1'
   */
  /* Level2 S-Function Block: '<S465>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S463>/S-Function' incorporates:
   *  Constant: '<S462>/K1'
   */
  /* Level2 S-Function Block: '<S463>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S471>/S-Function' incorporates:
   *  Constant: '<S470>/K1'
   */
  /* Level2 S-Function Block: '<S471>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */
  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S477>/S-Function' incorporates:
   *  Constant: '<S476>/K1'
   */
  /* Level2 S-Function Block: '<S477>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */
  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S489>/S-Function' incorporates:
   *  Constant: '<S488>/K1'
   */
  /* Level2 S-Function Block: '<S489>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S487>/S-Function' incorporates:
   *  Constant: '<S486>/K1'
   */
  /* Level2 S-Function Block: '<S487>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */
  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */
  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */
  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */
  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for DiscreteIntegrator: '<S193>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_PrevRese = 2;

  /* InitializeConditions for DiscreteIntegrator: '<S272>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_PrevRe_g = 2;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S269>/S-Function' incorporates:
   *  Constant: '<S268>/K1'
   */
  /* Level2 S-Function Block: '<S269>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S268>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ai = 1.0;

  /* InitializeConditions for RateLimiter: '<S63>/Rate Limiter' */
  rtDW.PrevY_k = 1200.0;

  /* InitializeConditions for DiscreteIntegrator: '<S74>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTAT_oe = 200.0;

  /* InitializeConditions for RateLimiter: '<S63>/Rate Limiter1' */
  rtDW.PrevY_n = 200.0;

  /* InitializeConditions for RateTransition: '<S63>/Rate Transition2' */
  rtDW.RateTransition2_Buffer0 = 0.7;

  /* InitializeConditions for UnitDelay: '<S272>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_cn4 = 60.0;

  /* InitializeConditions for DiscreteIntegrator: '<S274>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_n = 376.99111843077515;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S300>/S-Function' */
  /* Level2 S-Function Block: '<S300>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for RateLimiter: '<S272>/Rate Limiter' */
  rtDW.PrevY_l = 60.0;

  /* InitializeConditions for UnitDelay: '<S294>/Delay_x1' */
  rtDW.Delay_x1_DSTATE_l = 48.633668149093175;

  /* InitializeConditions for UnitDelay: '<S294>/Delay_x2' */
  rtDW.Delay_x2_DSTATE_j = -3.5527136788005009E-15;

  /* InitializeConditions for DiscreteIntegrator: '<S73>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTAT_om = 0.7;

  /* InitializeConditions for UnitDelay: '<S193>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_fu = 60.0;

  /* InitializeConditions for DiscreteIntegrator: '<S195>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_p = 376.99111843077515;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S221>/S-Function' */
  /* Level2 S-Function Block: '<S221>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for RateLimiter: '<S193>/Rate Limiter' */
  rtDW.PrevY_a = 60.0;

  /* InitializeConditions for UnitDelay: '<S215>/Delay_x1' */
  rtDW.Delay_x1_DSTATE_g = 48.633668149093175;

  /* InitializeConditions for UnitDelay: '<S215>/Delay_x2' */
  rtDW.Delay_x2_DSTATE_ie = -3.5527136788005009E-15;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */
  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S593>/S-Function' incorporates:
   *  Constant: '<S592>/K1'
   */
  /* Level2 S-Function Block: '<S593>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S595>/S-Function' incorporates:
   *  Constant: '<S594>/K1'
   */
  /* Level2 S-Function Block: '<S595>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */
  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S601>/S-Function' incorporates:
   *  Constant: '<S600>/K1'
   */
  /* Level2 S-Function Block: '<S601>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */
  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S607>/S-Function' incorporates:
   *  Constant: '<S606>/K1'
   */
  /* Level2 S-Function Block: '<S607>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S617>/S-Function' incorporates:
   *  Constant: '<S616>/K1'
   */
  /* Level2 S-Function Block: '<S617>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S619>/S-Function' incorporates:
   *  Constant: '<S618>/K1'
   */
  /* Level2 S-Function Block: '<S619>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */
  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */
  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */
  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */
  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */
  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */
  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */
  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */
  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */
  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */
  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S549>/S-Function' incorporates:
   *  Constant: '<S548>/K1'
   */
  /* Level2 S-Function Block: '<S549>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S551>/S-Function' incorporates:
   *  Constant: '<S550>/K1'
   */
  /* Level2 S-Function Block: '<S551>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */
  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S557>/S-Function' incorporates:
   *  Constant: '<S556>/K1'
   */
  /* Level2 S-Function Block: '<S557>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S567>/S-Function' incorporates:
   *  Constant: '<S566>/K1'
   */
  /* Level2 S-Function Block: '<S567>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S569>/S-Function' incorporates:
   *  Constant: '<S568>/K1'
   */
  /* Level2 S-Function Block: '<S569>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */
  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */
  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */
  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */
  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S641>/S-Function' incorporates:
   *  Constant: '<S640>/K1'
   */
  /* Level2 S-Function Block: '<S641>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S643>/S-Function' incorporates:
   *  Constant: '<S642>/K1'
   */
  /* Level2 S-Function Block: '<S643>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */
  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */
  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */
  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */
  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S515>/S-Function' incorporates:
   *  Constant: '<S514>/K1'
   */
  /* Level2 S-Function Block: '<S515>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S511>/S-Function' incorporates:
   *  Constant: '<S510>/K1'
   */
  /* Level2 S-Function Block: '<S511>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S513>/S-Function' incorporates:
   *  Constant: '<S512>/K1'
   */
  /* Level2 S-Function Block: '<S513>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* SystemInitialize for Enabled SubSystem: '<S67>/PWM Gen' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */
  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S67>/PWM Gen' */

  /* SystemInitialize for Enabled SubSystem: '<S68>/PWM Gen' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S141>/S-Function' incorporates:
   *  Constant: '<S140>/K1'
   */
  /* Level2 S-Function Block: '<S141>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S68>/PWM Gen' */

  /* SystemInitialize for Enabled SubSystem: '<S64>/PWMgen - Averaging' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S83>/S-Function' incorporates:
   *  Constant: '<S82>/K1'
   */
  /* Level2 S-Function Block: '<S83>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S85>/S-Function' incorporates:
   *  Constant: '<S84>/K1'
   */
  /* Level2 S-Function Block: '<S85>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S64>/PWMgen - Averaging' */

  /* SystemInitialize for Enabled SubSystem: '<S272>/Automatic Gain Control' */
  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S284>/S-Function' */
  /* Level2 S-Function Block: '<S284>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S282>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_hp = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S287>/S-Function' */
  /* Level2 S-Function Block: '<S287>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* SystemInitialize for Outport: '<S273>/Gain' */
  rtDW.MathFunction = 1.0;

  /* End of SystemInitialize for SubSystem: '<S272>/Automatic Gain Control' */

  /* SystemInitialize for Enabled SubSystem: '<S65>/Subsystem' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S111>/S-Function' incorporates:
   *  Constant: '<S110>/K1'
   */
  /* Level2 S-Function Block: '<S111>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S65>/Subsystem' */

  /* SystemInitialize for Enabled SubSystem: '<S66>/PWMgen - Averaging' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S121>/S-Function' incorporates:
   *  Constant: '<S120>/K1'
   */
  /* Level2 S-Function Block: '<S121>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */
  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S66>/PWMgen - Averaging' */

  /* SystemInitialize for Enabled SubSystem: '<S193>/Automatic Gain Control' */
  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S205>/S-Function' */
  /* Level2 S-Function Block: '<S205>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S203>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ia = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S208>/S-Function' */
  /* Level2 S-Function Block: '<S208>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* SystemInitialize for Outport: '<S194>/Gain' */
  rtDW.MathFunction_h = 1.0;

  /* End of SystemInitialize for SubSystem: '<S193>/Automatic Gain Control' */

  /* SystemInitialize for Enabled SubSystem: '<S70>/Subsystem' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S169>/S-Function' incorporates:
   *  Constant: '<S168>/K1'
   */
  /* Level2 S-Function Block: '<S169>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S70>/Subsystem' */

  /* SystemInitialize for Enabled SubSystem: '<S69>/PWM gen' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S151>/S-Function' incorporates:
   *  Constant: '<S150>/K1'
   */
  /* Level2 S-Function Block: '<S151>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */
  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S69>/PWM gen' */

  /* Enable for Sin: '<Root>/Vload' */
  rtDW.systemEnable = 1;

  /* Enable for Sin: '<S404>/sin(wt)' */
  rtDW.systemEnable_f = 1;

  /* Enable for DiscreteIntegrator: '<S414>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE = 1U;

  /* Enable for Sin: '<S404>/cos(wt)' */
  rtDW.systemEnable_b = 1;

  /* Enable for DiscreteIntegrator: '<S412>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_e = 1U;

  /* Enable for Sin: '<S405>/sin(wt)' */
  rtDW.systemEnable_n = 1;

  /* Enable for DiscreteIntegrator: '<S420>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_c = 1U;

  /* Enable for Sin: '<S405>/cos(wt)' */
  rtDW.systemEnable_c = 1;

  /* Enable for DiscreteIntegrator: '<S418>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i = 1U;

  /* Enable for Sin: '<S406>/sin(wt)' */
  rtDW.systemEnable_a = 1;

  /* Enable for DiscreteIntegrator: '<S426>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n = 1U;

  /* Enable for Sin: '<S406>/cos(wt)' */
  rtDW.systemEnable_d = 1;

  /* Enable for DiscreteIntegrator: '<S424>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k = 1U;

  /* Enable for Sin: '<S428>/sin(wt)' */
  rtDW.systemEnable_fb = 1;

  /* Enable for DiscreteIntegrator: '<S438>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_g = 1U;

  /* Enable for Sin: '<S428>/cos(wt)' */
  rtDW.systemEnable_o = 1;

  /* Enable for DiscreteIntegrator: '<S436>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ex = 1U;

  /* Enable for Sin: '<S429>/sin(wt)' */
  rtDW.systemEnable_p = 1;

  /* Enable for DiscreteIntegrator: '<S444>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kl = 1U;

  /* Enable for Sin: '<S429>/cos(wt)' */
  rtDW.systemEnable_e = 1;

  /* Enable for DiscreteIntegrator: '<S442>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_l = 1U;

  /* Enable for Sin: '<S430>/sin(wt)' */
  rtDW.systemEnable_l = 1;

  /* Enable for DiscreteIntegrator: '<S450>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k2 = 1U;

  /* Enable for Sin: '<S430>/cos(wt)' */
  rtDW.systemEnable_g = 1;

  /* Enable for DiscreteIntegrator: '<S448>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_j = 1U;

  /* Enable for Sin: '<S779>/sin(wt)' */
  rtDW.systemEnable_nr = 1;

  /* Enable for DiscreteIntegrator: '<S789>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o = 1U;

  /* Enable for Sin: '<S779>/cos(wt)' */
  rtDW.systemEnable_nk = 1;

  /* Enable for DiscreteIntegrator: '<S787>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_km = 1U;

  /* Enable for Sin: '<S780>/sin(wt)' */
  rtDW.systemEnable_lm = 1;

  /* Enable for DiscreteIntegrator: '<S795>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_f = 1U;

  /* Enable for Sin: '<S780>/cos(wt)' */
  rtDW.systemEnable_fk = 1;

  /* Enable for DiscreteIntegrator: '<S793>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fy = 1U;

  /* Enable for Sin: '<S781>/sin(wt)' */
  rtDW.systemEnable_es = 1;

  /* Enable for DiscreteIntegrator: '<S801>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n0 = 1U;

  /* Enable for Sin: '<S781>/cos(wt)' */
  rtDW.systemEnable_eq = 1;

  /* Enable for DiscreteIntegrator: '<S799>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_d = 1U;

  /* Enable for DiscreteIntegrator: '<S380>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a = 1U;

  /* Enable for DiscreteIntegrator: '<S382>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h = 1U;

  /* Enable for DiscreteIntegrator: '<S384>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_m = 1U;

  /* Enable for DiscreteIntegrator: '<S386>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o0 = 1U;

  /* Enable for Sin: '<S388>/sin(wt)' */
  rtDW.systemEnable_m = 1;

  /* Enable for DiscreteIntegrator: '<S394>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_b = 1U;

  /* Enable for Sin: '<S388>/cos(wt)' */
  rtDW.systemEnable_e2 = 1;

  /* Enable for DiscreteIntegrator: '<S392>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_en = 1U;

  /* Enable for Sin: '<S389>/sin(wt)' */
  rtDW.systemEnable_aq = 1;

  /* Enable for DiscreteIntegrator: '<S400>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a3 = 1U;

  /* Enable for Sin: '<S389>/cos(wt)' */
  rtDW.systemEnable_ac = 1;

  /* Enable for DiscreteIntegrator: '<S398>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kb = 1U;

  /* Enable for Sin: '<S454>/sin(wt)' */
  rtDW.systemEnable_j = 1;

  /* Enable for DiscreteIntegrator: '<S464>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cl = 1U;

  /* Enable for Sin: '<S454>/cos(wt)' */
  rtDW.systemEnable_gz = 1;

  /* Enable for DiscreteIntegrator: '<S462>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i2 = 1U;

  /* Enable for Sin: '<S455>/sin(wt)' */
  rtDW.systemEnable_lb = 1;

  /* Enable for DiscreteIntegrator: '<S470>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bc = 1U;

  /* Enable for Sin: '<S455>/cos(wt)' */
  rtDW.systemEnable_i = 1;

  /* Enable for DiscreteIntegrator: '<S468>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gs = 1U;

  /* Enable for Sin: '<S456>/sin(wt)' */
  rtDW.systemEnable_bk = 1;

  /* Enable for DiscreteIntegrator: '<S476>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jz = 1U;

  /* Enable for Sin: '<S456>/cos(wt)' */
  rtDW.systemEnable_oz = 1;

  /* Enable for DiscreteIntegrator: '<S474>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bm = 1U;

  /* Enable for Sin: '<S478>/sin(wt)' */
  rtDW.systemEnable_cd = 1;

  /* Enable for DiscreteIntegrator: '<S488>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ke = 1U;

  /* Enable for Sin: '<S478>/cos(wt)' */
  rtDW.systemEnable_jg = 1;

  /* Enable for DiscreteIntegrator: '<S486>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oh = 1U;

  /* Enable for Sin: '<S479>/sin(wt)' */
  rtDW.systemEnable_av = 1;

  /* Enable for DiscreteIntegrator: '<S494>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_lx = 1U;

  /* Enable for Sin: '<S479>/cos(wt)' */
  rtDW.systemEnable_oh = 1;

  /* Enable for DiscreteIntegrator: '<S492>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_of = 1U;

  /* Enable for Sin: '<S480>/sin(wt)' */
  rtDW.systemEnable_bn = 1;

  /* Enable for DiscreteIntegrator: '<S500>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_p = 1U;

  /* Enable for Sin: '<S480>/cos(wt)' */
  rtDW.systemEnable_na = 1;

  /* Enable for DiscreteIntegrator: '<S498>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_on = 1U;

  /* Enable for DiscreteIntegrator: '<S268>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ei = 1U;

  /* Enable for DiscreteIntegrator: '<S298>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nm = 1U;

  /* Enable for DiscreteIntegrator: '<S219>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nr = 1U;

  /* Enable for Sin: '<S5>/Uref1' */
  rtDW.systemEnable_h = 1;

  /* Enable for Sin: '<S5>/Uref2' */
  rtDW.systemEnable_ia = 1;

  /* Enable for DiscreteIntegrator: '<S516>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o3 = 1U;

  /* Enable for Sin: '<S584>/cos(wt)' */
  rtDW.systemEnable_bz = 1;

  /* Enable for DiscreteIntegrator: '<S592>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_og = 1U;

  /* Enable for Sin: '<S584>/sin(wt)' */
  rtDW.systemEnable_e5 = 1;

  /* Enable for DiscreteIntegrator: '<S594>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gy = 1U;

  /* Enable for Sin: '<S585>/cos(wt)' */
  rtDW.systemEnable_bj = 1;

  /* Enable for DiscreteIntegrator: '<S598>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nt = 1U;

  /* Enable for Sin: '<S585>/sin(wt)' */
  rtDW.systemEnable_di = 1;

  /* Enable for DiscreteIntegrator: '<S600>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ax = 1U;

  /* Enable for Sin: '<S586>/cos(wt)' */
  rtDW.systemEnable_k = 1;

  /* Enable for DiscreteIntegrator: '<S604>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ob = 1U;

  /* Enable for Sin: '<S586>/sin(wt)' */
  rtDW.systemEnable_go = 1;

  /* Enable for DiscreteIntegrator: '<S606>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pc = 1U;

  /* Enable for Sin: '<S608>/cos(wt)' */
  rtDW.systemEnable_fq = 1;

  /* Enable for DiscreteIntegrator: '<S616>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ka = 1U;

  /* Enable for Sin: '<S608>/sin(wt)' */
  rtDW.systemEnable_kf = 1;

  /* Enable for DiscreteIntegrator: '<S618>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ft = 1U;

  /* Enable for Sin: '<S609>/cos(wt)' */
  rtDW.systemEnable_ip = 1;

  /* Enable for DiscreteIntegrator: '<S622>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_js = 1U;

  /* Enable for Sin: '<S609>/sin(wt)' */
  rtDW.systemEnable_g1 = 1;

  /* Enable for DiscreteIntegrator: '<S624>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jw = 1U;

  /* Enable for Sin: '<S610>/cos(wt)' */
  rtDW.systemEnable_e3 = 1;

  /* Enable for DiscreteIntegrator: '<S628>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h5 = 1U;

  /* Enable for Sin: '<S610>/sin(wt)' */
  rtDW.systemEnable_bl = 1;

  /* Enable for DiscreteIntegrator: '<S630>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k5 = 1U;

  /* Enable for Sin: '<S518>/cos(wt)' */
  rtDW.systemEnable_pz = 1;

  /* Enable for DiscreteIntegrator: '<S522>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bj = 1U;

  /* Enable for Sin: '<S518>/sin(wt)' */
  rtDW.systemEnable_avi = 1;

  /* Enable for DiscreteIntegrator: '<S524>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ba = 1U;

  /* Enable for Sin: '<S519>/cos(wt)' */
  rtDW.systemEnable_ci = 1;

  /* Enable for DiscreteIntegrator: '<S528>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gl = 1U;

  /* Enable for Sin: '<S519>/sin(wt)' */
  rtDW.systemEnable_bj1 = 1;

  /* Enable for DiscreteIntegrator: '<S530>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fs = 1U;

  /* Enable for Sin: '<S534>/cos(wt)' */
  rtDW.systemEnable_co = 1;

  /* Enable for DiscreteIntegrator: '<S542>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cm = 1U;

  /* Enable for Sin: '<S534>/sin(wt)' */
  rtDW.systemEnable_pd = 1;

  /* Enable for DiscreteIntegrator: '<S544>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cc = 1U;

  /* Enable for Sin: '<S535>/cos(wt)' */
  rtDW.systemEnable_i2 = 1;

  /* Enable for DiscreteIntegrator: '<S548>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ix = 1U;

  /* Enable for Sin: '<S535>/sin(wt)' */
  rtDW.systemEnable_ov = 1;

  /* Enable for DiscreteIntegrator: '<S550>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jo = 1U;

  /* Enable for Sin: '<S536>/cos(wt)' */
  rtDW.systemEnable_mj = 1;

  /* Enable for DiscreteIntegrator: '<S554>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bu = 1U;

  /* Enable for Sin: '<S536>/sin(wt)' */
  rtDW.systemEnable_nf = 1;

  /* Enable for DiscreteIntegrator: '<S556>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i0 = 1U;

  /* Enable for Sin: '<S558>/cos(wt)' */
  rtDW.systemEnable_mx = 1;

  /* Enable for DiscreteIntegrator: '<S566>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_af = 1U;

  /* Enable for Sin: '<S558>/sin(wt)' */
  rtDW.systemEnable_mx0 = 1;

  /* Enable for DiscreteIntegrator: '<S568>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ks = 1U;

  /* Enable for Sin: '<S559>/cos(wt)' */
  rtDW.systemEnable_gl = 1;

  /* Enable for DiscreteIntegrator: '<S572>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fu = 1U;

  /* Enable for Sin: '<S559>/sin(wt)' */
  rtDW.systemEnable_df = 1;

  /* Enable for DiscreteIntegrator: '<S574>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ns = 1U;

  /* Enable for Sin: '<S560>/cos(wt)' */
  rtDW.systemEnable_h1 = 1;

  /* Enable for DiscreteIntegrator: '<S578>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_or = 1U;

  /* Enable for Sin: '<S560>/sin(wt)' */
  rtDW.systemEnable_iv = 1;

  /* Enable for DiscreteIntegrator: '<S580>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a0 = 1U;

  /* Enable for Sin: '<S632>/cos(wt)' */
  rtDW.systemEnable_jo = 1;

  /* Enable for DiscreteIntegrator: '<S640>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ic = 1U;

  /* Enable for Sin: '<S632>/sin(wt)' */
  rtDW.systemEnable_fh = 1;

  /* Enable for DiscreteIntegrator: '<S642>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bz = 1U;

  /* Enable for Sin: '<S633>/cos(wt)' */
  rtDW.systemEnable_lo = 1;

  /* Enable for DiscreteIntegrator: '<S646>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ds = 1U;

  /* Enable for Sin: '<S633>/sin(wt)' */
  rtDW.systemEnable_jc = 1;

  /* Enable for DiscreteIntegrator: '<S648>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ow = 1U;

  /* Enable for Sin: '<S634>/cos(wt)' */
  rtDW.systemEnable_pq = 1;

  /* Enable for DiscreteIntegrator: '<S652>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i1 = 1U;

  /* Enable for Sin: '<S634>/sin(wt)' */
  rtDW.systemEnable_n5 = 1;

  /* Enable for DiscreteIntegrator: '<S654>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oo = 1U;

  /* Enable for DiscreteIntegrator: '<S514>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_co = 1U;

  /* Enable for DiscreteIntegrator: '<S510>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pb = 1U;

  /* Enable for DiscreteIntegrator: '<S512>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bzw = 1U;
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
