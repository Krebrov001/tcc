/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * File: power_converters_switching_function.c
 *
 * Code generated for Simulink model 'power_converters_switching_function'.
 *
 * Model version                  : 1.1239
 * Simulink Coder version         : 9.1 (R2019a) 23-Nov-2018
 * C/C++ source code generated on : Thu Sep  5 13:31:30 2019
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: Intel->x86-64 (Windows64)
 * Code generation objectives:
 *    1. Execution efficiency
 *    2. RAM efficiency
 * Validation result: Not run
 */

#include "power_converters_switching_function.h"
#include "power_converters_switching_function_private.h"

/* Block signals and states (default storage) */
DW rtDW;

/* External outputs (root outports fed by signals with default storage) */
ExtY rtY;

/* Real-time model */
RT_MODEL rtM_;
RT_MODEL *const rtM = &rtM_;
real_T look1_pbinlx(real_T u0, const real_T bp0[], const real_T table[],
                    uint32_T prevIndex[], uint32_T maxIndex)
{
  real_T frac;
  uint32_T iRght;
  uint32_T iLeft;
  uint32_T bpIdx;
  uint32_T found;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'on'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Linear'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Linear'
     Use previous index: 'on'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    bpIdx = 0U;
    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search using Previous Index */
    bpIdx = prevIndex[0U];
    iLeft = 0U;
    iRght = maxIndex;
    found = 0U;
    while (found == 0U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx - 1U;
        bpIdx = (iRght + iLeft) >> 1U;
      } else if (u0 < bp0[bpIdx + 1U]) {
        found = 1U;
      } else {
        iLeft = bpIdx + 1U;
        bpIdx = (iRght + iLeft) >> 1U;
      }
    }

    frac = (u0 - bp0[bpIdx]) / (bp0[bpIdx + 1U] - bp0[bpIdx]);
  } else {
    bpIdx = maxIndex - 1U;
    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);
  }

  prevIndex[0U] = bpIdx;

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'wrapping'
   */
  return (table[bpIdx + 1U] - table[bpIdx]) * frac + table[bpIdx];
}

/*
 * Output and update for atomic system:
 *    '<S43>/MATLAB Function4'
 *    '<S61>/MATLAB Function4'
 */
void MATLABFunction4(real_T rtu_g, real_T rtu_Vdc, real_T rtu_I, real_T *rty_V,
                     real_T *rty_Idc)
{
  *rty_V = -rtu_g * rtu_Vdc;
  *rty_Idc = rtu_g * rtu_I;
}

/*
 * Output and update for enable system:
 *    '<S221>/Subsystem - pi//2 delay'
 *    '<S234>/Subsystem - pi//2 delay'
 *    '<S240>/Subsystem - pi//2 delay'
 *    '<S255>/Subsystem - pi//2 delay'
 *    '<S300>/Subsystem - pi//2 delay'
 *    '<S313>/Subsystem - pi//2 delay'
 *    '<S319>/Subsystem - pi//2 delay'
 *    '<S334>/Subsystem - pi//2 delay'
 */
void Subsystempi2delay(uint8_T rtu_Enable, const real_T rtu_alpha_beta[2],
  real_T rtu_wt, real_T *rty_dq, real_T *rty_dq_d)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S221>/Subsystem - pi//2 delay' incorporates:
   *  EnablePort: '<S225>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S225>/Fcn' incorporates:
     *  Fcn: '<S225>/Fcn1'
     */
    tmp = cos(rtu_wt);
    tmp_0 = sin(rtu_wt);
    *rty_dq = rtu_alpha_beta[0] * tmp_0 - rtu_alpha_beta[1] * tmp;

    /* Fcn: '<S225>/Fcn1' */
    *rty_dq_d = rtu_alpha_beta[0] * tmp + rtu_alpha_beta[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S221>/Subsystem - pi//2 delay' */
}

/*
 * Output and update for enable system:
 *    '<S221>/Subsystem1'
 *    '<S234>/Subsystem1'
 *    '<S240>/Subsystem1'
 *    '<S255>/Subsystem1'
 *    '<S300>/Subsystem1'
 *    '<S313>/Subsystem1'
 *    '<S319>/Subsystem1'
 *    '<S334>/Subsystem1'
 */
void Subsystem1(uint8_T rtu_Enable, const real_T rtu_alpha_beta[2], real_T
                rtu_wt, real_T *rty_dq, real_T *rty_dq_h)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S221>/Subsystem1' incorporates:
   *  EnablePort: '<S226>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S226>/Fcn' incorporates:
     *  Fcn: '<S226>/Fcn1'
     */
    tmp = sin(rtu_wt);
    tmp_0 = cos(rtu_wt);
    *rty_dq = rtu_alpha_beta[0] * tmp_0 + rtu_alpha_beta[1] * tmp;

    /* Fcn: '<S226>/Fcn1' */
    *rty_dq_h = -rtu_alpha_beta[0] * tmp + rtu_alpha_beta[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S221>/Subsystem1' */
}

/*
 * Output and update for enable system:
 *    '<S262>/Subsystem - pi//2 delay'
 *    '<S341>/Subsystem - pi//2 delay'
 */
void Subsystempi2delay_l(uint8_T rtu_Enable, const real_T rtu_dq[2], real_T
  rtu_wt, real_T *rty_alpha_beta, real_T *rty_alpha_beta_o)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S262>/Subsystem - pi//2 delay' incorporates:
   *  EnablePort: '<S265>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S265>/Fcn' incorporates:
     *  Fcn: '<S265>/Fcn1'
     */
    tmp = cos(rtu_wt);
    tmp_0 = sin(rtu_wt);
    *rty_alpha_beta = rtu_dq[0] * tmp_0 + rtu_dq[1] * tmp;

    /* Fcn: '<S265>/Fcn1' */
    *rty_alpha_beta_o = -rtu_dq[0] * tmp + rtu_dq[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S262>/Subsystem - pi//2 delay' */
}

/*
 * Output and update for enable system:
 *    '<S262>/Subsystem1'
 *    '<S341>/Subsystem1'
 */
void Subsystem1_i(uint8_T rtu_Enable, const real_T rtu_dq[2], real_T rtu_wt,
                  real_T *rty_alpha_beta, real_T *rty_alpha_beta_m)
{
  real_T tmp;
  real_T tmp_0;

  /* Outputs for Enabled SubSystem: '<S262>/Subsystem1' incorporates:
   *  EnablePort: '<S266>/Enable'
   */
  if (rtu_Enable > 0) {
    /* Fcn: '<S266>/Fcn' incorporates:
     *  Fcn: '<S266>/Fcn1'
     */
    tmp = sin(rtu_wt);
    tmp_0 = cos(rtu_wt);
    *rty_alpha_beta = rtu_dq[0] * tmp_0 - rtu_dq[1] * tmp;

    /* Fcn: '<S266>/Fcn1' */
    *rty_alpha_beta_m = rtu_dq[0] * tmp + rtu_dq[1] * tmp_0;
  }

  /* End of Outputs for SubSystem: '<S262>/Subsystem1' */
}

/*
 * Output and update for atomic system:
 *    '<S390>/MATLAB Function'
 *    '<S762>/MATLAB Function'
 *    '<S763>/MATLAB Function'
 *    '<S764>/MATLAB Function'
 *    '<S822>/MATLAB Function'
 *    '<S823>/MATLAB Function'
 *    '<S824>/MATLAB Function'
 *    '<S882>/MATLAB Function'
 */
void MATLABFunction(const real_T rtu_g[2], real_T rtu_Vdc, const real_T rtu_I[2],
                    real_T rty_V[2], real_T *rty_Idc)
{
  real_T tmp;
  rty_V[0] = (-rtu_g[1] + 1.0) * rtu_Vdc;
  rty_V[1] = -rtu_g[0] * rtu_Vdc;
  tmp = rtu_I[1] - rtu_I[0];
  if (tmp > 0.0) {
    *rty_Idc = tmp * rtu_g[0];
  } else {
    *rty_Idc = (1.0 - rtu_g[1]) * tmp;
  }

  if (rtu_g[0] + rtu_g[1] == 2.0) {
    *rty_Idc = rtu_I[0];
  }
}

/*
 * Output and update for enable system:
 *    '<S432>/Neg. Seq. Computation'
 *    '<S433>/Neg. Seq. Computation'
 *    '<S482>/Neg. Seq. Computation'
 *    '<S483>/Neg. Seq. Computation'
 *    '<S32>/Neg. Seq. Computation'
 */
void NegSeqComputation(real_T rtu_Enable, creal_T rtu_In, creal_T rtu_In_o,
  creal_T rtu_In_j, creal_T *rty_Out)
{
  /* Outputs for Enabled SubSystem: '<S432>/Neg. Seq. Computation' incorporates:
   *  EnablePort: '<S437>/Enable'
   */
  if (rtu_Enable > 0.0) {
    /* Gain: '<S437>/Gain3' incorporates:
     *  Gain: '<S437>/Gain1'
     *  Sum: '<S437>/Sum'
     */
    rty_Out->re = (((rtu_In.re - 0.0 * rtu_In.im) + (-0.49999999999999978 *
      rtu_In_o.re - -0.86602540378443871 * rtu_In_o.im)) + (-0.49999999999999978
      * rtu_In_j.re - 0.86602540378443871 * rtu_In_j.im)) * 0.33333333333333331;
    rty_Out->im = (((0.0 * rtu_In.re + rtu_In.im) + (-0.49999999999999978 *
      rtu_In_o.im + -0.86602540378443871 * rtu_In_o.re)) + (-0.49999999999999978
      * rtu_In_j.im + 0.86602540378443871 * rtu_In_j.re)) * 0.33333333333333331;
  }

  /* End of Outputs for SubSystem: '<S432>/Neg. Seq. Computation' */
}

/*
 * Output and update for enable system:
 *    '<S432>/Pos. Seq. Computation'
 *    '<S433>/Pos. Seq. Computation'
 *    '<S482>/Pos. Seq. Computation'
 *    '<S483>/Pos. Seq. Computation'
 *    '<S32>/Pos. Seq. Computation'
 */
void PosSeqComputation(real_T rtu_Enable, creal_T rtu_In, creal_T rtu_In_b,
  creal_T rtu_In_d, creal_T *rty_Out)
{
  /* Outputs for Enabled SubSystem: '<S432>/Pos. Seq. Computation' incorporates:
   *  EnablePort: '<S438>/Enable'
   */
  if (rtu_Enable > 0.0) {
    /* Gain: '<S438>/Gain3' incorporates:
     *  Gain: '<S438>/Gain1'
     *  Sum: '<S438>/Sum'
     */
    rty_Out->re = (((rtu_In.re - 0.0 * rtu_In.im) + (-0.49999999999999978 *
      rtu_In_b.re - 0.86602540378443871 * rtu_In_b.im)) + (-0.49999999999999978 *
      rtu_In_d.re - -0.86602540378443871 * rtu_In_d.im)) * 0.33333333333333331;
    rty_Out->im = (((0.0 * rtu_In.re + rtu_In.im) + (-0.49999999999999978 *
      rtu_In_b.im + 0.86602540378443871 * rtu_In_b.re)) + (-0.49999999999999978 *
      rtu_In_d.im + -0.86602540378443871 * rtu_In_d.re)) * 0.33333333333333331;
  }

  /* End of Outputs for SubSystem: '<S432>/Pos. Seq. Computation' */
}

/*
 * Output and update for enable system:
 *    '<S432>/Zero Seq. Computation'
 *    '<S433>/Zero Seq. Computation'
 *    '<S482>/Zero Seq. Computation'
 *    '<S483>/Zero Seq. Computation'
 *    '<S32>/Zero Seq. Computation'
 */
void ZeroSeqComputation(real_T rtu_Enable, creal_T rtu_In, creal_T rtu_In_d,
  creal_T rtu_In_o, creal_T *rty_Out)
{
  /* Outputs for Enabled SubSystem: '<S432>/Zero Seq. Computation' incorporates:
   *  EnablePort: '<S439>/Enable'
   */
  if (rtu_Enable > 0.0) {
    /* Gain: '<S439>/Gain3' incorporates:
     *  Sum: '<S439>/Sum'
     */
    rty_Out->re = ((rtu_In.re + rtu_In_d.re) + rtu_In_o.re) *
      0.33333333333333331;
    rty_Out->im = ((rtu_In.im + rtu_In_d.im) + rtu_In_o.im) *
      0.33333333333333331;
  }

  /* End of Outputs for SubSystem: '<S432>/Zero Seq. Computation' */
}

/*
 * Output and update for atomic system:
 *    '<S686>/MATLAB Function1'
 *    '<S687>/MATLAB Function1'
 *    '<S688>/MATLAB Function1'
 */
void MATLABFunction1(const real_T rtu_g[4], real_T rtu_Vdc, real_T rtu_Vdc_b,
                     const real_T rtu_I[2], real_T rty_V[2], real_T rty_Idc[2])
{
  real_T k2;
  real_T k1;
  real_T In;
  if (rtu_g[0] > rtu_g[1]) {
    k2 = rtu_g[1];
  } else {
    k2 = rtu_g[0];
  }

  if (rtu_g[3] > rtu_g[2]) {
    k1 = rtu_g[2];
  } else {
    k1 = rtu_g[3];
  }

  /* SignalConversion: '<S690>/TmpSignal ConversionAt SFunction Inport2' */
  rty_V[0] = (1.0 - rtu_g[2]) * rtu_Vdc + -k1 * rtu_Vdc_b;
  rty_V[1] = (1.0 - rtu_g[1]) * rtu_Vdc_b + -k2 * rtu_Vdc;
  In = rtu_I[1] - rtu_I[0];
  if (In >= 0.0) {
    rty_Idc[0] = k2 * In + rtu_I[0];
    rty_Idc[1] = rtu_g[1] * In - rtu_I[1];
  } else {
    rty_Idc[0] = -rtu_g[2] * In - rtu_I[0];
    rty_Idc[1] = -k1 * In - rtu_I[1];
  }

  if ((rtu_g[2] + rtu_g[3] == 2.0) && (rtu_g[1] == 1.0) && (rtu_g[0] == 0.0)) {
    rty_Idc[0] = 0.0;
    rty_Idc[1] = rtu_I[1];

    /* SignalConversion: '<S690>/TmpSignal ConversionAt SFunction Inport2' */
    rty_V[0] = -rtu_Vdc_b;
    rty_V[1] = 0.0;
  }

  k2 = rtu_g[0] + rtu_g[1];
  if ((k2 == 2.0) && (rtu_g[2] == 1.0) && (rtu_g[3] == 0.0)) {
    rty_Idc[0] = rtu_I[0];
    rty_Idc[1] = 0.0;
    rty_V[0] = 0.0;

    /* SignalConversion: '<S690>/TmpSignal ConversionAt SFunction Inport2' */
    rty_V[1] = -rtu_Vdc;
  }

  if ((k2 + rtu_g[2]) + rtu_g[3] == 4.0) {
    rty_Idc[0] = rtu_I[0];
    rty_Idc[1] = rtu_I[1];

    /* SignalConversion: '<S690>/TmpSignal ConversionAt SFunction Inport2' */
    rty_V[0] = -rtu_Vdc_b;
    rty_V[1] = -rtu_Vdc;
  }
}

real_T rt_remd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T u1_0;
  if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {
    y = (rtNaN);
  } else if (rtIsInf(u1)) {
    y = u0;
  } else {
    if (u1 < 0.0) {
      u1_0 = ceil(u1);
    } else {
      u1_0 = floor(u1);
    }

    if ((u1 != 0.0) && (u1 != u1_0)) {
      u1_0 = fabs(u0 / u1);
      if (fabs(u1_0 - floor(u1_0 + 0.5)) <= DBL_EPSILON * u1_0) {
        y = 0.0 * u0;
      } else {
        y = fmod(u0, u1);
      }
    } else {
      y = fmod(u0, u1);
    }
  }

  return y;
}

real_T rt_hypotd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T a;
  a = fabs(u0);
  y = fabs(u1);
  if (a < y) {
    a /= y;
    y *= sqrt(a * a + 1.0);
  } else if (a > y) {
    y /= a;
    y = sqrt(y * y + 1.0) * a;
  } else {
    if (!rtIsNaN(y)) {
      y = a * 1.4142135623730951;
    }
  }

  return y;
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  int32_T u0_0;
  int32_T u1_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    if (u0 > 0.0) {
      u0_0 = 1;
    } else {
      u0_0 = -1;
    }

    if (u1 > 0.0) {
      u1_0 = 1;
    } else {
      u1_0 = -1;
    }

    y = atan2(u0_0, u1_0);
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }

  return y;
}

/* Model step function for TID0 */
void power_converters_switching_function_step0(void) /* Sample time: [5.0E-6s, 0.0s] */
{
  real_T HoldSine;
  real_T rtb_ComplextoMagnitudeAngle__nj;
  boolean_T rtb_Amplitude;
  real_T rtb_Product1[4];
  real_T rtb_UnitDelay5_o;
  real_T rtb_sinwt;
  real_T rtb_Product1_eq[3];
  real_T rtb_UnitDelay_ai[3];
  real_T rtb_UnitDelay7_b;
  real_T rtb_Product1_fq[3];
  real_T rtb_UnitDelay6_e;
  real_T rtb_UnitDelay5_di;
  real_T rtb_UnitDelay5_f;
  real_T rtb_UnitDelay5_h0;
  real_T rtb_UnitDelay4_c;
  real_T rtb_UnitDelay5_aw;
  real_T rtb_UnitDelay5_l;
  real_T rtb_UnitDelay5_de;
  real_T rtb_UnitDelay5_e;
  real_T rtb_UnitDelay5_a2;
  real_T rtb_UnitDelay5_g;
  real_T rtb_UnitDelay4_lk;
  real_T rtb_Product1_a3;
  real_T rtb_Product_jl;
  real_T rtb_Product1_cj;
  real_T rtb_Product_e;
  real_T rtb_Product1_cu;
  real_T rtb_UnitDelay4_h[3];
  real_T rtb_Product_bk;
  real_T rtb_Product1_om;
  real_T rtb_Product_gi;
  real_T rtb_Product1_m1;
  real_T rtb_Product_o;
  real_T rtb_Product1_ly;
  real_T rtb_UnitDelay3[3];
  real_T rtb_UnitDelay1_d[3];
  real_T rtb_phi;
  real_T rtb_Product_kx;
  real_T rtb_Product1_a;
  real_T rtb_Product_h5;
  real_T rtb_Product1_dm;
  real_T rtb_Product_gk;
  real_T rtb_Product1_id;
  real_T rtb_Switch_lo;
  real_T rtb_Switch_pa;
  real_T rtb_Switch_pt;
  real_T rtb_Product_f;
  real_T rtb_Product1_aw;
  real_T rtb_Product_h4;
  real_T rtb_Product1_iv;
  real_T rtb_phi_b;
  real_T rtb_Product1_fg;
  real_T rtb_Product_aa;
  real_T rtb_Product1_if;
  real_T rtb_Product_p;
  real_T rtb_Product1_b4;
  real_T rtb_Product_bo;
  real_T rtb_Product1_c5;
  real_T rtb_Product_i;
  real_T rtb_Product1_ol;
  real_T rtb_Product_lv;
  real_T rtb_Product1_jq;
  real_T rtb_phi_f;
  real_T rtb_Add;
  real_T rtb_UnitDelay5_ax;
  real_T rtb_B11_h;
  real_T rtb_B21_n;
  real_T rtb_sum3_d;
  real_T rtb_B11_n;
  real_T rtb_B21_h;
  real_T rtb_Fieldarmaturemutualinductan;
  real_T rtb_Product1_hh;
  real_T rtb_Product_g;
  real_T rtb_Product1_m4;
  real_T rtb_Product_h;
  real_T rtb_Product1_cr;
  real_T rtb_Product_mv;
  real_T rtb_Product1_ec;
  real_T rtb_Product_db;
  real_T rtb_Product1_lp5;
  real_T rtb_Product_cki;
  real_T rtb_Product1_gf;
  real_T rtb_Product_jn;
  real_T rtb_Product1_l2;
  real_T rtb_Product_ae;
  real_T rtb_Product1_oo;
  real_T rtb_Product_d;
  real_T rtb_Product1_aa;
  real_T rtb_Product_p5i;
  real_T rtb_Product1_mm;
  real_T rtb_Product_d3;
  real_T rtb_Product1_e5;
  real_T rtb_Product_m;
  real_T rtb_Product1_d;
  real_T rtb_Product_k;
  real_T rtb_Product1_le;
  real_T rtb_Product_a;
  real_T rtb_Product1_e;
  real_T rtb_Product_jv;
  real_T rtb_Product1_br;
  real_T rtb_Product_kb;
  real_T rtb_Product1_ce;
  real_T rtb_Product_pg;
  real_T rtb_Product1_pz;
  real_T rtb_Product_pk;
  real_T rtb_Uref2;
  boolean_T rtb_DataTypeConversion2;
  real_T rtb_UnitDelay1[2];
  real_T rtb_Fcn_iz;
  real_T rtb_Fcn1;
  real_T rtb_UnitDelay1_no[2];
  real_T rtb_Switch_p;
  real_T rtb_Switch_j5;
  real_T rtb_Switch_a4;
  real_T rtb_Switch_lc;
  real_T rtb_Switch_d5;
  real_T rtb_Switch_g;
  real_T rtb_Switch_i;
  real_T rtb_Switch_fr;
  real_T rtb_Switch_b;
  real_T rtb_Switch_f;
  real_T rtb_Switch_fz;
  real_T rtb_Switch_c;
  real_T rtb_Switch_d;
  real_T rtb_Switch_a;
  real_T rtb_Switch_kul;
  real_T rtb_Switch_lu;
  real_T rtb_Switch_pr;
  real_T rtb_Switch_ly;
  real_T rtb_Switch_o;
  real_T rtb_Switch_of;
  real_T rtb_Switch_eu;
  real_T rtb_Switch_e;
  real_T rtb_Switch_ec;
  real_T rtb_Switch_nl;
  real_T rtb_Switch_h;
  real_T rtb_Switch_on;
  real_T rtb_Switch_m;
  real_T rtb_Switch_fc;
  real_T rtb_Switch_id;
  real_T rtb_Switch_lq;
  real_T rtb_Switch_p0;
  real_T rtb_Switch_k;
  real_T rtb_Switch_kp;
  real_T rtb_Add8;
  real_T rtb_Switch2;
  real_T rtb_Switch3;
  creal_T rtb_RealImagtoComplex_l;
  creal_T rtb_MagnitudeAngletoComplex;
  creal_T rtb_MagnitudeAngletoComplex1;
  creal_T Gain3_gs;
  boolean_T rtb_LogicalOperator4_d;
  boolean_T rtb_LogicalOperator4_g_idx_0;
  int32_T rtb_MultiportSwitch4_idx_3;
  int32_T rtb_MultiportSwitch3_idx_3;
  int32_T rtb_MultiportSwitch4_idx_2;
  int32_T rtb_MultiportSwitch3_idx_2;
  int32_T rtb_MultiportSwitch4_idx_1;
  int32_T rtb_MultiportSwitch3_idx_1;
  int32_T rtb_MultiportSwitch4_idx_0;
  int32_T rtb_MultiportSwitch3_idx_0;
  boolean_T rtb_RelationalOperator2_k_idx_0;
  real_T rtb_Product3_h_tmp;
  real_T rtb_Product2_tmp;
  real_T rtb_Product1_g_tmp;

  /* Update the flag to indicate when data transfers from
   *  Sample time: [5.0E-6s, 0.0s] to Sample time: [5.0E-5s, 0.0s]  */
  rtM->Timing.perTaskSampleHits[1] = (rtM->Timing.RateInteraction.TID0_1 == 0);
  (rtM->Timing.RateInteraction.TID0_1)++;
  if ((rtM->Timing.RateInteraction.TID0_1) > 9) {
    rtM->Timing.RateInteraction.TID0_1 = 0;
  }

  /* S-Function (sfun_spssw_discc): '<S953>/State-Space' incorporates:
   *  Constant: '<S354>/DC'
   */

  /* S-Function block: <S953>/State-Space */
  {
    real_T accum;

    /*
     * Compute outputs:
     * ---------------
     */
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK.DS;
    accum = 0.0;
    accum += *(Cs++) * rtDW.StateSpace_DSTATE;
    accum += *(Ds++) * 500.0;
    rtDW.StateSpace = accum;
  }

  /* Sin: '<S5>/Uref2' */
  if (rtDW.systemEnable != 0) {
    rtb_Uref2 = 314.15926535897933 * rtM->Timing.t[0];
    rtDW.lastSin = sin(rtb_Uref2);
    rtDW.lastCos = cos(rtb_Uref2);
    rtDW.systemEnable = 0;
  }

  rtb_Uref2 = ((rtDW.lastSin * 0.99999876629970352 + rtDW.lastCos *
                -0.0015707956808308789) * 0.99999876629970352 + (rtDW.lastCos *
    0.99999876629970352 - rtDW.lastSin * -0.0015707956808308789) *
               0.0015707956808308789) * 0.9;

  /* End of Sin: '<S5>/Uref2' */

  /* Outputs for Enabled SubSystem: '<S81>/PWM gen' incorporates:
   *  EnablePort: '<S157>/Enable'
   */
  if (!rtDW.PWMgen_MODE) {
    /* Enable for DiscreteIntegrator: '<S162>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_b4 = 1U;

    /* Enable for DiscreteIntegrator: '<S164>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ke4 = 1U;
    rtDW.PWMgen_MODE = true;
  }

  /* DigitalClock: '<S175>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Sum: '<S175>/Add1' incorporates:
   *  Constant: '<S175>/Constant3'
   */
  rtb_UnitDelay6_e += 0.00015151515151515152;

  /* Math: '<S175>/Math Function' incorporates:
   *  Constant: '<S175>/Constant1'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.00060606060606060606);

  /* Gain: '<S175>/1\ib1' */
  rtb_UnitDelay6_e *= 1650.0;

  /* Lookup_n-D: '<S175>/1-D Lookup Table' */
  rtb_UnitDelay6_e = look1_pbinlx(rtb_UnitDelay6_e, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex_c, 2U);

  /* Product: '<S166>/MUL1' incorporates:
   *  Constant: '<S175>/Constant2'
   *  Sum: '<S175>/Add3'
   */
  rtb_UnitDelay6_e--;

  /* Sum: '<S166>/Add4' */
  rtb_UnitDelay6_e = (-1.0 + rtb_UnitDelay6_e) + 1.0;

  /* RelationalOperator: '<S170>/Relational Operator1' */
  rtb_DataTypeConversion2 = (rtb_Uref2 >= rtb_UnitDelay6_e);

  /* RelationalOperator: '<S170>/Relational Operator3' incorporates:
   *  Gain: '<S170>/Gain'
   */
  rtb_Amplitude = (-rtb_Uref2 >= rtb_UnitDelay6_e);

  /* DataTypeConversion: '<S161>/Data Type Conversion' incorporates:
   *  Logic: '<S161>/Logical Operator4'
   */
  rtDW.DataTypeConversion_o[0] = rtb_DataTypeConversion2;
  rtDW.DataTypeConversion_o[1] = !rtb_DataTypeConversion2;
  rtDW.DataTypeConversion_o[2] = rtb_Amplitude;
  rtDW.DataTypeConversion_o[3] = !rtb_Amplitude;

  /* DiscreteIntegrator: '<S162>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_b4 != 0) {
    rtDW.Integ4_m0 = rtDW.Integ4_DSTATE_f0;
  } else {
    rtDW.Integ4_m0 = 2.5E-6 * rtDW.DataTypeConversion_o[0] +
      rtDW.Integ4_DSTATE_f0;
  }

  /* End of DiscreteIntegrator: '<S162>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S163>/S-Function' incorporates:
   *  Constant: '<S162>/K1'
   */

  /* Level2 S-Function Block: '<S163>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S164>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ke4 != 0) {
    rtDW.Integ4_jq = rtDW.Integ4_DSTATE_b0;
  } else {
    rtDW.Integ4_jq = 2.5E-6 * rtDW.DataTypeConversion_o[2] +
      rtDW.Integ4_DSTATE_b0;
  }

  /* End of DiscreteIntegrator: '<S164>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S165>/S-Function' incorporates:
   *  Constant: '<S164>/K1'
   */

  /* Level2 S-Function Block: '<S165>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S162>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_b4 = 0U;
  rtDW.Integ4_DSTATE_f0 = 2.5E-6 * rtDW.DataTypeConversion_o[0] + rtDW.Integ4_m0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S163>/S-Function' incorporates:
   *  Constant: '<S162>/K1'
   */
  /* Level2 S-Function Block: '<S163>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S164>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ke4 = 0U;
  rtDW.Integ4_DSTATE_b0 = 2.5E-6 * rtDW.DataTypeConversion_o[2] + rtDW.Integ4_jq;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S165>/S-Function' incorporates:
   *  Constant: '<S164>/K1'
   */
  /* Level2 S-Function Block: '<S165>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S81>/PWM gen' */

  /* Step: '<S5>/Block4' */
  rtb_ComplextoMagnitudeAngle__nj = (rtM->Timing.t[0] < 0.05);

  /* RelationalOperator: '<S367>/Compare' incorporates:
   *  Constant: '<S367>/Constant'
   */
  rtb_Amplitude = (rtb_ComplextoMagnitudeAngle__nj <= 0.5);

  /* Saturate: '<S366>/Saturation' */
  if (rtDW.DataTypeConversion_o[0] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_o[0] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_o[0];
  }

  /* Product: '<S366>/Product1' incorporates:
   *  DataTypeConversion: '<S366>/Data Type Conversion1'
   */
  rtb_Product1[0] = HoldSine * (real_T)rtb_Amplitude;

  /* Saturate: '<S366>/Saturation' */
  if (rtDW.DataTypeConversion_o[1] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_o[1] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_o[1];
  }

  /* Product: '<S366>/Product1' incorporates:
   *  DataTypeConversion: '<S366>/Data Type Conversion1'
   */
  rtb_Product1[1] = HoldSine * (real_T)rtb_Amplitude;

  /* Saturate: '<S366>/Saturation' */
  if (rtDW.DataTypeConversion_o[2] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_o[2] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_o[2];
  }

  /* Product: '<S366>/Product1' incorporates:
   *  DataTypeConversion: '<S366>/Data Type Conversion1'
   */
  rtb_Product1[2] = HoldSine * (real_T)rtb_Amplitude;

  /* Saturate: '<S366>/Saturation' */
  if (rtDW.DataTypeConversion_o[3] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_o[3] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_o[3];
  }

  /* Product: '<S366>/Product1' incorporates:
   *  DataTypeConversion: '<S366>/Data Type Conversion1'
   */
  rtb_Product1[3] = HoldSine * (real_T)rtb_Amplitude;

  /* UnitDelay: '<S370>/Unit Delay5' */
  rtb_Uref2 = rtDW.UnitDelay5_DSTATE;

  /* Sum: '<S370>/Add8' incorporates:
   *  Gain: '<S370>/Gain4'
   *  UnitDelay: '<S370>/Unit Delay6'
   */
  rtb_Add8 = 2.0 * rtb_Uref2 - rtDW.UnitDelay6_DSTATE;

  /* UnitDelay: '<S366>/Unit Delay1' */
  rtb_UnitDelay1[0] = rtDW.UnitDelay1_DSTATE[0];

  /* MATLAB Function: '<S366>/MATLAB Function3' incorporates:
   *  UnitDelay: '<S366>/Unit Delay1'
   */
  rtb_UnitDelay5_o = (rtb_Product1[1] + rtb_Product1[2]) - 1.0;
  rtDW.V_ji[0] = -rtb_UnitDelay5_o * rtb_Add8;
  rtb_Fcn_iz = (rtb_Product1[0] + rtb_Product1[3]) - 1.0;
  rtDW.V_ji[1] = -rtb_Fcn_iz * rtb_Add8;
  rtDW.Idc_jt = rtb_UnitDelay5_o * rtb_UnitDelay1[0] + rtb_Fcn_iz *
    rtDW.UnitDelay1_DSTATE[1];
  if (((rtb_Product1[0] + rtb_Product1[1]) + rtb_Product1[2]) + rtb_Product1[3] ==
      4.0) {
    rtDW.Idc_jt = rtb_UnitDelay1[0];
    rtDW.V_ji[0] = -rtb_Add8;
    rtDW.V_ji[1] = -rtb_Add8;
  }

  /* End of MATLAB Function: '<S366>/MATLAB Function3' */

  /* S-Function (sfun_spssw_discc): '<S954>/State-Space' incorporates:
   *  Constant: '<S381>/eee'
   *  Constant: '<S383>/eee'
   *  Constant: '<S959>/SwitchCurrents'
   */

  /* S-Function block: <S954>/State-Space */
  {
    real_T accum;

    /* Circuit has switches */
    int_T *switch_status = (int_T*) rtDW.StateSpace_PWORK_n.SWITCH_STATUS;
    int_T *switch_status_init = (int_T*)
      rtDW.StateSpace_PWORK_n.SWITCH_STATUS_INIT;
    int_T *SwitchChange = (int_T*) rtDW.StateSpace_PWORK_n.SW_CHG;
    int_T *gState = (int_T*) rtDW.StateSpace_PWORK_n.G_STATE;
    real_T *yswitch = (real_T*)rtDW.StateSpace_PWORK_n.Y_SWITCH;
    int_T *switchTypes = (int_T*) rtDW.StateSpace_PWORK_n.SWITCH_TYPES;
    int_T *idxOutSw = (int_T*) rtDW.StateSpace_PWORK_n.IDX_OUT_SW;
    real_T *DxCol = (real_T*)rtDW.StateSpace_PWORK_n.DX_COL;
    real_T *tmp2 = (real_T*)rtDW.StateSpace_PWORK_n.TMP2;
    real_T *BDcol = (real_T*)rtDW.StateSpace_PWORK_n.BD_COL;
    real_T *tmp1 = (real_T*)rtDW.StateSpace_PWORK_n.TMP1;
    real_T *uswlast = (real_T*)rtDW.StateSpace_PWORK_n.USWLAST;
    int_T newState;
    int_T swChanged = 0;
    int loopsToDo = 20;
    real_T temp;

    /* keep an initial copy of switch_status*/
    memcpy(switch_status_init, switch_status, 2 * sizeof(int_T));
    memcpy(uswlast, &rtDW.StateSpace_o1[0], 2*sizeof(real_T));
    do {
      if (loopsToDo == 1) {            /* Need to reset some variables: */
        swChanged = 0;

        /* return to the original switch status*/
        {
          int_T i1;
          for (i1=0; i1 < 2; i1++) {
            swChanged = ((SwitchChange[i1] = switch_status_init[i1] -
                          switch_status[i1]) != 0) ? 1 : swChanged;
            switch_status[i1] = switch_status_init[i1];
          }
        }
      } else {
        /*
         * Compute outputs:
         * ---------------
         */
        real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
        real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;

        {
          int_T i1;
          real_T *y0 = &rtDW.StateSpace_o1[0];
          for (i1=0; i1 < 6; i1++) {
            accum = 0.0;
            accum += *(Cs++) * rtDW.StateSpace_DSTATE_d[0];
            accum += *(Cs++) * rtDW.StateSpace_DSTATE_d[1];
            accum += *(Ds++) * (0.0);
            accum += *(Ds++) * (0.0);
            accum += *(Ds++) * rtDW.V_ji[1];
            accum += *(Ds++) * rtDW.V_ji[0];
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            y0[i1] = accum;
          }
        }

        swChanged = 0;

        /* Diodes */
        newState = rtDW.StateSpace_o1[0] > 0.0 ? 1 : ((rtDW.StateSpace_o1[0] <
          0.0) ? 0 : switch_status[0]);
        swChanged = ((SwitchChange[0] = newState - switch_status[0]) != 0) ? 1 :
          swChanged;
        switch_status[0] = newState;   /* Keep new state */

        /* Diodes */
        newState = rtDW.StateSpace_o1[1] > 0.0 ? 1 : ((rtDW.StateSpace_o1[1] <
          0.0) ? 0 : switch_status[1]);
        swChanged = ((SwitchChange[1] = newState - switch_status[1]) != 0) ? 1 :
          swChanged;
        switch_status[1] = newState;   /* Keep new state */
      }

      /*
       * Compute new As, Bs, Cs and Ds matrixes:
       * --------------------------------------
       */
      if (swChanged) {
        real_T *As = (real_T*)rtDW.StateSpace_PWORK_n.AS;
        real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
        real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_n.BS;
        real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;
        real_T a1;

        {
          int_T i1;
          for (i1=0; i1 < 2; i1++) {
            if (SwitchChange[i1] != 0) {
              a1 = 1000.0*SwitchChange[i1];
              temp = 1/(1-Ds[i1*7]*a1);

              {
                int_T i2;
                for (i2=0; i2 < 6; i2++) {
                  DxCol[i2]= Ds[i2 * 6 + i1]*temp*a1;
                }
              }

              DxCol[i1] = temp;
              BDcol[0]= Bs[0 + i1]*a1;
              BDcol[1]= Bs[6 + i1]*a1;

              /* Copy row nSw of Cs into tmp1 and zero it out in Cs */
              memcpy(tmp1, &Cs[i1 * 2], 2 * sizeof(real_T));
              memset(&Cs[i1 * 2], '\0', 2 * sizeof(real_T));

              /* Copy row nSw of Ds into tmp2 and zero it out in Ds */
              memcpy(tmp2, &Ds[i1 * 6], 6 * sizeof(real_T));
              memset(&Ds[i1 * 6], '\0', 6 * sizeof(real_T));

              /* Cs = Cs + DxCol * tmp1, Ds = Ds + DxCol * tmp2 *******************/
              {
                int_T i2;
                for (i2=0; i2 < 6; i2++) {
                  a1 = DxCol[i2];
                  Cs[i2 * 2 + 0] += a1 * tmp1[0];
                  Cs[i2 * 2 + 1] += a1 * tmp1[1];

                  {
                    int_T i3;
                    for (i3=0; i3 < 6; i3++) {
                      Ds[i2 * 6 + i3] += a1 * tmp2[i3];
                    }
                  }
                }
              }

              /* As = As + BdCol*Cs(nSw,:), Bs = Bs + BdCol*Ds(nSw,:) *************/
              a1 = BDcol[0];
              As[0 + 0] += a1 * Cs[i1 * 2 + 0];
              As[0 + 1] += a1 * Cs[i1 * 2 + 1];

              {
                int_T i2;
                for (i2=0; i2 < 6; i2++) {
                  Bs[0 + i2] += a1 * Ds[i1 * 6 + i2];
                }
              }

              a1 = BDcol[1];
              As[2 + 0] += a1 * Cs[i1 * 2 + 0];
              As[2 + 1] += a1 * Cs[i1 * 2 + 1];

              {
                int_T i2;
                for (i2=0; i2 < 6; i2++) {
                  Bs[6 + i2] += a1 * Ds[i1 * 6 + i2];
                }
              }
            }
          }
        }
      }                                /* if (swChanged) */
    } while (swChanged > 0 && --loopsToDo > 0);

    if (loopsToDo == 0) {
      real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
      real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;

      {
        int_T i1;
        real_T *y0 = &rtDW.StateSpace_o1[0];
        for (i1=0; i1 < 6; i1++) {
          accum = 0.0;
          accum += *(Cs++) * rtDW.StateSpace_DSTATE_d[0];
          accum += *(Cs++) * rtDW.StateSpace_DSTATE_d[1];
          accum += *(Ds++) * (0.0);
          accum += *(Ds++) * (0.0);
          accum += *(Ds++) * rtDW.V_ji[1];
          accum += *(Ds++) * rtDW.V_ji[0];
          accum += *(Ds++) * 0.001;
          accum += *(Ds++) * 0.001;
          y0[i1] = accum;
        }
      }
    }

    /* Output new switches states */
    rtDW.StateSpace_o2[0] = (real_T)switch_status[0];
    rtDW.StateSpace_o2[1] = (real_T)switch_status[1];
  }

  /* Sin: '<Root>/Vload' */
  if (rtDW.systemEnable_d != 0) {
    rtb_Add8 = 31.415926535897931 * rtM->Timing.t[0];
    rtDW.lastSin_n = sin(rtb_Add8);
    rtDW.lastCos_f = cos(rtb_Add8);
    rtDW.systemEnable_d = 0;
  }

  rtDW.Vload = ((rtDW.lastSin_n * 0.99999998766299447 + rtDW.lastCos_f *
                 -0.00015707963203352558) * 0.99999998766299447 +
                (rtDW.lastCos_f * 0.99999998766299447 - rtDW.lastSin_n *
                 -0.00015707963203352558) * 0.00015707963203352558) * 50.0 +
    500.0;

  /* End of Sin: '<Root>/Vload' */

  /* Outputs for Enabled SubSystem: '<S80>/PWM Gen' incorporates:
   *  EnablePort: '<S149>/Enable'
   */
  if (!rtDW.PWMGen_MODE) {
    /* Enable for DiscreteIntegrator: '<S152>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_lr = 1U;
    rtDW.PWMGen_MODE = true;
  }

  /* DigitalClock: '<S156>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Math: '<S156>/Math Function' incorporates:
   *  Constant: '<S156>/Constant2'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.0005);

  /* DataTypeConversion: '<S151>/Data Type Conversion' incorporates:
   *  Constant: '<S5>/Duty cycle1'
   *  Fcn: '<S151>/Fcn'
   *  Fcn: '<S156>/Fcn'
   *  Gain: '<S156>/1\ib1'
   *  RelationalOperator: '<S151>/Relational Operator'
   */
  rtDW.DataTypeConversion_j = (0.55 >= ((2000.0 * rtb_UnitDelay6_e * 2.0 - 1.0)
    + 1.0) * 0.5);

  /* DiscreteIntegrator: '<S152>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_lr != 0) {
    rtDW.Integ4_jx = rtDW.Integ4_DSTATE_m0;
  } else {
    rtDW.Integ4_jx = 2.5E-6 * rtDW.DataTypeConversion_j + rtDW.Integ4_DSTATE_m0;
  }

  /* End of DiscreteIntegrator: '<S152>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */

  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S152>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_lr = 0U;
  rtDW.Integ4_DSTATE_m0 = 2.5E-6 * rtDW.DataTypeConversion_j + rtDW.Integ4_jx;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */
  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S80>/PWM Gen' */

  /* UnitDelay: '<S65>/Unit Delay5' */
  rtb_Add8 = rtDW.UnitDelay5_DSTATE_g;

  /* Saturate: '<S61>/Saturation' */
  if (rtDW.DataTypeConversion_j > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_j < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_j;
  }

  /* End of Saturate: '<S61>/Saturation' */

  /* MATLAB Function: '<S61>/MATLAB Function4' incorporates:
   *  Constant: '<S63>/Constant'
   *  DataTypeConversion: '<S61>/Data Type Conversion1'
   *  Gain: '<S65>/Gain4'
   *  Product: '<S61>/Product1'
   *  RelationalOperator: '<S63>/Compare'
   *  Sum: '<S65>/Add8'
   *  UnitDelay: '<S61>/Unit Delay1'
   *  UnitDelay: '<S65>/Unit Delay6'
   */
  MATLABFunction4(HoldSine * (real_T)(rtb_ComplextoMagnitudeAngle__nj <= 0.5),
                  2.0 * rtb_Add8 - rtDW.UnitDelay6_DSTATE_h,
                  rtDW.UnitDelay1_DSTATE_k, &rtDW.V_jp, &rtDW.Idc_b);

  /* Outputs for Enabled SubSystem: '<S79>/PWM Gen' incorporates:
   *  EnablePort: '<S141>/Enable'
   */
  if (!rtDW.PWMGen_MODE_e) {
    /* Enable for DiscreteIntegrator: '<S144>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_gy2 = 1U;
    rtDW.PWMGen_MODE_e = true;
  }

  /* DigitalClock: '<S148>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Math: '<S148>/Math Function' incorporates:
   *  Constant: '<S148>/Constant2'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.0005);

  /* DataTypeConversion: '<S143>/Data Type Conversion' incorporates:
   *  Constant: '<S5>/Duty cycle2'
   *  Fcn: '<S143>/Fcn'
   *  Fcn: '<S148>/Fcn'
   *  Gain: '<S148>/1\ib1'
   *  RelationalOperator: '<S143>/Relational Operator'
   */
  rtDW.DataTypeConversion_ob = (0.8 >= ((2000.0 * rtb_UnitDelay6_e * 2.0 - 1.0)
    + 1.0) * 0.5);

  /* DiscreteIntegrator: '<S144>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gy2 != 0) {
    rtDW.Integ4_hv = rtDW.Integ4_DSTATE_dd;
  } else {
    rtDW.Integ4_hv = 2.5E-6 * rtDW.DataTypeConversion_ob + rtDW.Integ4_DSTATE_dd;
  }

  /* End of DiscreteIntegrator: '<S144>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S145>/S-Function' incorporates:
   *  Constant: '<S144>/K1'
   */

  /* Level2 S-Function Block: '<S145>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S144>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gy2 = 0U;
  rtDW.Integ4_DSTATE_dd = 2.5E-6 * rtDW.DataTypeConversion_ob + rtDW.Integ4_hv;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S145>/S-Function' incorporates:
   *  Constant: '<S144>/K1'
   */
  /* Level2 S-Function Block: '<S145>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S79>/PWM Gen' */

  /* UnitDelay: '<S47>/Unit Delay5' */
  rtb_UnitDelay5_o = rtDW.UnitDelay5_DSTATE_e;

  /* Saturate: '<S43>/Saturation' */
  if (rtDW.DataTypeConversion_ob > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_ob < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_ob;
  }

  /* End of Saturate: '<S43>/Saturation' */

  /* MATLAB Function: '<S43>/MATLAB Function4' incorporates:
   *  Constant: '<S45>/Constant'
   *  DataTypeConversion: '<S43>/Data Type Conversion1'
   *  Gain: '<S47>/Gain4'
   *  Product: '<S43>/Product1'
   *  RelationalOperator: '<S45>/Compare'
   *  Sum: '<S47>/Add8'
   *  UnitDelay: '<S43>/Unit Delay1'
   *  UnitDelay: '<S47>/Unit Delay6'
   */
  MATLABFunction4(HoldSine * (real_T)(rtb_ComplextoMagnitudeAngle__nj <= 0.5),
                  2.0 * rtb_UnitDelay5_o - rtDW.UnitDelay6_DSTATE_o,
                  rtDW.UnitDelay1_DSTATE_i, &rtDW.V_c, &rtDW.Idc_a2);

  /* Product: '<S346>/Product' incorporates:
   *  DiscreteIntegrator: '<S346>/Discrete-Time Integrator'
   *  UnitDelay: '<S346>/KE filter'
   */
  rtDW.Product = rtDW.DiscreteTimeIntegrator_DSTATE * rtDW.KEfilter_DSTATE;

  /* RateTransition: '<S83>/Rate Transition3' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition3[0] = rtDW.RateTransition3_Buffer0[0];
    rtDW.RateTransition3[1] = rtDW.RateTransition3_Buffer0[1];
  }

  /* End of RateTransition: '<S83>/Rate Transition3' */

  /* Sum: '<S250>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S250>/D*u(k)'
   *  Gain: '<S253>/C11'
   *  Gain: '<S253>/C12'
   *  Sum: '<S253>/sum2'
   *  UnitDelay: '<S250>/Delay_x1'
   *  UnitDelay: '<S250>/Delay_x2'
   *  UnitDelay: '<S83>/Unit Delay'
   */
  rtb_Fcn_iz = (444.06110962854092 * rtDW.Delay_x1_DSTATE +
                0.0010601835537138449 * rtDW.Delay_x2_DSTATE) +
    0.00053009177685692244 * rtDW.UnitDelay_DSTATE;

  /* Saturate: '<S194>/0.8 to 1.2 x Vnom_dc' */
  if (rtb_Fcn_iz > 1500.0) {
    rtb_Fcn_iz = 1500.0;
  } else {
    if (rtb_Fcn_iz < 500.0) {
      rtb_Fcn_iz = 500.0;
    }
  }

  /* End of Saturate: '<S194>/0.8 to 1.2 x Vnom_dc' */

  /* Product: '<S194>/Product' incorporates:
   *  Constant: '<S194>/Constant1'
   *  Gain: '<S194>/Gain1'
   */
  rtb_sinwt = 489.89794855663553 / (0.61237243569579447 * rtb_Fcn_iz);

  /* Product: '<S194>/Product1' incorporates:
   *  Constant: '<S83>/Constant'
   */
  rtb_Product1_eq[0] = rtDW.RateTransition3[0] * rtb_sinwt;
  rtb_Product1_eq[1] = rtDW.RateTransition3[1] * rtb_sinwt;
  rtb_Product1_eq[2] = 0.0 * rtb_sinwt;

  /* RateTransition: '<S83>/Rate Transition4' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition4 = rtDW.RateTransition4_Buffer0;
  }

  /* End of RateTransition: '<S83>/Rate Transition4' */

  /* Outputs for Enabled SubSystem: '<S262>/Subsystem1' */
  Subsystem1_i(0, &rtb_Product1_eq[0], rtDW.RateTransition4, &rtDW.Fcn_e,
               &rtDW.Fcn1_a);

  /* End of Outputs for SubSystem: '<S262>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S262>/Subsystem - pi//2 delay' */
  Subsystempi2delay_l(rtConstB.Compare_p, &rtb_Product1_eq[0],
                      rtDW.RateTransition4, &rtDW.Fcn_k, &rtDW.Fcn1_jb);

  /* End of Outputs for SubSystem: '<S262>/Subsystem - pi//2 delay' */

  /* SignalConversion: '<S261>/TmpSignal ConversionAtGain3Inport1' incorporates:
   *  Switch: '<S262>/Switch'
   */
  rtb_UnitDelay_ai[0] = rtDW.Fcn_k;
  rtb_UnitDelay_ai[1] = rtDW.Fcn1_jb;
  rtb_UnitDelay_ai[2] = rtb_Product1_eq[2];

  /* Gain: '<S261>/Gain3' */
  for (rtb_MultiportSwitch3_idx_0 = 0; rtb_MultiportSwitch3_idx_0 < 3;
       rtb_MultiportSwitch3_idx_0++) {
    rtb_Product1_fq[rtb_MultiportSwitch3_idx_0] =
      rtConstP.pooled59[rtb_MultiportSwitch3_idx_0 + 6] * rtb_UnitDelay_ai[2] +
      (rtConstP.pooled59[rtb_MultiportSwitch3_idx_0 + 3] * rtb_UnitDelay_ai[1] +
       rtConstP.pooled59[rtb_MultiportSwitch3_idx_0] * rtb_UnitDelay_ai[0]);
  }

  /* Outputs for Enabled SubSystem: '<S78>/PWMgen - Averaging' incorporates:
   *  EnablePort: '<S127>/Enable'
   */
  if (!rtDW.PWMgenAveraging_MODE) {
    /* Enable for DiscreteIntegrator: '<S132>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_jm = 1U;

    /* Enable for DiscreteIntegrator: '<S134>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_h0 = 1U;
    rtDW.PWMgenAveraging_MODE = true;
  }

  /* DigitalClock: '<S140>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Sum: '<S140>/Add1' incorporates:
   *  Constant: '<S140>/Constant3'
   */
  rtb_UnitDelay6_e += 0.00012626262626262626;

  /* Math: '<S140>/Math Function' incorporates:
   *  Constant: '<S140>/Constant1'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.000505050505050505);

  /* Gain: '<S140>/1\ib1' */
  rtb_UnitDelay6_e *= 1980.0;

  /* Lookup_n-D: '<S140>/1-D Lookup Table' */
  rtb_UnitDelay6_e = look1_pbinlx(rtb_UnitDelay6_e, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex_b, 2U);

  /* Sum: '<S140>/Add3' incorporates:
   *  Constant: '<S140>/Constant2'
   */
  rtb_UnitDelay6_e--;

  /* Fcn: '<S131>/Fcn' */
  rtb_Fcn_iz = (rtb_UnitDelay6_e + 1.0) * 0.5;

  /* Fcn: '<S131>/Fcn1' */
  rtb_Fcn1 = (rtb_UnitDelay6_e - 1.0) * 0.5;

  /* Outputs for Enabled SubSystem: '<S131>/Half bridge (1-ph) and 3-ph bridge' incorporates:
   *  EnablePort: '<S137>/Enable'
   */
  /* MultiPortSwitch: '<S131>/Multiport Switch2' incorporates:
   *  Gain: '<S261>/Gain3'
   *  RelationalOperator: '<S137>/Relational Operator1'
   *  RelationalOperator: '<S137>/Relational Operator3'
   *  Sum: '<S137>/Sum3'
   */
  rtb_UnitDelay_ai[0] = (rtb_Product1_fq[0] >= rtb_Fcn_iz) - (rtb_Product1_fq[0]
    <= rtb_Fcn1);
  rtb_UnitDelay_ai[1] = (rtb_Product1_fq[1] >= rtb_Fcn_iz) - (rtb_Product1_fq[1]
    <= rtb_Fcn1);
  rtb_UnitDelay_ai[2] = (rtb_Product1_fq[2] >= rtb_Fcn_iz) - (rtb_Product1_fq[2]
    <= rtb_Fcn1);

  /* End of Outputs for SubSystem: '<S131>/Half bridge (1-ph) and 3-ph bridge' */

  /* Sum: '<S138>/Sum' incorporates:
   *  Constant: '<S138>/Constant2'
   */
  rtb_UnitDelay_ai[0] = (int32_T)rtb_UnitDelay_ai[0] + 2;
  rtb_UnitDelay_ai[1] = (int32_T)rtb_UnitDelay_ai[1] + 2;
  rtb_UnitDelay_ai[2] = (int32_T)rtb_UnitDelay_ai[2] + 2;

  /* MultiPortSwitch: '<S138>/Multiport Switch' */
  switch ((int32_T)rtb_UnitDelay_ai[0]) {
   case 1:
    rtb_Product1[0] = 0.0;
    rtb_Product1[1] = 0.0;
    rtb_Product1[2] = 1.0;
    rtb_Product1[3] = 1.0;
    break;

   case 2:
    rtb_Product1[0] = 0.0;
    rtb_Product1[1] = 1.0;
    rtb_Product1[2] = 1.0;
    rtb_Product1[3] = 0.0;
    break;

   default:
    rtb_Product1[0] = 1.0;
    rtb_Product1[1] = 1.0;
    rtb_Product1[2] = 0.0;
    rtb_Product1[3] = 0.0;
    break;
  }

  /* End of MultiPortSwitch: '<S138>/Multiport Switch' */

  /* MultiPortSwitch: '<S138>/Multiport Switch3' */
  switch ((int32_T)rtb_UnitDelay_ai[1]) {
   case 1:
    rtb_MultiportSwitch3_idx_0 = 0;
    rtb_MultiportSwitch3_idx_1 = 0;
    rtb_MultiportSwitch3_idx_2 = 1;
    rtb_MultiportSwitch3_idx_3 = 1;
    break;

   case 2:
    rtb_MultiportSwitch3_idx_0 = 0;
    rtb_MultiportSwitch3_idx_1 = 1;
    rtb_MultiportSwitch3_idx_2 = 1;
    rtb_MultiportSwitch3_idx_3 = 0;
    break;

   default:
    rtb_MultiportSwitch3_idx_0 = 1;
    rtb_MultiportSwitch3_idx_1 = 1;
    rtb_MultiportSwitch3_idx_2 = 0;
    rtb_MultiportSwitch3_idx_3 = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S138>/Multiport Switch3' */

  /* MultiPortSwitch: '<S138>/Multiport Switch4' */
  switch ((int32_T)rtb_UnitDelay_ai[2]) {
   case 1:
    rtb_MultiportSwitch4_idx_0 = 0;
    rtb_MultiportSwitch4_idx_1 = 0;
    rtb_MultiportSwitch4_idx_2 = 1;
    rtb_MultiportSwitch4_idx_3 = 1;
    break;

   case 2:
    rtb_MultiportSwitch4_idx_0 = 0;
    rtb_MultiportSwitch4_idx_1 = 1;
    rtb_MultiportSwitch4_idx_2 = 1;
    rtb_MultiportSwitch4_idx_3 = 0;
    break;

   default:
    rtb_MultiportSwitch4_idx_0 = 1;
    rtb_MultiportSwitch4_idx_1 = 1;
    rtb_MultiportSwitch4_idx_2 = 0;
    rtb_MultiportSwitch4_idx_3 = 0;
    break;
  }

  /* End of MultiPortSwitch: '<S138>/Multiport Switch4' */

  /* DataTypeConversion: '<S131>/Data Type Conversion' */
  rtDW.DataTypeConversion_or[0] = rtb_Product1[0];
  rtDW.DataTypeConversion_or[4] = rtb_MultiportSwitch3_idx_0;
  rtDW.DataTypeConversion_or[8] = rtb_MultiportSwitch4_idx_0;
  rtDW.DataTypeConversion_or[1] = rtb_Product1[1];
  rtDW.DataTypeConversion_or[5] = rtb_MultiportSwitch3_idx_1;
  rtDW.DataTypeConversion_or[9] = rtb_MultiportSwitch4_idx_1;
  rtDW.DataTypeConversion_or[2] = rtb_Product1[2];
  rtDW.DataTypeConversion_or[6] = rtb_MultiportSwitch3_idx_2;
  rtDW.DataTypeConversion_or[10] = rtb_MultiportSwitch4_idx_2;
  rtDW.DataTypeConversion_or[3] = rtb_Product1[3];
  rtDW.DataTypeConversion_or[7] = rtb_MultiportSwitch3_idx_3;
  rtDW.DataTypeConversion_or[11] = rtb_MultiportSwitch4_idx_3;

  /* DiscreteIntegrator: '<S132>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jm != 0) {
    rtDW.Integ4_lh[0] = rtDW.Integ4_DSTATE_lf[0];
    rtDW.Integ4_lh[1] = rtDW.Integ4_DSTATE_lf[1];
    rtDW.Integ4_lh[2] = rtDW.Integ4_DSTATE_lf[2];
  } else {
    rtDW.Integ4_lh[0] = 2.5E-6 * rtDW.DataTypeConversion_or[0] +
      rtDW.Integ4_DSTATE_lf[0];
    rtDW.Integ4_lh[1] = 2.5E-6 * rtDW.DataTypeConversion_or[4] +
      rtDW.Integ4_DSTATE_lf[1];
    rtDW.Integ4_lh[2] = 2.5E-6 * rtDW.DataTypeConversion_or[8] +
      rtDW.Integ4_DSTATE_lf[2];
  }

  /* End of DiscreteIntegrator: '<S132>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */

  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S134>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_h0 != 0) {
    rtDW.Integ4_fe[0] = rtDW.Integ4_DSTATE_lk[0];
    rtDW.Integ4_fe[1] = rtDW.Integ4_DSTATE_lk[1];
    rtDW.Integ4_fe[2] = rtDW.Integ4_DSTATE_lk[2];
  } else {
    rtDW.Integ4_fe[0] = 2.5E-6 * rtDW.DataTypeConversion_or[3] +
      rtDW.Integ4_DSTATE_lk[0];
    rtDW.Integ4_fe[1] = 2.5E-6 * rtDW.DataTypeConversion_or[7] +
      rtDW.Integ4_DSTATE_lk[1];
    rtDW.Integ4_fe[2] = 2.5E-6 * rtDW.DataTypeConversion_or[11] +
      rtDW.Integ4_DSTATE_lk[2];
  }

  /* End of DiscreteIntegrator: '<S134>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S135>/S-Function' incorporates:
   *  Constant: '<S134>/K1'
   */

  /* Level2 S-Function Block: '<S135>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S132>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jm = 0U;
  rtDW.Integ4_DSTATE_lf[0] = 2.5E-6 * rtDW.DataTypeConversion_or[0] +
    rtDW.Integ4_lh[0];
  rtDW.Integ4_DSTATE_lf[1] = 2.5E-6 * rtDW.DataTypeConversion_or[4] +
    rtDW.Integ4_lh[1];
  rtDW.Integ4_DSTATE_lf[2] = 2.5E-6 * rtDW.DataTypeConversion_or[8] +
    rtDW.Integ4_lh[2];

  /* Update for S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */
  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S134>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h0 = 0U;
  rtDW.Integ4_DSTATE_lk[0] = 2.5E-6 * rtDW.DataTypeConversion_or[3] +
    rtDW.Integ4_fe[0];
  rtDW.Integ4_DSTATE_lk[1] = 2.5E-6 * rtDW.DataTypeConversion_or[7] +
    rtDW.Integ4_fe[1];
  rtDW.Integ4_DSTATE_lk[2] = 2.5E-6 * rtDW.DataTypeConversion_or[11] +
    rtDW.Integ4_fe[2];

  /* Update for S-Function (sfun_discreteVariableDelay): '<S135>/S-Function' incorporates:
   *  Constant: '<S134>/K1'
   */
  /* Level2 S-Function Block: '<S135>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S78>/PWMgen - Averaging' */

  /* Step: '<S5>/Block1' */
  rtb_sinwt = !(rtM->Timing.t[0] < 999.0);

  /* DataTypeConversion: '<S688>/Data Type Conversion1' incorporates:
   *  Constant: '<S733>/Constant'
   *  RelationalOperator: '<S733>/Compare'
   */
  rtb_UnitDelay7_b = (rtb_sinwt <= 0.5);

  /* Saturate: '<S688>/Saturation' */
  if (rtDW.DataTypeConversion_or[8] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[8] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[8];
  }

  /* Product: '<S688>/Product4' */
  rtb_Product1[0] = HoldSine * rtb_UnitDelay7_b;

  /* Saturate: '<S688>/Saturation' */
  if (rtDW.DataTypeConversion_or[9] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[9] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[9];
  }

  /* Product: '<S688>/Product4' */
  rtb_Product1[1] = HoldSine * rtb_UnitDelay7_b;

  /* Saturate: '<S688>/Saturation' */
  if (rtDW.DataTypeConversion_or[10] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[10] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[10];
  }

  /* Product: '<S688>/Product4' */
  rtb_Product1[2] = HoldSine * rtb_UnitDelay7_b;

  /* Saturate: '<S688>/Saturation' */
  if (rtDW.DataTypeConversion_or[11] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[11] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[11];
  }

  /* Product: '<S688>/Product4' */
  rtb_Product1[3] = HoldSine * rtb_UnitDelay7_b;

  /* UnitDelay: '<S736>/Unit Delay5' */
  rtb_Fcn_iz = rtDW.UnitDelay5_DSTATE_c;

  /* UnitDelay: '<S736>/Unit Delay4' */
  rtb_Fcn1 = rtDW.UnitDelay4_DSTATE;

  /* UnitDelay: '<S688>/Unit Delay1' */
  rtb_UnitDelay1[0] = rtDW.UnitDelay1_DSTATE_ky[0];
  rtb_UnitDelay1[1] = rtDW.UnitDelay1_DSTATE_ky[1];

  /* MATLAB Function: '<S688>/MATLAB Function1' incorporates:
   *  Gain: '<S736>/Gain4'
   *  Gain: '<S736>/Gain5'
   *  Sum: '<S736>/Add8'
   *  Sum: '<S736>/Add9'
   *  UnitDelay: '<S736>/Unit Delay6'
   *  UnitDelay: '<S736>/Unit Delay7'
   */
  MATLABFunction1(rtb_Product1, 2.0 * rtb_Fcn_iz - rtDW.UnitDelay6_DSTATE_l, 2.0
                  * rtb_Fcn1 - rtDW.UnitDelay7_DSTATE, rtb_UnitDelay1, rtDW.V_k,
                  rtDW.Idc_h);

  /* RateTransition: '<S84>/Rate Transition3' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition3_a[0] = rtDW.RateTransition3_Buffer0_a[0];
    rtDW.RateTransition3_a[1] = rtDW.RateTransition3_Buffer0_a[1];
  }

  /* End of RateTransition: '<S84>/Rate Transition3' */

  /* Sum: '<S329>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S329>/D*u(k)'
   *  Gain: '<S332>/C11'
   *  Gain: '<S332>/C12'
   *  Sum: '<S332>/sum2'
   *  UnitDelay: '<S329>/Delay_x1'
   *  UnitDelay: '<S329>/Delay_x2'
   *  UnitDelay: '<S84>/Unit Delay'
   */
  rtb_UnitDelay7_b = (444.06110962854092 * rtDW.Delay_x1_DSTATE_p +
                      0.0010601835537138449 * rtDW.Delay_x2_DSTATE_c) +
    0.00053009177685692244 * rtDW.UnitDelay_DSTATE_o;

  /* Saturate: '<S270>/0.5 to 1.5 x Vnom_dc' */
  if (rtb_UnitDelay7_b > 3600.0) {
    rtb_UnitDelay7_b = 3600.0;
  } else {
    if (rtb_UnitDelay7_b < 1200.0) {
      rtb_UnitDelay7_b = 1200.0;
    }
  }

  /* End of Saturate: '<S270>/0.5 to 1.5 x Vnom_dc' */

  /* Product: '<S270>/Product' incorporates:
   *  Constant: '<S270>/Constant2'
   */
  rtb_UnitDelay7_b = 1837.1173070873838 / rtb_UnitDelay7_b;

  /* Product: '<S270>/Product1' incorporates:
   *  Constant: '<S84>/Constant'
   */
  rtb_Product1_fq[0] = rtDW.RateTransition3_a[0] * rtb_UnitDelay7_b;
  rtb_Product1_fq[1] = rtDW.RateTransition3_a[1] * rtb_UnitDelay7_b;
  rtb_Product1_fq[2] = 0.0 * rtb_UnitDelay7_b;

  /* RateTransition: '<S84>/Rate Transition4' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition4_p = rtDW.RateTransition4_Buffer0_o;
  }

  /* End of RateTransition: '<S84>/Rate Transition4' */

  /* Outputs for Enabled SubSystem: '<S341>/Subsystem1' */
  Subsystem1_i(0, &rtb_Product1_fq[0], rtDW.RateTransition4_p, &rtDW.Fcn,
               &rtDW.Fcn1);

  /* End of Outputs for SubSystem: '<S341>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S341>/Subsystem - pi//2 delay' */
  Subsystempi2delay_l(rtConstB.Compare_o, &rtb_Product1_fq[0],
                      rtDW.RateTransition4_p, &rtDW.Fcn_f, &rtDW.Fcn1_o);

  /* End of Outputs for SubSystem: '<S341>/Subsystem - pi//2 delay' */

  /* SignalConversion: '<S340>/TmpSignal ConversionAtGain3Inport1' incorporates:
   *  Switch: '<S341>/Switch'
   */
  rtb_UnitDelay_ai[0] = rtDW.Fcn_f;
  rtb_UnitDelay_ai[1] = rtDW.Fcn1_o;
  rtb_UnitDelay_ai[2] = rtb_Product1_fq[2];

  /* Gain: '<S340>/Gain3' */
  for (rtb_MultiportSwitch3_idx_0 = 0; rtb_MultiportSwitch3_idx_0 < 3;
       rtb_MultiportSwitch3_idx_0++) {
    rtb_UnitDelay3[rtb_MultiportSwitch3_idx_0] =
      rtConstP.pooled59[rtb_MultiportSwitch3_idx_0 + 6] * rtb_UnitDelay_ai[2] +
      (rtConstP.pooled59[rtb_MultiportSwitch3_idx_0 + 3] * rtb_UnitDelay_ai[1] +
       rtConstP.pooled59[rtb_MultiportSwitch3_idx_0] * rtb_UnitDelay_ai[0]);
  }

  /* Outputs for Enabled SubSystem: '<S76>/PWMgen - Averaging' incorporates:
   *  EnablePort: '<S87>/Enable'
   */
  if (!rtDW.PWMgenAveraging_MODE_e) {
    /* Enable for DiscreteIntegrator: '<S96>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_i3 = 1U;

    /* Enable for DiscreteIntegrator: '<S94>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_i05 = 1U;
    rtDW.PWMgenAveraging_MODE_e = true;
  }

  /* DigitalClock: '<S107>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Sum: '<S107>/Add1' incorporates:
   *  Constant: '<S107>/Constant3'
   */
  rtb_UnitDelay6_e += 0.00015432098765432098;

  /* Math: '<S107>/Math Function' incorporates:
   *  Constant: '<S107>/Constant1'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.00061728395061728394);

  /* Gain: '<S107>/1\ib1' */
  rtb_UnitDelay6_e *= 1620.0;

  /* Lookup_n-D: '<S107>/1-D Lookup Table' */
  rtb_UnitDelay6_e = look1_pbinlx(rtb_UnitDelay6_e, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex_k, 2U);

  /* Product: '<S98>/MUL1' incorporates:
   *  Constant: '<S107>/Constant2'
   *  Sum: '<S107>/Add3'
   */
  rtb_UnitDelay6_e--;

  /* Sum: '<S98>/Add4' */
  rtb_UnitDelay6_e = (-1.0 + rtb_UnitDelay6_e) + 1.0;

  /* RelationalOperator: '<S102>/Relational Operator2' incorporates:
   *  Gain: '<S340>/Gain3'
   */
  rtb_LogicalOperator4_d = (rtb_UnitDelay3[0] >= rtb_UnitDelay6_e);

  /* Logic: '<S92>/Logical Operator4' */
  rtb_RelationalOperator2_k_idx_0 = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S102>/Relational Operator2' incorporates:
   *  Gain: '<S340>/Gain3'
   */
  rtb_LogicalOperator4_g_idx_0 = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (rtb_UnitDelay3[1] >= rtb_UnitDelay6_e);

  /* Logic: '<S92>/Logical Operator4' */
  rtb_DataTypeConversion2 = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S102>/Relational Operator2' incorporates:
   *  Gain: '<S340>/Gain3'
   */
  rtb_Amplitude = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (rtb_UnitDelay3[2] >= rtb_UnitDelay6_e);

  /* DataTypeConversion: '<S92>/Data Type Conversion' incorporates:
   *  Logic: '<S92>/Logical Operator4'
   */
  rtDW.DataTypeConversion_d[0] = rtb_LogicalOperator4_g_idx_0;
  rtDW.DataTypeConversion_d[1] = rtb_RelationalOperator2_k_idx_0;
  rtDW.DataTypeConversion_d[2] = rtb_Amplitude;
  rtDW.DataTypeConversion_d[3] = rtb_DataTypeConversion2;
  rtDW.DataTypeConversion_d[4] = rtb_LogicalOperator4_d;
  rtDW.DataTypeConversion_d[5] = !rtb_LogicalOperator4_d;

  /* DigitalClock: '<S117>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Sum: '<S117>/Add1' incorporates:
   *  Constant: '<S117>/Constant3'
   */
  rtb_UnitDelay6_e += 0.00015432098765432098;

  /* Math: '<S117>/Math Function' incorporates:
   *  Constant: '<S117>/Constant1'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.00061728395061728394);

  /* Gain: '<S117>/1\ib1' */
  rtb_UnitDelay6_e *= 1620.0;

  /* Lookup_n-D: '<S117>/1-D Lookup Table' */
  rtb_UnitDelay6_e = look1_pbinlx(rtb_UnitDelay6_e, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex_n, 2U);

  /* Product: '<S108>/MUL1' incorporates:
   *  Constant: '<S117>/Constant2'
   *  Sum: '<S117>/Add3'
   */
  rtb_UnitDelay6_e--;

  /* Sum: '<S108>/Add4' */
  rtb_UnitDelay6_e = (-1.0 + rtb_UnitDelay6_e) + 1.0;

  /* RelationalOperator: '<S112>/Relational Operator2' incorporates:
   *  Gain: '<S340>/Gain3'
   *  Gain: '<S5>/Gain'
   */
  rtb_LogicalOperator4_d = (-rtb_UnitDelay3[0] >= rtb_UnitDelay6_e);

  /* Logic: '<S93>/Logical Operator4' */
  rtb_RelationalOperator2_k_idx_0 = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S112>/Relational Operator2' incorporates:
   *  Gain: '<S340>/Gain3'
   *  Gain: '<S5>/Gain'
   */
  rtb_LogicalOperator4_g_idx_0 = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (-rtb_UnitDelay3[1] >= rtb_UnitDelay6_e);

  /* Logic: '<S93>/Logical Operator4' */
  rtb_Amplitude = !rtb_LogicalOperator4_d;

  /* RelationalOperator: '<S112>/Relational Operator2' incorporates:
   *  Gain: '<S340>/Gain3'
   *  Gain: '<S5>/Gain'
   */
  rtb_DataTypeConversion2 = rtb_LogicalOperator4_d;
  rtb_LogicalOperator4_d = (-rtb_UnitDelay3[2] >= rtb_UnitDelay6_e);

  /* DataTypeConversion: '<S93>/Data Type Conversion' incorporates:
   *  Logic: '<S93>/Logical Operator4'
   */
  rtDW.DataTypeConversion_do[0] = rtb_LogicalOperator4_g_idx_0;
  rtDW.DataTypeConversion_do[1] = rtb_RelationalOperator2_k_idx_0;
  rtDW.DataTypeConversion_do[2] = rtb_DataTypeConversion2;
  rtDW.DataTypeConversion_do[3] = rtb_Amplitude;
  rtDW.DataTypeConversion_do[4] = rtb_LogicalOperator4_d;
  rtDW.DataTypeConversion_do[5] = !rtb_LogicalOperator4_d;

  /* DiscreteIntegrator: '<S96>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i3 != 0) {
    rtDW.Integ4_iy[0] = rtDW.Integ4_DSTATE_ey[0];
    rtDW.Integ4_iy[1] = rtDW.Integ4_DSTATE_ey[1];
    rtDW.Integ4_iy[2] = rtDW.Integ4_DSTATE_ey[2];
  } else {
    rtDW.Integ4_iy[0] = 2.5E-6 * rtDW.DataTypeConversion_do[0] +
      rtDW.Integ4_DSTATE_ey[0];
    rtDW.Integ4_iy[1] = 2.5E-6 * rtDW.DataTypeConversion_do[2] +
      rtDW.Integ4_DSTATE_ey[1];
    rtDW.Integ4_iy[2] = 2.5E-6 * rtDW.DataTypeConversion_do[4] +
      rtDW.Integ4_DSTATE_ey[2];
  }

  /* End of DiscreteIntegrator: '<S96>/Integ4' */

  /* DiscreteIntegrator: '<S94>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i05 != 0) {
    rtDW.Integ4_im[0] = rtDW.Integ4_DSTATE_bk[0];
    rtDW.Integ4_im[1] = rtDW.Integ4_DSTATE_bk[1];
    rtDW.Integ4_im[2] = rtDW.Integ4_DSTATE_bk[2];
  } else {
    rtDW.Integ4_im[0] = 2.5E-6 * rtDW.DataTypeConversion_d[0] +
      rtDW.Integ4_DSTATE_bk[0];
    rtDW.Integ4_im[1] = 2.5E-6 * rtDW.DataTypeConversion_d[2] +
      rtDW.Integ4_DSTATE_bk[1];
    rtDW.Integ4_im[2] = 2.5E-6 * rtDW.DataTypeConversion_d[4] +
      rtDW.Integ4_DSTATE_bk[2];
  }

  /* End of DiscreteIntegrator: '<S94>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S95>/S-Function' incorporates:
   *  Constant: '<S94>/K1'
   */

  /* Level2 S-Function Block: '<S95>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnOutputs(rts,0);
  }

  /* S-Function (sfun_discreteVariableDelay): '<S97>/S-Function' incorporates:
   *  Constant: '<S96>/K1'
   */

  /* Level2 S-Function Block: '<S97>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S96>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i3 = 0U;
  rtDW.Integ4_DSTATE_ey[0] = 2.5E-6 * rtDW.DataTypeConversion_do[0] +
    rtDW.Integ4_iy[0];
  rtDW.Integ4_DSTATE_ey[1] = 2.5E-6 * rtDW.DataTypeConversion_do[2] +
    rtDW.Integ4_iy[1];
  rtDW.Integ4_DSTATE_ey[2] = 2.5E-6 * rtDW.DataTypeConversion_do[4] +
    rtDW.Integ4_iy[2];

  /* Update for DiscreteIntegrator: '<S94>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i05 = 0U;
  rtDW.Integ4_DSTATE_bk[0] = 2.5E-6 * rtDW.DataTypeConversion_d[0] +
    rtDW.Integ4_im[0];
  rtDW.Integ4_DSTATE_bk[1] = 2.5E-6 * rtDW.DataTypeConversion_d[2] +
    rtDW.Integ4_im[1];
  rtDW.Integ4_DSTATE_bk[2] = 2.5E-6 * rtDW.DataTypeConversion_d[4] +
    rtDW.Integ4_im[2];

  /* Update for S-Function (sfun_discreteVariableDelay): '<S95>/S-Function' incorporates:
   *  Constant: '<S94>/K1'
   */
  /* Level2 S-Function Block: '<S95>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for S-Function (sfun_discreteVariableDelay): '<S97>/S-Function' incorporates:
   *  Constant: '<S96>/K1'
   */
  /* Level2 S-Function Block: '<S97>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S76>/PWMgen - Averaging' */

  /* UnitDelay: '<S828>/Unit Delay5' */
  rtb_UnitDelay5_di = rtDW.UnitDelay5_DSTATE_g0;

  /* Saturate: '<S822>/Saturation' */
  if (rtDW.DataTypeConversion_do[0] > 1.0) {
    /* Product: '<S822>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_do[0] < 0.0) {
    /* Product: '<S822>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S822>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_do[0];
  }

  /* UnitDelay: '<S822>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_b[0];

  /* Saturate: '<S822>/Saturation' */
  if (rtDW.DataTypeConversion_do[1] > 1.0) {
    /* Product: '<S822>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.DataTypeConversion_do[1] < 0.0) {
    /* Product: '<S822>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S822>/Product1' */
    rtb_UnitDelay1[1] = rtDW.DataTypeConversion_do[1];
  }

  /* UnitDelay: '<S822>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_b[1];

  /* MATLAB Function: '<S822>/MATLAB Function' incorporates:
   *  Gain: '<S828>/Gain4'
   *  Sum: '<S828>/Add8'
   *  UnitDelay: '<S828>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_di -
                 rtDW.UnitDelay6_DSTATE_hc, rtb_UnitDelay1_no, rtDW.V_oe,
                 &rtDW.Idc_n);

  /* RateTransition: '<S75>/Rate Transition2' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition2 = rtDW.RateTransition2_Buffer0;
  }

  /* End of RateTransition: '<S75>/Rate Transition2' */

  /* Outputs for Enabled SubSystem: '<S77>/Subsystem' incorporates:
   *  EnablePort: '<S119>/Enable'
   */
  if (!rtDW.Subsystem_MODE_n) {
    /* Enable for DiscreteIntegrator: '<S122>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ae = 1U;
    rtDW.Subsystem_MODE_n = true;
  }

  /* DigitalClock: '<S126>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Math: '<S126>/Math Function' incorporates:
   *  Constant: '<S126>/Constant2'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.0005);

  /* DataTypeConversion: '<S121>/Data Type Conversion' incorporates:
   *  Constant: '<S124>/Constant'
   *  Fcn: '<S121>/Fcn'
   *  Fcn: '<S126>/Fcn'
   *  Gain: '<S126>/1\ib1'
   *  Logic: '<S121>/Logical Operator'
   *  RelationalOperator: '<S121>/Relational Operator'
   *  RelationalOperator: '<S124>/Compare'
   */
  rtDW.DataTypeConversion_l = ((rtDW.RateTransition2 != 0.0) &&
    (rtDW.RateTransition2 >= ((2000.0 * rtb_UnitDelay6_e * 2.0 - 1.0) + 1.0) *
     0.5));

  /* Logic: '<S119>/Logical Operator' */
  rtDW.LogicalOperator = !(rtDW.DataTypeConversion_l != 0.0);

  /* DiscreteIntegrator: '<S122>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ae != 0) {
    rtDW.Integ4_md = rtDW.Integ4_DSTATE_dt;
  } else {
    rtDW.Integ4_md = 2.5E-6 * rtDW.DataTypeConversion_l + rtDW.Integ4_DSTATE_dt;
  }

  /* End of DiscreteIntegrator: '<S122>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */

  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S122>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ae = 0U;
  rtDW.Integ4_DSTATE_dt = 2.5E-6 * rtDW.DataTypeConversion_l + rtDW.Integ4_md;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */
  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S77>/Subsystem' */

  /* Saturate: '<S882>/Saturation' */
  if (rtDW.DataTypeConversion_l > 1.0) {
    /* Product: '<S882>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_l < 0.0) {
    /* Product: '<S882>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S882>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_l;
  }

  if (rtDW.LogicalOperator > 1.0) {
    /* Product: '<S882>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.LogicalOperator < 0.0) {
    /* Product: '<S882>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S882>/Product1' */
    rtb_UnitDelay1[1] = rtDW.LogicalOperator;
  }

  /* End of Saturate: '<S882>/Saturation' */

  /* UnitDelay: '<S886>/Unit Delay5' */
  rtb_UnitDelay5_f = rtDW.UnitDelay5_DSTATE_i;

  /* UnitDelay: '<S882>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_d[0];
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_d[1];

  /* MATLAB Function: '<S882>/MATLAB Function' incorporates:
   *  Gain: '<S886>/Gain4'
   *  Sum: '<S886>/Add8'
   *  UnitDelay: '<S886>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_f -
                 rtDW.UnitDelay6_DSTATE_i, rtb_UnitDelay1_no, rtDW.V, &rtDW.Idc);

  /* DataTypeConversion: '<S686>/Data Type Conversion1' incorporates:
   *  Constant: '<S689>/Constant'
   *  RelationalOperator: '<S689>/Compare'
   */
  rtb_UnitDelay6_e = (rtb_sinwt <= 0.5);

  /* Saturate: '<S686>/Saturation' */
  if (rtDW.DataTypeConversion_or[0] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[0] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[0];
  }

  /* Product: '<S686>/Product4' */
  rtb_Product1[0] = HoldSine * rtb_UnitDelay6_e;

  /* Saturate: '<S686>/Saturation' */
  if (rtDW.DataTypeConversion_or[1] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[1] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[1];
  }

  /* Product: '<S686>/Product4' */
  rtb_Product1[1] = HoldSine * rtb_UnitDelay6_e;

  /* Saturate: '<S686>/Saturation' */
  if (rtDW.DataTypeConversion_or[2] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[2] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[2];
  }

  /* Product: '<S686>/Product4' */
  rtb_Product1[2] = HoldSine * rtb_UnitDelay6_e;

  /* Saturate: '<S686>/Saturation' */
  if (rtDW.DataTypeConversion_or[3] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[3] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[3];
  }

  /* Product: '<S686>/Product4' */
  rtb_Product1[3] = HoldSine * rtb_UnitDelay6_e;

  /* UnitDelay: '<S692>/Unit Delay5' */
  rtb_UnitDelay5_h0 = rtDW.UnitDelay5_DSTATE_l;

  /* UnitDelay: '<S692>/Unit Delay4' */
  rtb_UnitDelay4_c = rtDW.UnitDelay4_DSTATE_p;

  /* UnitDelay: '<S686>/Unit Delay1' */
  rtb_UnitDelay1[0] = rtDW.UnitDelay1_DSTATE_a[0];
  rtb_UnitDelay1[1] = rtDW.UnitDelay1_DSTATE_a[1];

  /* MATLAB Function: '<S686>/MATLAB Function1' incorporates:
   *  Gain: '<S692>/Gain4'
   *  Gain: '<S692>/Gain5'
   *  Sum: '<S692>/Add8'
   *  Sum: '<S692>/Add9'
   *  UnitDelay: '<S692>/Unit Delay6'
   *  UnitDelay: '<S692>/Unit Delay7'
   */
  MATLABFunction1(rtb_Product1, 2.0 * rtb_UnitDelay5_h0 -
                  rtDW.UnitDelay6_DSTATE_g, 2.0 * rtb_UnitDelay4_c -
                  rtDW.UnitDelay7_DSTATE_d, rtb_UnitDelay1, rtDW.V_o2,
                  rtDW.Idc_nv);

  /* UnitDelay: '<S787>/Unit Delay5' */
  rtb_UnitDelay5_aw = rtDW.UnitDelay5_DSTATE_b;

  /* Saturate: '<S763>/Saturation' */
  if (rtDW.DataTypeConversion_d[2] > 1.0) {
    /* Product: '<S763>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_d[2] < 0.0) {
    /* Product: '<S763>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S763>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_d[2];
  }

  /* UnitDelay: '<S763>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_ka[0];

  /* Saturate: '<S763>/Saturation' */
  if (rtDW.DataTypeConversion_d[3] > 1.0) {
    /* Product: '<S763>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.DataTypeConversion_d[3] < 0.0) {
    /* Product: '<S763>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S763>/Product1' */
    rtb_UnitDelay1[1] = rtDW.DataTypeConversion_d[3];
  }

  /* UnitDelay: '<S763>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_ka[1];

  /* MATLAB Function: '<S763>/MATLAB Function' incorporates:
   *  Gain: '<S787>/Gain4'
   *  Sum: '<S787>/Add8'
   *  UnitDelay: '<S787>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_aw -
                 rtDW.UnitDelay6_DSTATE_b, rtb_UnitDelay1_no, rtDW.V_in,
                 &rtDW.Idc_e);

  /* UnitDelay: '<S866>/Unit Delay5' */
  rtb_UnitDelay5_l = rtDW.UnitDelay5_DSTATE_lw;

  /* Saturate: '<S824>/Saturation' */
  if (rtDW.DataTypeConversion_do[4] > 1.0) {
    /* Product: '<S824>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_do[4] < 0.0) {
    /* Product: '<S824>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S824>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_do[4];
  }

  /* UnitDelay: '<S824>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_l[0];

  /* Saturate: '<S824>/Saturation' */
  if (rtDW.DataTypeConversion_do[5] > 1.0) {
    /* Product: '<S824>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.DataTypeConversion_do[5] < 0.0) {
    /* Product: '<S824>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S824>/Product1' */
    rtb_UnitDelay1[1] = rtDW.DataTypeConversion_do[5];
  }

  /* UnitDelay: '<S824>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_l[1];

  /* MATLAB Function: '<S824>/MATLAB Function' incorporates:
   *  Gain: '<S866>/Gain4'
   *  Sum: '<S866>/Add8'
   *  UnitDelay: '<S866>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_l -
                 rtDW.UnitDelay6_DSTATE_d, rtb_UnitDelay1_no, rtDW.V_o,
                 &rtDW.Idc_o);

  /* UnitDelay: '<S768>/Unit Delay5' */
  rtb_UnitDelay5_de = rtDW.UnitDelay5_DSTATE_ij;

  /* Saturate: '<S762>/Saturation' */
  if (rtDW.DataTypeConversion_d[0] > 1.0) {
    /* Product: '<S762>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_d[0] < 0.0) {
    /* Product: '<S762>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S762>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_d[0];
  }

  /* UnitDelay: '<S762>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_f[0];

  /* Saturate: '<S762>/Saturation' */
  if (rtDW.DataTypeConversion_d[1] > 1.0) {
    /* Product: '<S762>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.DataTypeConversion_d[1] < 0.0) {
    /* Product: '<S762>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S762>/Product1' */
    rtb_UnitDelay1[1] = rtDW.DataTypeConversion_d[1];
  }

  /* UnitDelay: '<S762>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_f[1];

  /* MATLAB Function: '<S762>/MATLAB Function' incorporates:
   *  Gain: '<S768>/Gain4'
   *  Sum: '<S768>/Add8'
   *  UnitDelay: '<S768>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_de -
                 rtDW.UnitDelay6_DSTATE_o0, rtb_UnitDelay1_no, rtDW.V_ow,
                 &rtDW.Idc_ay);

  /* UnitDelay: '<S847>/Unit Delay5' */
  rtb_UnitDelay5_e = rtDW.UnitDelay5_DSTATE_bb;

  /* Saturate: '<S823>/Saturation' */
  if (rtDW.DataTypeConversion_do[2] > 1.0) {
    /* Product: '<S823>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_do[2] < 0.0) {
    /* Product: '<S823>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S823>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_do[2];
  }

  /* UnitDelay: '<S823>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_c[0];

  /* Saturate: '<S823>/Saturation' */
  if (rtDW.DataTypeConversion_do[3] > 1.0) {
    /* Product: '<S823>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.DataTypeConversion_do[3] < 0.0) {
    /* Product: '<S823>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S823>/Product1' */
    rtb_UnitDelay1[1] = rtDW.DataTypeConversion_do[3];
  }

  /* UnitDelay: '<S823>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_c[1];

  /* MATLAB Function: '<S823>/MATLAB Function' incorporates:
   *  Gain: '<S847>/Gain4'
   *  Sum: '<S847>/Add8'
   *  UnitDelay: '<S847>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_e -
                 rtDW.UnitDelay6_DSTATE_iz, rtb_UnitDelay1_no, rtDW.V_i,
                 &rtDW.Idc_j);

  /* UnitDelay: '<S806>/Unit Delay5' */
  rtb_UnitDelay5_a2 = rtDW.UnitDelay5_DSTATE_ik;

  /* Saturate: '<S764>/Saturation' */
  if (rtDW.DataTypeConversion_d[4] > 1.0) {
    /* Product: '<S764>/Product1' */
    rtb_UnitDelay1[0] = 1.0;
  } else if (rtDW.DataTypeConversion_d[4] < 0.0) {
    /* Product: '<S764>/Product1' */
    rtb_UnitDelay1[0] = 0.0;
  } else {
    /* Product: '<S764>/Product1' */
    rtb_UnitDelay1[0] = rtDW.DataTypeConversion_d[4];
  }

  /* UnitDelay: '<S764>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_j[0];

  /* Saturate: '<S764>/Saturation' */
  if (rtDW.DataTypeConversion_d[5] > 1.0) {
    /* Product: '<S764>/Product1' */
    rtb_UnitDelay1[1] = 1.0;
  } else if (rtDW.DataTypeConversion_d[5] < 0.0) {
    /* Product: '<S764>/Product1' */
    rtb_UnitDelay1[1] = 0.0;
  } else {
    /* Product: '<S764>/Product1' */
    rtb_UnitDelay1[1] = rtDW.DataTypeConversion_d[5];
  }

  /* UnitDelay: '<S764>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_j[1];

  /* MATLAB Function: '<S764>/MATLAB Function' incorporates:
   *  Gain: '<S806>/Gain4'
   *  Sum: '<S806>/Add8'
   *  UnitDelay: '<S806>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_UnitDelay5_a2 -
                 rtDW.UnitDelay6_DSTATE_le, rtb_UnitDelay1_no, rtDW.V_j,
                 &rtDW.Idc_a);

  /* Sin: '<S5>/Uref1' */
  if (rtDW.systemEnable_h != 0) {
    rtb_UnitDelay6_e = 376.99111843077515 * rtM->Timing.t[0];
    rtDW.lastSin_b = sin(rtb_UnitDelay6_e);
    rtDW.lastCos_h = cos(rtb_UnitDelay6_e);
    rtDW.systemEnable_h = 0;
  }

  /* Outputs for Enabled SubSystem: '<S82>/Subsystem' incorporates:
   *  EnablePort: '<S177>/Enable'
   */
  if (!rtDW.Subsystem_MODE) {
    /* Enable for DiscreteIntegrator: '<S180>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ji = 1U;
    rtDW.Subsystem_MODE = true;
  }

  /* DigitalClock: '<S191>/Digital Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Sum: '<S191>/Add1' incorporates:
   *  Constant: '<S191>/Constant3'
   */
  rtb_UnitDelay6_e += 0.00012626262626262626;

  /* Math: '<S191>/Math Function' incorporates:
   *  Constant: '<S191>/Constant1'
   */
  rtb_UnitDelay6_e = rt_remd_snf(rtb_UnitDelay6_e, 0.000505050505050505);

  /* Gain: '<S191>/1\ib1' */
  rtb_UnitDelay6_e *= 1980.0;

  /* Lookup_n-D: '<S191>/1-D Lookup Table' */
  rtb_UnitDelay6_e = look1_pbinlx(rtb_UnitDelay6_e, rtConstP.pooled8,
    rtConstP.pooled7, &rtDW.m_bpIndex, 2U);

  /* Product: '<S182>/MUL1' incorporates:
   *  Constant: '<S191>/Constant2'
   *  Sum: '<S191>/Add3'
   */
  rtb_UnitDelay6_e--;

  /* Sum: '<S182>/Add4' */
  rtb_UnitDelay6_e = (-1.0 + rtb_UnitDelay6_e) + 1.0;

  /* RelationalOperator: '<S186>/Relational Operator2' incorporates:
   *  Sin: '<S5>/Uref1'
   */
  rtb_DataTypeConversion2 = ((rtDW.lastSin_b * 0.96641197241205634 +
    rtDW.lastCos_h * 0.2569978590934931) * 0.99999822347173384 + (rtDW.lastCos_h
    * 0.96641197241205634 - rtDW.lastSin_b * 0.2569978590934931) *
    0.0018849544759281136 >= rtb_UnitDelay6_e);

  /* DataTypeConversion: '<S179>/Data Type Conversion' incorporates:
   *  Logic: '<S179>/Logical Operator4'
   */
  rtDW.DataTypeConversion[0] = rtb_DataTypeConversion2;
  rtDW.DataTypeConversion[1] = !rtb_DataTypeConversion2;

  /* DiscreteIntegrator: '<S180>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ji != 0) {
    rtDW.Integ4_l1 = rtDW.Integ4_DSTATE_go;
  } else {
    rtDW.Integ4_l1 = 2.5E-6 * rtDW.DataTypeConversion[0] + rtDW.Integ4_DSTATE_go;
  }

  /* End of DiscreteIntegrator: '<S180>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S181>/S-Function' incorporates:
   *  Constant: '<S180>/K1'
   */

  /* Level2 S-Function Block: '<S181>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnOutputs(rts,0);
  }

  /* Update for DiscreteIntegrator: '<S180>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ji = 0U;
  rtDW.Integ4_DSTATE_go = 2.5E-6 * rtDW.DataTypeConversion[0] + rtDW.Integ4_l1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S181>/S-Function' incorporates:
   *  Constant: '<S180>/K1'
   */
  /* Level2 S-Function Block: '<S181>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Outputs for SubSystem: '<S82>/Subsystem' */

  /* DataTypeConversion: '<S390>/Data Type Conversion1' incorporates:
   *  Constant: '<S391>/Constant'
   *  RelationalOperator: '<S391>/Compare'
   */
  rtb_UnitDelay6_e = (rtb_ComplextoMagnitudeAngle__nj <= 0.5);

  /* UnitDelay: '<S394>/Unit Delay5' */
  rtb_ComplextoMagnitudeAngle__nj = rtDW.UnitDelay5_DSTATE_g0i;

  /* Saturate: '<S390>/Saturation' */
  if (rtDW.DataTypeConversion[0] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion[0] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion[0];
  }

  /* Product: '<S390>/Product1' */
  rtb_UnitDelay1[0] = HoldSine * rtb_UnitDelay6_e;

  /* UnitDelay: '<S390>/Unit Delay1' */
  rtb_UnitDelay1_no[0] = rtDW.UnitDelay1_DSTATE_d3[0];

  /* Saturate: '<S390>/Saturation' */
  if (rtDW.DataTypeConversion[1] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion[1] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion[1];
  }

  /* Product: '<S390>/Product1' */
  rtb_UnitDelay1[1] = HoldSine * rtb_UnitDelay6_e;

  /* UnitDelay: '<S390>/Unit Delay1' */
  rtb_UnitDelay1_no[1] = rtDW.UnitDelay1_DSTATE_d3[1];

  /* MATLAB Function: '<S390>/MATLAB Function' incorporates:
   *  Gain: '<S394>/Gain4'
   *  Sum: '<S394>/Add8'
   *  UnitDelay: '<S394>/Unit Delay6'
   */
  MATLABFunction(rtb_UnitDelay1, 2.0 * rtb_ComplextoMagnitudeAngle__nj -
                 rtDW.UnitDelay6_DSTATE_n, rtb_UnitDelay1_no, rtDW.V_b,
                 &rtDW.Idc_g);

  /* DataTypeConversion: '<S687>/Data Type Conversion1' incorporates:
   *  Constant: '<S711>/Constant'
   *  RelationalOperator: '<S711>/Compare'
   */
  rtb_UnitDelay6_e = (rtb_sinwt <= 0.5);

  /* Saturate: '<S687>/Saturation' */
  if (rtDW.DataTypeConversion_or[4] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[4] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[4];
  }

  /* Product: '<S687>/Product4' */
  rtb_Product1[0] = HoldSine * rtb_UnitDelay6_e;

  /* Saturate: '<S687>/Saturation' */
  if (rtDW.DataTypeConversion_or[5] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[5] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[5];
  }

  /* Product: '<S687>/Product4' */
  rtb_Product1[1] = HoldSine * rtb_UnitDelay6_e;

  /* Saturate: '<S687>/Saturation' */
  if (rtDW.DataTypeConversion_or[6] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[6] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[6];
  }

  /* Product: '<S687>/Product4' */
  rtb_Product1[2] = HoldSine * rtb_UnitDelay6_e;

  /* Saturate: '<S687>/Saturation' */
  if (rtDW.DataTypeConversion_or[7] > 1.0) {
    HoldSine = 1.0;
  } else if (rtDW.DataTypeConversion_or[7] < 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = rtDW.DataTypeConversion_or[7];
  }

  /* Product: '<S687>/Product4' */
  rtb_Product1[3] = HoldSine * rtb_UnitDelay6_e;

  /* UnitDelay: '<S714>/Unit Delay5' */
  rtb_UnitDelay5_g = rtDW.UnitDelay5_DSTATE_k;

  /* UnitDelay: '<S714>/Unit Delay4' */
  rtb_UnitDelay4_lk = rtDW.UnitDelay4_DSTATE_c;

  /* UnitDelay: '<S687>/Unit Delay1' */
  rtb_UnitDelay1[0] = rtDW.UnitDelay1_DSTATE_k3[0];
  rtb_UnitDelay1[1] = rtDW.UnitDelay1_DSTATE_k3[1];

  /* MATLAB Function: '<S687>/MATLAB Function1' incorporates:
   *  Gain: '<S714>/Gain4'
   *  Gain: '<S714>/Gain5'
   *  Sum: '<S714>/Add8'
   *  Sum: '<S714>/Add9'
   *  UnitDelay: '<S714>/Unit Delay6'
   *  UnitDelay: '<S714>/Unit Delay7'
   */
  MATLABFunction1(rtb_Product1, 2.0 * rtb_UnitDelay5_g -
                  rtDW.UnitDelay6_DSTATE_h5, 2.0 * rtb_UnitDelay4_lk -
                  rtDW.UnitDelay7_DSTATE_n, rtb_UnitDelay1, rtDW.V_n, rtDW.Idc_d);

  /* Outputs for Enabled SubSystem: '<S926>/Signal generator' incorporates:
   *  EnablePort: '<S928>/Enable'
   */
  if (rtDW.Signalgenerator_MODE) {
    /* Disable for Outport: '<S928>/timer' */
    rtDW.LookUpTable = 0.0;

    /* Disable for Outport: '<S928>/selector' */
    rtDW.LogicalOperator1 = false;

    /* Disable for Outport: '<S928>/magnitude' */
    rtDW.Switch2 = 0.0;

    /* Disable for Outport: '<S928>/frequency' */
    rtDW.DiscreteTimeIntegrator = 0.0;

    /* Disable for Outport: '<S928>/phase' */
    rtDW.Switch3 = 0.0;
    rtDW.Signalgenerator_MODE = false;
  }

  /* End of Outputs for SubSystem: '<S926>/Signal generator' */

  /* Switch: '<S926>/Switch1' incorporates:
   *  Constant: '<S926>/valp_nom2'
   *  Sum: '<S926>/Sum3'
   */
  if (rtDW.LogicalOperator1) {
    rtb_UnitDelay6_e = rtDW.LookUpTable;
  } else {
    rtb_UnitDelay6_e = rtDW.Switch2 + 20412.414523193151;
  }

  /* End of Switch: '<S926>/Switch1' */

  /* DigitalClock: '<S926>/t' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Sum: '<S926>/Sum' incorporates:
   *  Product: '<S926>/Product'
   */
  rtb_Switch3 = rtb_UnitDelay7_b * 376.99111843077515 +
    rtDW.DiscreteTimeIntegrator;

  /* Trigonometry: '<S926>/Trigonometric Function' incorporates:
   *  Product: '<S926>/Product1'
   *  Sum: '<S926>/Sum1'
   *  Sum: '<S926>/Sum2'
   */
  rtb_UnitDelay_ai[0] = sin(rtb_Switch3 + rtDW.Switch3) * rtb_UnitDelay6_e;
  rtb_UnitDelay_ai[1] = sin((-2.0943951023931953 + rtDW.Switch3) + rtb_Switch3) *
    rtb_UnitDelay6_e;
  rtb_UnitDelay_ai[2] = sin((2.0943951023931953 + rtDW.Switch3) + rtb_Switch3) *
    rtb_UnitDelay6_e;

  /* Outputs for Enabled SubSystem: '<S926>/Harmonic Generator' incorporates:
   *  EnablePort: '<S927>/Enable'
   */
  if (rtDW.HarmonicGenerator_MODE) {
    /* Disable for Outport: '<S927>/Out1' */
    rtDW.Product1[0] = 0.0;

    /* Disable for Outport: '<S927>/Out2' */
    rtDW.Product1_o[0] = 0.0;

    /* Disable for Outport: '<S927>/Out1' */
    rtDW.Product1[1] = 0.0;

    /* Disable for Outport: '<S927>/Out2' */
    rtDW.Product1_o[1] = 0.0;

    /* Disable for Outport: '<S927>/Out1' */
    rtDW.Product1[2] = 0.0;

    /* Disable for Outport: '<S927>/Out2' */
    rtDW.Product1_o[2] = 0.0;
    rtDW.HarmonicGenerator_MODE = false;
  }

  /* End of Outputs for SubSystem: '<S926>/Harmonic Generator' */

  /* Sum: '<S926>/Sum5' */
  rtDW.Sum5[0] = (rtb_UnitDelay_ai[0] + rtDW.Product1[0]) + rtDW.Product1_o[0];
  rtDW.Sum5[1] = (rtb_UnitDelay_ai[1] + rtDW.Product1[1]) + rtDW.Product1_o[1];
  rtDW.Sum5[2] = (rtb_UnitDelay_ai[2] + rtDW.Product1[2]) + rtDW.Product1_o[2];

  /* S-Function (sfun_spssw_discc): '<S955>/State-Space' incorporates:
   *  Constant: '<S355>/DC'
   *  Constant: '<S405>/eee'
   *  Constant: '<S407>/eee'
   *  Constant: '<S54>/eee'
   *  Constant: '<S705>/eee'
   *  Constant: '<S707>/eee'
   *  Constant: '<S727>/eee'
   *  Constant: '<S729>/eee'
   *  Constant: '<S72>/eee'
   *  Constant: '<S749>/eee'
   *  Constant: '<S751>/eee'
   *  Constant: '<S779>/eee'
   *  Constant: '<S781>/eee'
   *  Constant: '<S798>/eee'
   *  Constant: '<S800>/eee'
   *  Constant: '<S817>/eee'
   *  Constant: '<S819>/eee'
   *  Constant: '<S839>/eee'
   *  Constant: '<S841>/eee'
   *  Constant: '<S858>/eee'
   *  Constant: '<S860>/eee'
   *  Constant: '<S877>/eee'
   *  Constant: '<S879>/eee'
   *  Constant: '<S897>/eee'
   *  Constant: '<S899>/eee'
   *  Constant: '<S963>/SwitchCurrents'
   */

  /* S-Function block: <S955>/State-Space */
  {
    real_T accum;

    /* Circuit has switches */
    int_T *switch_status = (int_T*) rtDW.StateSpace_PWORK_f.SWITCH_STATUS;
    int_T *switch_status_init = (int_T*)
      rtDW.StateSpace_PWORK_f.SWITCH_STATUS_INIT;
    int_T *SwitchChange = (int_T*) rtDW.StateSpace_PWORK_f.SW_CHG;
    int_T *gState = (int_T*) rtDW.StateSpace_PWORK_f.G_STATE;
    real_T *yswitch = (real_T*)rtDW.StateSpace_PWORK_f.Y_SWITCH;
    int_T *switchTypes = (int_T*) rtDW.StateSpace_PWORK_f.SWITCH_TYPES;
    int_T *idxOutSw = (int_T*) rtDW.StateSpace_PWORK_f.IDX_OUT_SW;
    real_T *DxCol = (real_T*)rtDW.StateSpace_PWORK_f.DX_COL;
    real_T *tmp2 = (real_T*)rtDW.StateSpace_PWORK_f.TMP2;
    real_T *BDcol = (real_T*)rtDW.StateSpace_PWORK_f.BD_COL;
    real_T *tmp1 = (real_T*)rtDW.StateSpace_PWORK_f.TMP1;
    real_T *uswlast = (real_T*)rtDW.StateSpace_PWORK_f.USWLAST;
    int_T newState;
    int_T swChanged = 0;
    int loopsToDo = 20;
    real_T temp;

    /* keep an initial copy of switch_status*/
    memcpy(switch_status_init, switch_status, 24 * sizeof(int_T));
    memcpy(uswlast, &rtDW.StateSpace_o1_m[0], 24*sizeof(real_T));
    do {
      if (loopsToDo == 1) {            /* Need to reset some variables: */
        swChanged = 0;

        /* return to the original switch status*/
        {
          int_T i1;
          for (i1=0; i1 < 24; i1++) {
            swChanged = ((SwitchChange[i1] = switch_status_init[i1] -
                          switch_status[i1]) != 0) ? 1 : swChanged;
            switch_status[i1] = switch_status_init[i1];
          }
        }
      } else {
        /*
         * Compute outputs:
         * ---------------
         */
        real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_f.CS;
        real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_f.DS;

        {
          int_T i1;
          real_T *y0 = &rtDW.StateSpace_o1_m[0];
          for (i1=0; i1 < 92; i1++) {
            accum = 0.0;

            {
              int_T i2;
              real_T *xd = &rtDW.StateSpace_DSTATE_l[0];
              for (i2=0; i2 < 38; i2++) {
                accum += *(Cs++) * xd[i2];
              }
            }

            {
              int_T i2;
              const real_T *u0 = rtConstP.SwitchCurrents_Value;
              for (i2=0; i2 < 24; i2++) {
                accum += *(Ds++) * u0[i2];
              }

              accum += *(Ds++) * 500.0;
              accum += *(Ds++) * rtDW.Vload;
              accum += *(Ds++) * rtDW.V_jp;
              accum += *(Ds++) * rtDW.V_c;
              accum += *(Ds++) * rtDW.Product;
              accum += *(Ds++) * rtDW.V_k[0];
              accum += *(Ds++) * rtDW.V_oe[1];
              accum += *(Ds++) * rtDW.V[0];
              accum += *(Ds++) * rtDW.V_o2[1];
              accum += *(Ds++) * rtDW.V_o2[0];
              accum += *(Ds++) * rtDW.V_in[0];
              accum += *(Ds++) * rtDW.V_in[1];
              accum += *(Ds++) * rtDW.V_o[0];
              accum += *(Ds++) * rtDW.V_o[1];
              accum += *(Ds++) * rtDW.V_ow[0];
              accum += *(Ds++) * rtDW.V_ow[1];
              accum += *(Ds++) * rtDW.V_i[0];
              accum += *(Ds++) * rtDW.V_i[1];
              accum += *(Ds++) * rtDW.V_oe[0];
              accum += *(Ds++) * rtDW.V_j[1];
              accum += *(Ds++) * rtDW.V_j[0];
              accum += *(Ds++) * rtDW.V_b[1];
              accum += *(Ds++) * rtDW.V_b[0];
              accum += *(Ds++) * rtDW.V[1];
              accum += *(Ds++) * rtDW.V_k[1];
              accum += *(Ds++) * rtDW.V_n[1];
              accum += *(Ds++) * rtDW.V_n[0];
              accum += *(Ds++) * rtDW.Idc_a2;
              accum += *(Ds++) * rtDW.Idc_b;
              accum += *(Ds++) * rtDW.Idc_jt;
              accum += *(Ds++) * rtDW.Idc_nv[1];
              accum += *(Ds++) * rtDW.Idc_d[1];
              accum += *(Ds++) * rtDW.Idc_h[1];
              accum += *(Ds++) * rtDW.Idc_a;
              accum += *(Ds++) * rtDW.Idc_ay;
              accum += *(Ds++) * rtDW.Idc_o;
              accum += *(Ds++) * rtDW.Idc_e;
              accum += *(Ds++) * rtDW.Idc_j;
              accum += *(Ds++) * rtDW.Idc_n;
              accum += *(Ds++) * rtDW.Idc_nv[0];
              accum += *(Ds++) * rtDW.Idc;
              accum += *(Ds++) * rtDW.Idc_g;
              accum += *(Ds++) * rtDW.Idc_h[0];
              accum += *(Ds++) * rtDW.Idc_d[0];
              accum += *(Ds++) * rtDW.Sum5[0];
              accum += *(Ds++) * rtDW.Sum5[1];
              accum += *(Ds++) * rtDW.Sum5[2];
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
              accum += *(Ds++) * 0.001;
            }

            y0[i1] = accum;
          }
        }

        swChanged = 0;

        {
          int_T i1;
          real_T *y0 = &rtDW.StateSpace_o1_m[0];
          for (i1=0; i1 < 24; i1++) {
            newState = y0[i1] > 0.0 ? 1 : ((y0[i1] < 0.0) ? 0 : switch_status[i1]);
            swChanged = ((SwitchChange[i1] = newState - switch_status[i1]) != 0)
              ? 1 : swChanged;
            switch_status[i1] = newState;/* Keep new state */
          }
        }
      }

      /*
       * Compute new As, Bs, Cs and Ds matrixes:
       * --------------------------------------
       */
      if (swChanged) {
        real_T *As = (real_T*)rtDW.StateSpace_PWORK_f.AS;
        real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_f.CS;
        real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_f.BS;
        real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_f.DS;
        real_T a1;

        {
          int_T i1;
          for (i1=0; i1 < 24; i1++) {
            if (SwitchChange[i1] != 0) {
              a1 = 1000.0*SwitchChange[i1];
              temp = 1/(1-Ds[i1*96]*a1);

              {
                int_T i2;
                for (i2=0; i2 < 92; i2++) {
                  DxCol[i2]= Ds[i2 * 95 + i1]*temp*a1;
                }
              }

              DxCol[i1] = temp;

              {
                int_T i2;
                for (i2=0; i2 < 38; i2++) {
                  BDcol[i2]= Bs[i2 * 95 + i1]*a1;
                }
              }

              /* Copy row nSw of Cs into tmp1 and zero it out in Cs */
              memcpy(tmp1, &Cs[i1 * 38], 38 * sizeof(real_T));
              memset(&Cs[i1 * 38], '\0', 38 * sizeof(real_T));

              /* Copy row nSw of Ds into tmp2 and zero it out in Ds */
              memcpy(tmp2, &Ds[i1 * 95], 95 * sizeof(real_T));
              memset(&Ds[i1 * 95], '\0', 95 * sizeof(real_T));

              /* Cs = Cs + DxCol * tmp1, Ds = Ds + DxCol * tmp2 *******************/
              {
                int_T i2;
                for (i2=0; i2 < 92; i2++) {
                  a1 = DxCol[i2];

                  {
                    int_T i3;
                    for (i3=0; i3 < 38; i3++) {
                      Cs[i2 * 38 + i3] += a1 * tmp1[i3];
                    }
                  }

                  {
                    int_T i3;
                    for (i3=0; i3 < 95; i3++) {
                      Ds[i2 * 95 + i3] += a1 * tmp2[i3];
                    }
                  }
                }
              }

              /* As = As + BdCol*Cs(nSw,:), Bs = Bs + BdCol*Ds(nSw,:) *************/
              {
                int_T i2;
                for (i2=0; i2 < 38; i2++) {
                  a1 = BDcol[i2];

                  {
                    int_T i3;
                    for (i3=0; i3 < 38; i3++) {
                      As[i2 * 38 + i3] += a1 * Cs[i1 * 38 + i3];
                    }
                  }

                  {
                    int_T i3;
                    for (i3=0; i3 < 95; i3++) {
                      Bs[i2 * 95 + i3] += a1 * Ds[i1 * 95 + i3];
                    }
                  }
                }
              }
            }
          }
        }
      }                                /* if (swChanged) */
    } while (swChanged > 0 && --loopsToDo > 0);

    if (loopsToDo == 0) {
      real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_f.CS;
      real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_f.DS;

      {
        int_T i1;
        real_T *y0 = &rtDW.StateSpace_o1_m[0];
        for (i1=0; i1 < 92; i1++) {
          accum = 0.0;

          {
            int_T i2;
            real_T *xd = &rtDW.StateSpace_DSTATE_l[0];
            for (i2=0; i2 < 38; i2++) {
              accum += *(Cs++) * xd[i2];
            }
          }

          {
            int_T i2;
            const real_T *u0 = rtConstP.SwitchCurrents_Value;
            for (i2=0; i2 < 24; i2++) {
              accum += *(Ds++) * u0[i2];
            }

            accum += *(Ds++) * 500.0;
            accum += *(Ds++) * rtDW.Vload;
            accum += *(Ds++) * rtDW.V_jp;
            accum += *(Ds++) * rtDW.V_c;
            accum += *(Ds++) * rtDW.Product;
            accum += *(Ds++) * rtDW.V_k[0];
            accum += *(Ds++) * rtDW.V_oe[1];
            accum += *(Ds++) * rtDW.V[0];
            accum += *(Ds++) * rtDW.V_o2[1];
            accum += *(Ds++) * rtDW.V_o2[0];
            accum += *(Ds++) * rtDW.V_in[0];
            accum += *(Ds++) * rtDW.V_in[1];
            accum += *(Ds++) * rtDW.V_o[0];
            accum += *(Ds++) * rtDW.V_o[1];
            accum += *(Ds++) * rtDW.V_ow[0];
            accum += *(Ds++) * rtDW.V_ow[1];
            accum += *(Ds++) * rtDW.V_i[0];
            accum += *(Ds++) * rtDW.V_i[1];
            accum += *(Ds++) * rtDW.V_oe[0];
            accum += *(Ds++) * rtDW.V_j[1];
            accum += *(Ds++) * rtDW.V_j[0];
            accum += *(Ds++) * rtDW.V_b[1];
            accum += *(Ds++) * rtDW.V_b[0];
            accum += *(Ds++) * rtDW.V[1];
            accum += *(Ds++) * rtDW.V_k[1];
            accum += *(Ds++) * rtDW.V_n[1];
            accum += *(Ds++) * rtDW.V_n[0];
            accum += *(Ds++) * rtDW.Idc_a2;
            accum += *(Ds++) * rtDW.Idc_b;
            accum += *(Ds++) * rtDW.Idc_jt;
            accum += *(Ds++) * rtDW.Idc_nv[1];
            accum += *(Ds++) * rtDW.Idc_d[1];
            accum += *(Ds++) * rtDW.Idc_h[1];
            accum += *(Ds++) * rtDW.Idc_a;
            accum += *(Ds++) * rtDW.Idc_ay;
            accum += *(Ds++) * rtDW.Idc_o;
            accum += *(Ds++) * rtDW.Idc_e;
            accum += *(Ds++) * rtDW.Idc_j;
            accum += *(Ds++) * rtDW.Idc_n;
            accum += *(Ds++) * rtDW.Idc_nv[0];
            accum += *(Ds++) * rtDW.Idc;
            accum += *(Ds++) * rtDW.Idc_g;
            accum += *(Ds++) * rtDW.Idc_h[0];
            accum += *(Ds++) * rtDW.Idc_d[0];
            accum += *(Ds++) * rtDW.Sum5[0];
            accum += *(Ds++) * rtDW.Sum5[1];
            accum += *(Ds++) * rtDW.Sum5[2];
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
            accum += *(Ds++) * 0.001;
          }

          y0[i1] = accum;
        }
      }
    }

    /* Output new switches states */
    {
      int_T i1;
      real_T *y1 = &rtDW.StateSpace_o2_e[0];
      for (i1=0; i1 < 24; i1++) {
        y1[i1] = (real_T)switch_status[i1];
      }
    }
  }

  /* Sin: '<S434>/sin(wt)' */
  if (rtDW.systemEnable_f != 0) {
    rtDW.lastSin_o = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_n = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_f = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_o * 0.99999822347173384 + rtDW.lastCos_n *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_n * 0.99999822347173384 - rtDW.lastSin_o *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S434>/sin(wt)' */

  /* Product: '<S434>/Product' */
  rtb_Switch2 = rtDW.StateSpace_o1_m[30] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S444>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE != 0) {
    rtDW.Integ4 = rtDW.Integ4_DSTATE;
  } else {
    rtDW.Integ4 = 2.5E-6 * rtb_Switch2 + rtDW.Integ4_DSTATE;
  }

  /* End of DiscreteIntegrator: '<S444>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */

  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S444>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S444>/Switch' incorporates:
   *  Constant: '<S444>/K1'
   *  Constant: '<S444>/K2'
   *  Gain: '<S444>/Gain'
   *  Gain: '<S444>/Gain1'
   *  Product: '<S444>/Product'
   *  RelationalOperator: '<S444>/Relational Operator'
   *  Sum: '<S444>/Sum1'
   *  Sum: '<S444>/Sum5'
   *  Sum: '<S444>/Sum7'
   *  UnitDelay: '<S444>/Unit Delay'
   *  UnitDelay: '<S444>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch3 = (rtDW.Integ4 - rtDW.SFunction) * 60.0 +
      (-0.00013333333333336367 * rtb_Switch2 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_p);
  } else {
    rtb_Switch3 = rtDW.UnitDelay1_DSTATE_m;
  }

  /* End of Switch: '<S444>/Switch' */

  /* Sin: '<S434>/cos(wt)' */
  if (rtDW.systemEnable_b != 0) {
    rtDW.lastSin_j = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_i = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_b = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_j * 0.0018849544759281464 + rtDW.lastCos_i *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_i * 0.0018849544759281464 - rtDW.lastSin_j *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S434>/cos(wt)' */

  /* Product: '<S434>/Product1' */
  rtb_Product1_a3 = rtDW.StateSpace_o1_m[30] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S442>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_e != 0) {
    rtDW.Integ4_p = rtDW.Integ4_DSTATE_e;
  } else {
    rtDW.Integ4_p = 2.5E-6 * rtb_Product1_a3 + rtDW.Integ4_DSTATE_e;
  }

  /* End of DiscreteIntegrator: '<S442>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */

  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S442>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S442>/Switch' incorporates:
   *  Constant: '<S442>/K1'
   *  Constant: '<S442>/K2'
   *  Gain: '<S442>/Gain'
   *  Gain: '<S442>/Gain1'
   *  Product: '<S442>/Product'
   *  RelationalOperator: '<S442>/Relational Operator'
   *  Sum: '<S442>/Sum1'
   *  Sum: '<S442>/Sum5'
   *  Sum: '<S442>/Sum7'
   *  UnitDelay: '<S442>/Unit Delay'
   *  UnitDelay: '<S442>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_p = (rtDW.Integ4_p - rtDW.SFunction_e) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_a3 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_c);
  } else {
    rtb_Switch_p = rtDW.UnitDelay1_DSTATE_lc;
  }

  /* End of Switch: '<S442>/Switch' */

  /* ComplexToMagnitudeAngle: '<S434>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S434>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch3, rtb_Switch_p);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_p, rtb_Switch3);

  /* Gain: '<S432>/deg->rad' incorporates:
   *  Gain: '<S434>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S432>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S435>/sin(wt)' */
  if (rtDW.systemEnable_n != 0) {
    rtDW.lastSin_h = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_j = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_n = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_h * 0.99999822347173384 + rtDW.lastCos_j *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_j * 0.99999822347173384 - rtDW.lastSin_h *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S435>/sin(wt)' */

  /* Product: '<S435>/Product' */
  rtb_Product_jl = rtDW.StateSpace_o1_m[31] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S450>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_c != 0) {
    rtDW.Integ4_d = rtDW.Integ4_DSTATE_d;
  } else {
    rtDW.Integ4_d = 2.5E-6 * rtb_Product_jl + rtDW.Integ4_DSTATE_d;
  }

  /* End of DiscreteIntegrator: '<S450>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */

  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S450>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S450>/Switch' incorporates:
   *  Constant: '<S450>/K1'
   *  Constant: '<S450>/K2'
   *  Gain: '<S450>/Gain'
   *  Gain: '<S450>/Gain1'
   *  Product: '<S450>/Product'
   *  RelationalOperator: '<S450>/Relational Operator'
   *  Sum: '<S450>/Sum1'
   *  Sum: '<S450>/Sum5'
   *  Sum: '<S450>/Sum7'
   *  UnitDelay: '<S450>/Unit Delay'
   *  UnitDelay: '<S450>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_j5 = (rtDW.Integ4_d - rtDW.SFunction_em) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_jl - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_g);
  } else {
    rtb_Switch_j5 = rtDW.UnitDelay1_DSTATE_fh;
  }

  /* End of Switch: '<S450>/Switch' */

  /* Sin: '<S435>/cos(wt)' */
  if (rtDW.systemEnable_c != 0) {
    rtDW.lastSin_hi = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_o = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_c = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_hi * 0.0018849544759281464 + rtDW.lastCos_o *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_o * 0.0018849544759281464 - rtDW.lastSin_hi *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S435>/cos(wt)' */

  /* Product: '<S435>/Product1' */
  rtb_Product1_cj = rtDW.StateSpace_o1_m[31] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S448>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i != 0) {
    rtDW.Integ4_h = rtDW.Integ4_DSTATE_dw;
  } else {
    rtDW.Integ4_h = 2.5E-6 * rtb_Product1_cj + rtDW.Integ4_DSTATE_dw;
  }

  /* End of DiscreteIntegrator: '<S448>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */

  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S448>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S448>/Switch' incorporates:
   *  Constant: '<S448>/K1'
   *  Constant: '<S448>/K2'
   *  Gain: '<S448>/Gain'
   *  Gain: '<S448>/Gain1'
   *  Product: '<S448>/Product'
   *  RelationalOperator: '<S448>/Relational Operator'
   *  Sum: '<S448>/Sum1'
   *  Sum: '<S448>/Sum5'
   *  Sum: '<S448>/Sum7'
   *  UnitDelay: '<S448>/Unit Delay'
   *  UnitDelay: '<S448>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_a4 = (rtDW.Integ4_h - rtDW.SFunction_c) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_cj - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_e);
  } else {
    rtb_Switch_a4 = rtDW.UnitDelay1_DSTATE_jg;
  }

  /* End of Switch: '<S448>/Switch' */

  /* ComplexToMagnitudeAngle: '<S435>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S435>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_j5, rtb_Switch_a4);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_a4, rtb_Switch_j5);

  /* Gain: '<S432>/deg->rad1' incorporates:
   *  Gain: '<S435>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S432>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S436>/sin(wt)' */
  if (rtDW.systemEnable_a != 0) {
    rtDW.lastSin_e = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fk = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_a = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_e * 0.99999822347173384 + rtDW.lastCos_fk *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_fk * 0.99999822347173384 - rtDW.lastSin_e *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S436>/sin(wt)' */

  /* Product: '<S436>/Product' */
  rtb_Product_e = rtDW.StateSpace_o1_m[32] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S456>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_n != 0) {
    rtDW.Integ4_a = rtDW.Integ4_DSTATE_p;
  } else {
    rtDW.Integ4_a = 2.5E-6 * rtb_Product_e + rtDW.Integ4_DSTATE_p;
  }

  /* End of DiscreteIntegrator: '<S456>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S457>/S-Function' incorporates:
   *  Constant: '<S456>/K1'
   */

  /* Level2 S-Function Block: '<S457>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S456>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S456>/Switch' incorporates:
   *  Constant: '<S456>/K1'
   *  Constant: '<S456>/K2'
   *  Gain: '<S456>/Gain'
   *  Gain: '<S456>/Gain1'
   *  Product: '<S456>/Product'
   *  RelationalOperator: '<S456>/Relational Operator'
   *  Sum: '<S456>/Sum1'
   *  Sum: '<S456>/Sum5'
   *  Sum: '<S456>/Sum7'
   *  UnitDelay: '<S456>/Unit Delay'
   *  UnitDelay: '<S456>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_lc = (rtDW.Integ4_a - rtDW.SFunction_l) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_e - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_l);
  } else {
    rtb_Switch_lc = rtDW.UnitDelay1_DSTATE_n;
  }

  /* End of Switch: '<S456>/Switch' */

  /* Sin: '<S436>/cos(wt)' */
  if (rtDW.systemEnable_di != 0) {
    rtDW.lastSin_k = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_g = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_di = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_k * 0.0018849544759281464 + rtDW.lastCos_g *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_g * 0.0018849544759281464 - rtDW.lastSin_k *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S436>/cos(wt)' */

  /* Product: '<S436>/Product1' */
  rtb_Product1_cu = rtDW.StateSpace_o1_m[32] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S454>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_k != 0) {
    rtDW.Integ4_c = rtDW.Integ4_DSTATE_pr;
  } else {
    rtDW.Integ4_c = 2.5E-6 * rtb_Product1_cu + rtDW.Integ4_DSTATE_pr;
  }

  /* End of DiscreteIntegrator: '<S454>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S455>/S-Function' incorporates:
   *  Constant: '<S454>/K1'
   */

  /* Level2 S-Function Block: '<S455>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S454>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S454>/Switch' incorporates:
   *  Constant: '<S454>/K1'
   *  Constant: '<S454>/K2'
   *  Gain: '<S454>/Gain'
   *  Gain: '<S454>/Gain1'
   *  Product: '<S454>/Product'
   *  RelationalOperator: '<S454>/Relational Operator'
   *  Sum: '<S454>/Sum1'
   *  Sum: '<S454>/Sum5'
   *  Sum: '<S454>/Sum7'
   *  UnitDelay: '<S454>/Unit Delay'
   *  UnitDelay: '<S454>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_d5 = (rtDW.Integ4_c - rtDW.SFunction_h) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_cu - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_eo);
  } else {
    rtb_Switch_d5 = rtDW.UnitDelay1_DSTATE_h;
  }

  /* End of Switch: '<S454>/Switch' */

  /* ComplexToMagnitudeAngle: '<S436>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S436>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_lc, rtb_Switch_d5);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_d5, rtb_Switch_lc);

  /* Gain: '<S432>/deg->rad2' incorporates:
   *  Gain: '<S436>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S432>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Outputs for Enabled SubSystem: '<S432>/Pos. Seq. Computation' */
  /* Constant: '<S432>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_n);

  /* End of Outputs for SubSystem: '<S432>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S432>/Neg. Seq. Computation' */
  /* Constant: '<S432>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &Gain3_gs);

  /* End of Outputs for SubSystem: '<S432>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S432>/Zero Seq. Computation' */
  /* Constant: '<S432>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S432>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S432>/Complex to Magnitude-Angle' */
  rtb_UnitDelay_ai[0] = rt_hypotd_snf(rtDW.Gain3_n.re, rtDW.Gain3_n.im);
  rtb_UnitDelay3[0] = rt_atan2d_snf(rtDW.Gain3_n.im, rtDW.Gain3_n.re);

  /* Gain: '<Root>/to' */
  rtb_UnitDelay4_h[0] = -rtDW.StateSpace_o1_m[60];
  rtb_UnitDelay4_h[1] = -rtDW.StateSpace_o1_m[61];
  rtb_UnitDelay4_h[2] = -rtDW.StateSpace_o1_m[62];

  /* Sin: '<S458>/sin(wt)' */
  if (rtDW.systemEnable_fb != 0) {
    rtDW.lastSin_ob = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_k = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fb = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_ob * 0.99999822347173384 + rtDW.lastCos_k *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_k * 0.99999822347173384 - rtDW.lastSin_ob *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S458>/sin(wt)' */

  /* Product: '<S458>/Product' */
  rtb_Product_bk = rtb_UnitDelay4_h[0] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S468>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_g != 0) {
    rtDW.Integ4_ae = rtDW.Integ4_DSTATE_o;
  } else {
    rtDW.Integ4_ae = 2.5E-6 * rtb_Product_bk + rtDW.Integ4_DSTATE_o;
  }

  /* End of DiscreteIntegrator: '<S468>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */

  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S468>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S468>/Switch' incorporates:
   *  Constant: '<S468>/K1'
   *  Constant: '<S468>/K2'
   *  Gain: '<S468>/Gain'
   *  Gain: '<S468>/Gain1'
   *  Product: '<S468>/Product'
   *  RelationalOperator: '<S468>/Relational Operator'
   *  Sum: '<S468>/Sum1'
   *  Sum: '<S468>/Sum5'
   *  Sum: '<S468>/Sum7'
   *  UnitDelay: '<S468>/Unit Delay'
   *  UnitDelay: '<S468>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_g = (rtDW.Integ4_ae - rtDW.SFunction_c5) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_bk - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_h);
  } else {
    rtb_Switch_g = rtDW.UnitDelay1_DSTATE_au;
  }

  /* End of Switch: '<S468>/Switch' */

  /* Sin: '<S458>/cos(wt)' */
  if (rtDW.systemEnable_o != 0) {
    rtDW.lastSin_f = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_e = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_o = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_f * 0.0018849544759281464 + rtDW.lastCos_e *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_e * 0.0018849544759281464 - rtDW.lastSin_f *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S458>/cos(wt)' */

  /* Product: '<S458>/Product1' */
  rtb_Product1_om = rtb_UnitDelay4_h[0] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S466>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ex != 0) {
    rtDW.Integ4_k = rtDW.Integ4_DSTATE_i;
  } else {
    rtDW.Integ4_k = 2.5E-6 * rtb_Product1_om + rtDW.Integ4_DSTATE_i;
  }

  /* End of DiscreteIntegrator: '<S466>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S467>/S-Function' incorporates:
   *  Constant: '<S466>/K1'
   */

  /* Level2 S-Function Block: '<S467>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S466>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S466>/Switch' incorporates:
   *  Constant: '<S466>/K1'
   *  Constant: '<S466>/K2'
   *  Gain: '<S466>/Gain'
   *  Gain: '<S466>/Gain1'
   *  Product: '<S466>/Product'
   *  RelationalOperator: '<S466>/Relational Operator'
   *  Sum: '<S466>/Sum1'
   *  Sum: '<S466>/Sum5'
   *  Sum: '<S466>/Sum7'
   *  UnitDelay: '<S466>/Unit Delay'
   *  UnitDelay: '<S466>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_i = (rtDW.Integ4_k - rtDW.SFunction_c1) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_om - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_f);
  } else {
    rtb_Switch_i = rtDW.UnitDelay1_DSTATE_av;
  }

  /* End of Switch: '<S466>/Switch' */

  /* ComplexToMagnitudeAngle: '<S458>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S458>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_g, rtb_Switch_i);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_i, rtb_Switch_g);

  /* Gain: '<S433>/deg->rad' incorporates:
   *  Gain: '<S458>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S433>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S459>/sin(wt)' */
  if (rtDW.systemEnable_p != 0) {
    rtDW.lastSin_h0 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ov = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_p = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_h0 * 0.99999822347173384 + rtDW.lastCos_ov *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_ov * 0.99999822347173384 - rtDW.lastSin_h0 *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S459>/sin(wt)' */

  /* Product: '<S459>/Product' */
  rtb_Product_gi = rtb_UnitDelay4_h[1] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S474>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_kl != 0) {
    rtDW.Integ4_dh = rtDW.Integ4_DSTATE_g;
  } else {
    rtDW.Integ4_dh = 2.5E-6 * rtb_Product_gi + rtDW.Integ4_DSTATE_g;
  }

  /* End of DiscreteIntegrator: '<S474>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */

  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S474>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S474>/Switch' incorporates:
   *  Constant: '<S474>/K1'
   *  Constant: '<S474>/K2'
   *  Gain: '<S474>/Gain'
   *  Gain: '<S474>/Gain1'
   *  Product: '<S474>/Product'
   *  RelationalOperator: '<S474>/Relational Operator'
   *  Sum: '<S474>/Sum1'
   *  Sum: '<S474>/Sum5'
   *  Sum: '<S474>/Sum7'
   *  UnitDelay: '<S474>/Unit Delay'
   *  UnitDelay: '<S474>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_fr = (rtDW.Integ4_dh - rtDW.SFunction_g) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_gi - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_b);
  } else {
    rtb_Switch_fr = rtDW.UnitDelay1_DSTATE_mw;
  }

  /* End of Switch: '<S474>/Switch' */

  /* Sin: '<S459>/cos(wt)' */
  if (rtDW.systemEnable_e != 0) {
    rtDW.lastSin_a = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_hg = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_a * 0.0018849544759281464 + rtDW.lastCos_hg *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_hg * 0.0018849544759281464 - rtDW.lastSin_a *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S459>/cos(wt)' */

  /* Product: '<S459>/Product1' */
  rtb_Product1_m1 = rtb_UnitDelay4_h[1] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S472>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_l != 0) {
    rtDW.Integ4_b = rtDW.Integ4_DSTATE_m;
  } else {
    rtDW.Integ4_b = 2.5E-6 * rtb_Product1_m1 + rtDW.Integ4_DSTATE_m;
  }

  /* End of DiscreteIntegrator: '<S472>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S473>/S-Function' incorporates:
   *  Constant: '<S472>/K1'
   */

  /* Level2 S-Function Block: '<S473>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S472>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S472>/Switch' incorporates:
   *  Constant: '<S472>/K1'
   *  Constant: '<S472>/K2'
   *  Gain: '<S472>/Gain'
   *  Gain: '<S472>/Gain1'
   *  Product: '<S472>/Product'
   *  RelationalOperator: '<S472>/Relational Operator'
   *  Sum: '<S472>/Sum1'
   *  Sum: '<S472>/Sum5'
   *  Sum: '<S472>/Sum7'
   *  UnitDelay: '<S472>/Unit Delay'
   *  UnitDelay: '<S472>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_b = (rtDW.Integ4_b - rtDW.SFunction_gi) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_m1 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_lm);
  } else {
    rtb_Switch_b = rtDW.UnitDelay1_DSTATE_o;
  }

  /* End of Switch: '<S472>/Switch' */

  /* ComplexToMagnitudeAngle: '<S459>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S459>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_fr, rtb_Switch_b);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_b, rtb_Switch_fr);

  /* Gain: '<S433>/deg->rad1' incorporates:
   *  Gain: '<S459>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S433>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S460>/sin(wt)' */
  if (rtDW.systemEnable_l != 0) {
    rtDW.lastSin_fx = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_c = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_l = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_fx * 0.99999822347173384 + rtDW.lastCos_c *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_c * 0.99999822347173384 - rtDW.lastSin_fx *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S460>/sin(wt)' */

  /* Product: '<S460>/Product' */
  rtb_Product_o = rtb_UnitDelay4_h[2] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S480>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_k2 != 0) {
    rtDW.Integ4_hq = rtDW.Integ4_DSTATE_j;
  } else {
    rtDW.Integ4_hq = 2.5E-6 * rtb_Product_o + rtDW.Integ4_DSTATE_j;
  }

  /* End of DiscreteIntegrator: '<S480>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S481>/S-Function' incorporates:
   *  Constant: '<S480>/K1'
   */

  /* Level2 S-Function Block: '<S481>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S480>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S480>/Switch' incorporates:
   *  Constant: '<S480>/K1'
   *  Constant: '<S480>/K2'
   *  Gain: '<S480>/Gain'
   *  Gain: '<S480>/Gain1'
   *  Product: '<S480>/Product'
   *  RelationalOperator: '<S480>/Relational Operator'
   *  Sum: '<S480>/Sum1'
   *  Sum: '<S480>/Sum5'
   *  Sum: '<S480>/Sum7'
   *  UnitDelay: '<S480>/Unit Delay'
   *  UnitDelay: '<S480>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_f = (rtDW.Integ4_hq - rtDW.SFunction_lu) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_o - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_i);
  } else {
    rtb_Switch_f = rtDW.UnitDelay1_DSTATE_jl;
  }

  /* End of Switch: '<S480>/Switch' */

  /* Sin: '<S460>/cos(wt)' */
  if (rtDW.systemEnable_g != 0) {
    rtDW.lastSin_f2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ni = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_g = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_f2 * 0.0018849544759281464 + rtDW.lastCos_ni
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_ni * 0.0018849544759281464 - rtDW.lastSin_f2
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S460>/cos(wt)' */

  /* Product: '<S460>/Product1' */
  rtb_Product1_ly = rtb_UnitDelay4_h[2] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S478>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_j != 0) {
    rtDW.Integ4_j = rtDW.Integ4_DSTATE_l;
  } else {
    rtDW.Integ4_j = 2.5E-6 * rtb_Product1_ly + rtDW.Integ4_DSTATE_l;
  }

  /* End of DiscreteIntegrator: '<S478>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S479>/S-Function' incorporates:
   *  Constant: '<S478>/K1'
   */

  /* Level2 S-Function Block: '<S479>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S478>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S478>/Switch' incorporates:
   *  Constant: '<S478>/K1'
   *  Constant: '<S478>/K2'
   *  Gain: '<S478>/Gain'
   *  Gain: '<S478>/Gain1'
   *  Product: '<S478>/Product'
   *  RelationalOperator: '<S478>/Relational Operator'
   *  Sum: '<S478>/Sum1'
   *  Sum: '<S478>/Sum5'
   *  Sum: '<S478>/Sum7'
   *  UnitDelay: '<S478>/Unit Delay'
   *  UnitDelay: '<S478>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_fz = (rtDW.Integ4_j - rtDW.SFunction_hd) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_ly - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ps);
  } else {
    rtb_Switch_fz = rtDW.UnitDelay1_DSTATE_ha;
  }

  /* End of Switch: '<S478>/Switch' */

  /* ComplexToMagnitudeAngle: '<S460>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S460>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_f, rtb_Switch_fz);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_fz, rtb_Switch_f);

  /* Gain: '<S433>/deg->rad2' incorporates:
   *  Gain: '<S460>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S433>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Outputs for Enabled SubSystem: '<S433>/Pos. Seq. Computation' */
  /* Constant: '<S433>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_fk);

  /* End of Outputs for SubSystem: '<S433>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S433>/Neg. Seq. Computation' */
  /* Constant: '<S433>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &Gain3_gs);

  /* End of Outputs for SubSystem: '<S433>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S433>/Zero Seq. Computation' */
  /* Constant: '<S433>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S433>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S433>/Complex to Magnitude-Angle' */
  rtb_UnitDelay4_h[0] = rt_hypotd_snf(rtDW.Gain3_fk.re, rtDW.Gain3_fk.im);
  rtb_UnitDelay1_d[0] = rt_atan2d_snf(rtDW.Gain3_fk.im, rtDW.Gain3_fk.re);

  /* Product: '<S21>/Product' */
  rtb_UnitDelay6_e = rtb_UnitDelay_ai[0] * rtb_UnitDelay4_h[0];

  /* Gain: '<S21>/Gain1' */
  rtb_UnitDelay6_e *= 1.5;

  /* Gain: '<S432>/rad->deg1' */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay3[0];

  /* Gain: '<S21>/Deg->Rad' incorporates:
   *  Gain: '<S433>/rad->deg1'
   *  Sum: '<S21>/Sum'
   */
  rtb_phi = (rtb_UnitDelay7_b - 57.295779513082323 * rtb_UnitDelay1_d[0]) *
    0.017453292519943295;

  /* Outport: '<Root>/Out1' incorporates:
   *  Product: '<S21>/Product1'
   *  Trigonometry: '<S21>/Trigonometric Function2'
   */
  rtY.Pgrid = rtb_UnitDelay6_e * cos(rtb_phi);

  /* Outport: '<Root>/Out20' */
  rtY.Vgrid[0] = rtDW.StateSpace_o1_m[30];

  /* Outport: '<Root>/Out21' */
  rtY.Igrid[0] = rtDW.StateSpace_o1_m[60];

  /* Outport: '<Root>/Out20' */
  rtY.Vgrid[1] = rtDW.StateSpace_o1_m[31];

  /* Outport: '<Root>/Out21' */
  rtY.Igrid[1] = rtDW.StateSpace_o1_m[61];

  /* Outport: '<Root>/Out20' */
  rtY.Vgrid[2] = rtDW.StateSpace_o1_m[32];

  /* Outport: '<Root>/Out21' */
  rtY.Igrid[2] = rtDW.StateSpace_o1_m[62];

  /* Sin: '<S902>/sin(wt)' */
  if (rtDW.systemEnable_nr != 0) {
    rtDW.lastSin_fm = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_e4 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_nr = 0;
  }

  rtb_UnitDelay7_b = ((rtDW.lastSin_fm * 0.99999822347173384 + rtDW.lastCos_e4 *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_e4 * 0.99999822347173384 - rtDW.lastSin_fm *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S902>/sin(wt)' */

  /* Product: '<S902>/Product' */
  rtb_Product_kx = rtDW.StateSpace_o1_m[30] * rtb_UnitDelay7_b;

  /* DiscreteIntegrator: '<S912>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_o != 0) {
    rtDW.Integ4_f = rtDW.Integ4_DSTATE_os;
  } else {
    rtDW.Integ4_f = 2.5E-6 * rtb_Product_kx + rtDW.Integ4_DSTATE_os;
  }

  /* End of DiscreteIntegrator: '<S912>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S913>/S-Function' incorporates:
   *  Constant: '<S912>/K1'
   */

  /* Level2 S-Function Block: '<S913>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S912>/Digital  Clock' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Switch: '<S912>/Switch' incorporates:
   *  Constant: '<S912>/K1'
   *  Constant: '<S912>/K2'
   *  Gain: '<S912>/Gain'
   *  Gain: '<S912>/Gain1'
   *  Product: '<S912>/Product'
   *  RelationalOperator: '<S912>/Relational Operator'
   *  Sum: '<S912>/Sum1'
   *  Sum: '<S912>/Sum5'
   *  Sum: '<S912>/Sum7'
   *  UnitDelay: '<S912>/Unit Delay'
   *  UnitDelay: '<S912>/Unit Delay1'
   */
  if (rtb_UnitDelay7_b >= 0.01667) {
    rtb_Switch_c = (rtDW.Integ4_f - rtDW.SFunction_ez) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_kx - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_or);
  } else {
    rtb_Switch_c = rtDW.UnitDelay1_DSTATE_ay;
  }

  /* End of Switch: '<S912>/Switch' */

  /* Sin: '<S902>/cos(wt)' */
  if (rtDW.systemEnable_nk != 0) {
    rtDW.lastSin_f5 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_l = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_nk = 0;
  }

  rtb_UnitDelay7_b = ((rtDW.lastSin_f5 * 0.0018849544759281464 + rtDW.lastCos_l *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_l * 0.0018849544759281464 - rtDW.lastSin_f5 *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S902>/cos(wt)' */

  /* Product: '<S902>/Product1' */
  rtb_Product1_a = rtDW.StateSpace_o1_m[30] * rtb_UnitDelay7_b;

  /* DiscreteIntegrator: '<S910>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_km != 0) {
    rtDW.Integ4_aa = rtDW.Integ4_DSTATE_lo;
  } else {
    rtDW.Integ4_aa = 2.5E-6 * rtb_Product1_a + rtDW.Integ4_DSTATE_lo;
  }

  /* End of DiscreteIntegrator: '<S910>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S911>/S-Function' incorporates:
   *  Constant: '<S910>/K1'
   */

  /* Level2 S-Function Block: '<S911>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S910>/Digital  Clock' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Switch: '<S910>/Switch' incorporates:
   *  Constant: '<S910>/K1'
   *  Constant: '<S910>/K2'
   *  Gain: '<S910>/Gain'
   *  Gain: '<S910>/Gain1'
   *  Product: '<S910>/Product'
   *  RelationalOperator: '<S910>/Relational Operator'
   *  Sum: '<S910>/Sum1'
   *  Sum: '<S910>/Sum5'
   *  Sum: '<S910>/Sum7'
   *  UnitDelay: '<S910>/Unit Delay'
   *  UnitDelay: '<S910>/Unit Delay1'
   */
  if (rtb_UnitDelay7_b >= 0.01667) {
    rtb_Switch_d = (rtDW.Integ4_aa - rtDW.SFunction_d) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_a - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_a);
  } else {
    rtb_Switch_d = rtDW.UnitDelay1_DSTATE_e;
  }

  /* End of Switch: '<S910>/Switch' */

  /* ComplexToMagnitudeAngle: '<S902>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S902>/Real-Imag to Complex'
   */
  rtb_UnitDelay7_b = rt_hypotd_snf(rtb_Switch_c, rtb_Switch_d);

  /* Gain: '<S32>/deg->rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S902>/Complex to Magnitude-Angle'
   *  Gain: '<S902>/Rad->Deg.'
   *  RealImagToComplex: '<S902>/Real-Imag to Complex'
   */
  rtb_sinwt = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_d, rtb_Switch_c) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S32>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay7_b * cos(rtb_sinwt);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay7_b * sin(rtb_sinwt);

  /* Sin: '<S903>/sin(wt)' */
  if (rtDW.systemEnable_lm != 0) {
    rtDW.lastSin_fmt = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ns = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_lm = 0;
  }

  rtb_UnitDelay7_b = ((rtDW.lastSin_fmt * 0.99999822347173384 + rtDW.lastCos_ns *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_ns * 0.99999822347173384 - rtDW.lastSin_fmt *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S903>/sin(wt)' */

  /* Product: '<S903>/Product' */
  rtb_Product_h5 = rtDW.StateSpace_o1_m[31] * rtb_UnitDelay7_b;

  /* DiscreteIntegrator: '<S918>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_f != 0) {
    rtDW.Integ4_f0 = rtDW.Integ4_DSTATE_n;
  } else {
    rtDW.Integ4_f0 = 2.5E-6 * rtb_Product_h5 + rtDW.Integ4_DSTATE_n;
  }

  /* End of DiscreteIntegrator: '<S918>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S919>/S-Function' incorporates:
   *  Constant: '<S918>/K1'
   */

  /* Level2 S-Function Block: '<S919>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S918>/Digital  Clock' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Switch: '<S918>/Switch' incorporates:
   *  Constant: '<S918>/K1'
   *  Constant: '<S918>/K2'
   *  Gain: '<S918>/Gain'
   *  Gain: '<S918>/Gain1'
   *  Product: '<S918>/Product'
   *  RelationalOperator: '<S918>/Relational Operator'
   *  Sum: '<S918>/Sum1'
   *  Sum: '<S918>/Sum5'
   *  Sum: '<S918>/Sum7'
   *  UnitDelay: '<S918>/Unit Delay'
   *  UnitDelay: '<S918>/Unit Delay1'
   */
  if (rtb_UnitDelay7_b >= 0.01667) {
    rtb_Switch_a = (rtDW.Integ4_f0 - rtDW.SFunction_dm) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_h5 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ln);
  } else {
    rtb_Switch_a = rtDW.UnitDelay1_DSTATE_ca;
  }

  /* End of Switch: '<S918>/Switch' */

  /* Sin: '<S903>/cos(wt)' */
  if (rtDW.systemEnable_fk != 0) {
    rtDW.lastSin_d = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_a = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fk = 0;
  }

  rtb_UnitDelay7_b = ((rtDW.lastSin_d * 0.0018849544759281464 + rtDW.lastCos_a *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_a * 0.0018849544759281464 - rtDW.lastSin_d *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S903>/cos(wt)' */

  /* Product: '<S903>/Product1' */
  rtb_Product1_dm = rtDW.StateSpace_o1_m[31] * rtb_UnitDelay7_b;

  /* DiscreteIntegrator: '<S916>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_fy != 0) {
    rtDW.Integ4_i = rtDW.Integ4_DSTATE_lc;
  } else {
    rtDW.Integ4_i = 2.5E-6 * rtb_Product1_dm + rtDW.Integ4_DSTATE_lc;
  }

  /* End of DiscreteIntegrator: '<S916>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S917>/S-Function' incorporates:
   *  Constant: '<S916>/K1'
   */

  /* Level2 S-Function Block: '<S917>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S916>/Digital  Clock' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Switch: '<S916>/Switch' incorporates:
   *  Constant: '<S916>/K1'
   *  Constant: '<S916>/K2'
   *  Gain: '<S916>/Gain'
   *  Gain: '<S916>/Gain1'
   *  Product: '<S916>/Product'
   *  RelationalOperator: '<S916>/Relational Operator'
   *  Sum: '<S916>/Sum1'
   *  Sum: '<S916>/Sum5'
   *  Sum: '<S916>/Sum7'
   *  UnitDelay: '<S916>/Unit Delay'
   *  UnitDelay: '<S916>/Unit Delay1'
   */
  if (rtb_UnitDelay7_b >= 0.01667) {
    rtb_Switch_kul = (rtDW.Integ4_i - rtDW.SFunction_gs) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_dm - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_n);
  } else {
    rtb_Switch_kul = rtDW.UnitDelay1_DSTATE_ag;
  }

  /* End of Switch: '<S916>/Switch' */

  /* ComplexToMagnitudeAngle: '<S903>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S903>/Real-Imag to Complex'
   */
  rtb_UnitDelay7_b = rt_hypotd_snf(rtb_Switch_a, rtb_Switch_kul);

  /* Gain: '<S32>/deg->rad1' incorporates:
   *  ComplexToMagnitudeAngle: '<S903>/Complex to Magnitude-Angle'
   *  Gain: '<S903>/Rad->Deg.'
   *  RealImagToComplex: '<S903>/Real-Imag to Complex'
   */
  rtb_sinwt = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_kul, rtb_Switch_a) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S32>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay7_b * cos(rtb_sinwt);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay7_b * sin(rtb_sinwt);

  /* Sin: '<S904>/sin(wt)' */
  if (rtDW.systemEnable_es != 0) {
    rtDW.lastSin_d1 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_d = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_es = 0;
  }

  rtb_UnitDelay7_b = ((rtDW.lastSin_d1 * 0.99999822347173384 + rtDW.lastCos_d *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_d * 0.99999822347173384 - rtDW.lastSin_d1 *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S904>/sin(wt)' */

  /* Product: '<S904>/Product' */
  rtb_Product_gk = rtDW.StateSpace_o1_m[32] * rtb_UnitDelay7_b;

  /* DiscreteIntegrator: '<S924>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_n0 != 0) {
    rtDW.Integ4_l = rtDW.Integ4_DSTATE_o0;
  } else {
    rtDW.Integ4_l = 2.5E-6 * rtb_Product_gk + rtDW.Integ4_DSTATE_o0;
  }

  /* End of DiscreteIntegrator: '<S924>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S925>/S-Function' incorporates:
   *  Constant: '<S924>/K1'
   */

  /* Level2 S-Function Block: '<S925>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S924>/Digital  Clock' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Switch: '<S924>/Switch' incorporates:
   *  Constant: '<S924>/K1'
   *  Constant: '<S924>/K2'
   *  Gain: '<S924>/Gain'
   *  Gain: '<S924>/Gain1'
   *  Product: '<S924>/Product'
   *  RelationalOperator: '<S924>/Relational Operator'
   *  Sum: '<S924>/Sum1'
   *  Sum: '<S924>/Sum5'
   *  Sum: '<S924>/Sum7'
   *  UnitDelay: '<S924>/Unit Delay'
   *  UnitDelay: '<S924>/Unit Delay1'
   */
  if (rtb_UnitDelay7_b >= 0.01667) {
    rtb_Switch_lu = (rtDW.Integ4_l - rtDW.SFunction_dy) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_gk - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_gs);
  } else {
    rtb_Switch_lu = rtDW.UnitDelay1_DSTATE_cr;
  }

  /* End of Switch: '<S924>/Switch' */

  /* Sin: '<S904>/cos(wt)' */
  if (rtDW.systemEnable_eq != 0) {
    rtDW.lastSin_l = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_l0 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_eq = 0;
  }

  rtb_UnitDelay7_b = ((rtDW.lastSin_l * 0.0018849544759281464 + rtDW.lastCos_l0 *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_l0 * 0.0018849544759281464 - rtDW.lastSin_l *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S904>/cos(wt)' */

  /* Product: '<S904>/Product1' */
  rtb_Product1_id = rtDW.StateSpace_o1_m[32] * rtb_UnitDelay7_b;

  /* DiscreteIntegrator: '<S922>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_d != 0) {
    rtDW.Integ4_g = rtDW.Integ4_DSTATE_pu;
  } else {
    rtDW.Integ4_g = 2.5E-6 * rtb_Product1_id + rtDW.Integ4_DSTATE_pu;
  }

  /* End of DiscreteIntegrator: '<S922>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S923>/S-Function' incorporates:
   *  Constant: '<S922>/K1'
   */

  /* Level2 S-Function Block: '<S923>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S922>/Digital  Clock' */
  rtb_UnitDelay7_b = rtM->Timing.t[0];

  /* Switch: '<S922>/Switch' incorporates:
   *  Constant: '<S922>/K1'
   *  Constant: '<S922>/K2'
   *  Gain: '<S922>/Gain'
   *  Gain: '<S922>/Gain1'
   *  Product: '<S922>/Product'
   *  RelationalOperator: '<S922>/Relational Operator'
   *  Sum: '<S922>/Sum1'
   *  Sum: '<S922>/Sum5'
   *  Sum: '<S922>/Sum7'
   *  UnitDelay: '<S922>/Unit Delay'
   *  UnitDelay: '<S922>/Unit Delay1'
   */
  if (rtb_UnitDelay7_b >= 0.01667) {
    rtb_Switch_pr = (rtDW.Integ4_g - rtDW.SFunction_p) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_id - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_p3);
  } else {
    rtb_Switch_pr = rtDW.UnitDelay1_DSTATE_p;
  }

  /* End of Switch: '<S922>/Switch' */

  /* ComplexToMagnitudeAngle: '<S904>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S904>/Real-Imag to Complex'
   */
  rtb_UnitDelay7_b = rt_hypotd_snf(rtb_Switch_lu, rtb_Switch_pr);

  /* Gain: '<S32>/deg->rad2' incorporates:
   *  ComplexToMagnitudeAngle: '<S904>/Complex to Magnitude-Angle'
   *  Gain: '<S904>/Rad->Deg.'
   *  RealImagToComplex: '<S904>/Real-Imag to Complex'
   */
  rtb_sinwt = 57.295779513082323 * rt_atan2d_snf(rtb_Switch_pr, rtb_Switch_lu) *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S32>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay7_b * cos(rtb_sinwt);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay7_b * sin(rtb_sinwt);

  /* Outputs for Enabled SubSystem: '<S32>/Pos. Seq. Computation' */
  /* Constant: '<S32>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_e);

  /* End of Outputs for SubSystem: '<S32>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S32>/Neg. Seq. Computation' */
  /* Constant: '<S32>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &Gain3_gs);

  /* End of Outputs for SubSystem: '<S32>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S32>/Zero Seq. Computation' */
  /* Constant: '<S32>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &Gain3_gs);

  /* End of Outputs for SubSystem: '<S32>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S32>/Complex to Magnitude-Angle' */
  rtb_UnitDelay1_d[0] = rt_hypotd_snf(rtDW.Gain3_e.re, rtDW.Gain3_e.im);

  /* Outport: '<Root>/Out22' incorporates:
   *  Gain: '<Root>/to-pu3'
   */
  rtY.V1grid_pu = 4.8989794855663556E-5 * rtb_UnitDelay1_d[0];

  /* Outport: '<Root>/Out23' incorporates:
   *  Product: '<S21>/Product3'
   *  Trigonometry: '<S21>/Trigonometric Function2'
   */
  rtY.Qgrid = rtb_UnitDelay6_e * sin(rtb_phi);

  /* Product: '<Root>/Product' incorporates:
   *  Product: '<S23>/Product'
   */
  rtb_sinwt = rtDW.StateSpace_o1_m[35] * rtDW.StateSpace_o1_m[66];

  /* DiscreteIntegrator: '<S410>/Integ4' incorporates:
   *  Product: '<Root>/Product'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_a != 0) {
    rtDW.Integ4_m = rtDW.Integ4_DSTATE_jc;
  } else {
    rtDW.Integ4_m = 2.5E-6 * rtb_sinwt + rtDW.Integ4_DSTATE_jc;
  }

  /* End of DiscreteIntegrator: '<S410>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S411>/S-Function' incorporates:
   *  Constant: '<S410>/K1'
   */

  /* Level2 S-Function Block: '<S411>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S410>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S410>/Switch' incorporates:
   *  Constant: '<S410>/K1'
   *  Constant: '<S410>/K2'
   *  Gain: '<S410>/Gain'
   *  Gain: '<S410>/Gain1'
   *  Product: '<Root>/Product'
   *  Product: '<S410>/Product'
   *  RelationalOperator: '<S410>/Relational Operator'
   *  Sum: '<S410>/Sum1'
   *  Sum: '<S410>/Sum5'
   *  Sum: '<S410>/Sum7'
   *  UnitDelay: '<S410>/Unit Delay'
   *  UnitDelay: '<S410>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_phi = (rtDW.Integ4_m - rtDW.SFunction_f) * 60.0 +
      (-0.00013333333333336367 * rtb_sinwt - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_bm);
  } else {
    rtb_phi = rtDW.UnitDelay1_DSTATE_m0;
  }

  /* End of Switch: '<S410>/Switch' */

  /* Outport: '<Root>/Out2' */
  rtY.Pbuck = rtb_phi;

  /* Outport: '<Root>/Out24' */
  rtY.Vbuck = rtDW.StateSpace_o1_m[35];

  /* Outport: '<Root>/Out25' */
  rtY.Ibuck = rtDW.StateSpace_o1_m[66];

  /* Product: '<Root>/Product1' incorporates:
   *  Product: '<S23>/Product1'
   */
  rtb_Product1_g_tmp = rtDW.StateSpace_o1_m[33] * rtDW.StateSpace_o1_m[63];

  /* DiscreteIntegrator: '<S412>/Integ4' incorporates:
   *  Product: '<Root>/Product1'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_h != 0) {
    rtDW.Integ4_fr = rtDW.Integ4_DSTATE_id;
  } else {
    rtDW.Integ4_fr = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_DSTATE_id;
  }

  /* End of DiscreteIntegrator: '<S412>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */

  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S412>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S412>/Switch' incorporates:
   *  Constant: '<S412>/K1'
   *  Constant: '<S412>/K2'
   *  Gain: '<S412>/Gain'
   *  Gain: '<S412>/Gain1'
   *  Product: '<Root>/Product1'
   *  Product: '<S412>/Product'
   *  RelationalOperator: '<S412>/Relational Operator'
   *  Sum: '<S412>/Sum1'
   *  Sum: '<S412>/Sum5'
   *  Sum: '<S412>/Sum7'
   *  UnitDelay: '<S412>/Unit Delay'
   *  UnitDelay: '<S412>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_lo = (rtDW.Integ4_fr - rtDW.SFunction_ct) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_g_tmp - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_cr);
  } else {
    rtb_Switch_lo = rtDW.UnitDelay1_DSTATE_g;
  }

  /* End of Switch: '<S412>/Switch' */

  /* Outport: '<Root>/Out3' */
  rtY.Pboost = rtb_Switch_lo;

  /* Outport: '<Root>/Out32' */
  rtY.Vboost = rtDW.StateSpace_o1_m[33];

  /* Outport: '<Root>/Out33' */
  rtY.Iboost = rtDW.StateSpace_o1_m[63];

  /* Product: '<Root>/Product2' incorporates:
   *  Product: '<S23>/Product2'
   */
  rtb_Product2_tmp = rtDW.StateSpace_o1_m[51] * rtDW.StateSpace_o1_m[76];

  /* DiscreteIntegrator: '<S414>/Integ4' incorporates:
   *  Product: '<Root>/Product2'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_m != 0) {
    rtDW.Integ4_mt = rtDW.Integ4_DSTATE_h;
  } else {
    rtDW.Integ4_mt = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_DSTATE_h;
  }

  /* End of DiscreteIntegrator: '<S414>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */

  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S414>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S414>/Switch' incorporates:
   *  Constant: '<S414>/K1'
   *  Constant: '<S414>/K2'
   *  Gain: '<S414>/Gain'
   *  Gain: '<S414>/Gain1'
   *  Product: '<Root>/Product2'
   *  Product: '<S414>/Product'
   *  RelationalOperator: '<S414>/Relational Operator'
   *  Sum: '<S414>/Sum1'
   *  Sum: '<S414>/Sum5'
   *  Sum: '<S414>/Sum7'
   *  UnitDelay: '<S414>/Unit Delay'
   *  UnitDelay: '<S414>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_pa = (rtDW.Integ4_mt - rtDW.SFunction_n) * 60.0 +
      (-0.00013333333333336367 * rtb_Product2_tmp - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_m);
  } else {
    rtb_Switch_pa = rtDW.UnitDelay1_DSTATE_ags;
  }

  /* End of Switch: '<S414>/Switch' */

  /* Outport: '<Root>/Out4' */
  rtY.Pmotor = rtb_Switch_pa;

  /* Outport: '<Root>/Out37' */
  rtY.Vmotor = rtDW.StateSpace_o1_m[51];

  /* Outport: '<Root>/Out38' */
  rtY.Imotor_m = rtDW.StateSpace_o1_m[76];

  /* Product: '<Root>/Product3' incorporates:
   *  Product: '<S23>/Product3'
   */
  rtb_Product3_h_tmp = rtDW.StateSpace_o1[2] * rtDW.StateSpace_o1[5];

  /* DiscreteIntegrator: '<S416>/Integ4' incorporates:
   *  Product: '<Root>/Product3'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_o0 != 0) {
    rtDW.Integ4_ge = rtDW.Integ4_DSTATE_oi;
  } else {
    rtDW.Integ4_ge = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_DSTATE_oi;
  }

  /* End of DiscreteIntegrator: '<S416>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S417>/S-Function' incorporates:
   *  Constant: '<S416>/K1'
   */

  /* Level2 S-Function Block: '<S417>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S416>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S416>/Switch' incorporates:
   *  Constant: '<S416>/K1'
   *  Constant: '<S416>/K2'
   *  Gain: '<S416>/Gain'
   *  Gain: '<S416>/Gain1'
   *  Product: '<Root>/Product3'
   *  Product: '<S416>/Product'
   *  RelationalOperator: '<S416>/Relational Operator'
   *  Sum: '<S416>/Sum1'
   *  Sum: '<S416>/Sum5'
   *  Sum: '<S416>/Sum7'
   *  UnitDelay: '<S416>/Unit Delay'
   *  UnitDelay: '<S416>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.02) {
    rtb_Switch_pt = (rtDW.Integ4_ge - rtDW.SFunction_k) * 50.0 +
      (-1.1368683772159017E-16 * rtb_Product3_h_tmp - 2.5849394142282115E-29 *
       rtDW.UnitDelay_DSTATE_ez);
  } else {
    rtb_Switch_pt = rtDW.UnitDelay1_DSTATE_lg;
  }

  /* End of Switch: '<S416>/Switch' */

  /* Outport: '<Root>/Out5' */
  rtY.PFB = rtb_Switch_pt;

  /* Outport: '<Root>/Out39' */
  rtY.VFB = rtDW.StateSpace_o1[2];

  /* Outport: '<Root>/Out40' */
  rtY.IFB = rtDW.StateSpace_o1[5];

  /* Sin: '<S418>/sin(wt)' */
  if (rtDW.systemEnable_m != 0) {
    rtDW.lastSin_m = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ovt = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_m = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_m * 0.99999822347173384 + rtDW.lastCos_ovt *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_ovt * 0.99999822347173384 - rtDW.lastSin_m *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S418>/sin(wt)' */

  /* Product: '<S418>/Product' */
  rtb_Product_f = rtDW.StateSpace_o1_m[41] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S424>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_b != 0) {
    rtDW.Integ4_lf = rtDW.Integ4_DSTATE_pg;
  } else {
    rtDW.Integ4_lf = 2.5E-6 * rtb_Product_f + rtDW.Integ4_DSTATE_pg;
  }

  /* End of DiscreteIntegrator: '<S424>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */

  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S424>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S424>/Switch' incorporates:
   *  Constant: '<S424>/K1'
   *  Constant: '<S424>/K2'
   *  Gain: '<S424>/Gain'
   *  Gain: '<S424>/Gain1'
   *  Product: '<S424>/Product'
   *  RelationalOperator: '<S424>/Relational Operator'
   *  Sum: '<S424>/Sum1'
   *  Sum: '<S424>/Sum5'
   *  Sum: '<S424>/Sum7'
   *  UnitDelay: '<S424>/Unit Delay'
   *  UnitDelay: '<S424>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_ly = (rtDW.Integ4_lf - rtDW.SFunction_o) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_f - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_aq);
  } else {
    rtb_Switch_ly = rtDW.UnitDelay1_DSTATE_jx;
  }

  /* End of Switch: '<S424>/Switch' */

  /* Sin: '<S418>/cos(wt)' */
  if (rtDW.systemEnable_e2 != 0) {
    rtDW.lastSin_fl = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_nl = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e2 = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_fl * 0.0018849544759281464 + rtDW.lastCos_nl
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_nl * 0.0018849544759281464 - rtDW.lastSin_fl
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S418>/cos(wt)' */

  /* Product: '<S418>/Product1' */
  rtb_Product1_aw = rtDW.StateSpace_o1_m[41] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S422>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_en != 0) {
    rtDW.Integ4_bp = rtDW.Integ4_DSTATE_oi0;
  } else {
    rtDW.Integ4_bp = 2.5E-6 * rtb_Product1_aw + rtDW.Integ4_DSTATE_oi0;
  }

  /* End of DiscreteIntegrator: '<S422>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S423>/S-Function' incorporates:
   *  Constant: '<S422>/K1'
   */

  /* Level2 S-Function Block: '<S423>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S422>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S422>/Switch' incorporates:
   *  Constant: '<S422>/K1'
   *  Constant: '<S422>/K2'
   *  Gain: '<S422>/Gain'
   *  Gain: '<S422>/Gain1'
   *  Product: '<S422>/Product'
   *  RelationalOperator: '<S422>/Relational Operator'
   *  Sum: '<S422>/Sum1'
   *  Sum: '<S422>/Sum5'
   *  Sum: '<S422>/Sum7'
   *  UnitDelay: '<S422>/Unit Delay'
   *  UnitDelay: '<S422>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_o = (rtDW.Integ4_bp - rtDW.SFunction_c5r) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_aw - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_cn);
  } else {
    rtb_Switch_o = rtDW.UnitDelay1_DSTATE_kp;
  }

  /* End of Switch: '<S422>/Switch' */

  /* ComplexToMagnitudeAngle: '<S418>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S418>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_ly, rtb_Switch_o);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_o, rtb_Switch_ly);

  /* Sin: '<S419>/sin(wt)' */
  if (rtDW.systemEnable_aq != 0) {
    rtDW.lastSin_p = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fl = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_aq = 0;
  }

  /* Product: '<S419>/Product' incorporates:
   *  Sin: '<S419>/sin(wt)'
   */
  rtb_Product_h4 = ((rtDW.lastSin_p * 0.99999822347173384 + rtDW.lastCos_fl *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_fl * 0.99999822347173384 - rtDW.lastSin_p *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[68];

  /* DiscreteIntegrator: '<S430>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_a3 != 0) {
    rtDW.Integ4_n = rtDW.Integ4_DSTATE_io;
  } else {
    rtDW.Integ4_n = 2.5E-6 * rtb_Product_h4 + rtDW.Integ4_DSTATE_io;
  }

  /* End of DiscreteIntegrator: '<S430>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S431>/S-Function' incorporates:
   *  Constant: '<S430>/K1'
   */

  /* Level2 S-Function Block: '<S431>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S430>/Switch' incorporates:
   *  Constant: '<S430>/K1'
   *  Constant: '<S430>/K2'
   *  DigitalClock: '<S430>/Digital  Clock'
   *  Gain: '<S430>/Gain'
   *  Gain: '<S430>/Gain1'
   *  Product: '<S430>/Product'
   *  RelationalOperator: '<S430>/Relational Operator'
   *  Sum: '<S430>/Sum1'
   *  Sum: '<S430>/Sum5'
   *  Sum: '<S430>/Sum7'
   *  UnitDelay: '<S430>/Unit Delay'
   *  UnitDelay: '<S430>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_of = (rtDW.Integ4_n - rtDW.SFunction_h1) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_h4 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_j);
  } else {
    rtb_Switch_of = rtDW.UnitDelay1_DSTATE_lz;
  }

  /* End of Switch: '<S430>/Switch' */

  /* Sin: '<S419>/cos(wt)' */
  if (rtDW.systemEnable_ac != 0) {
    rtDW.lastSin_e1 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h5 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ac = 0;
  }

  /* Product: '<S419>/Product1' incorporates:
   *  Sin: '<S419>/cos(wt)'
   */
  rtb_Product1_iv = ((rtDW.lastSin_e1 * 0.0018849544759281464 + rtDW.lastCos_h5 *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_h5 * 0.0018849544759281464 - rtDW.lastSin_e1 *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[68];

  /* DiscreteIntegrator: '<S428>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_kb != 0) {
    rtDW.Integ4_o = rtDW.Integ4_DSTATE_hw;
  } else {
    rtDW.Integ4_o = 2.5E-6 * rtb_Product1_iv + rtDW.Integ4_DSTATE_hw;
  }

  /* End of DiscreteIntegrator: '<S428>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S429>/S-Function' incorporates:
   *  Constant: '<S428>/K1'
   */

  /* Level2 S-Function Block: '<S429>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnOutputs(rts,0);
  }

  /* Switch: '<S428>/Switch' incorporates:
   *  Constant: '<S428>/K1'
   *  Constant: '<S428>/K2'
   *  DigitalClock: '<S428>/Digital  Clock'
   *  Gain: '<S428>/Gain'
   *  Gain: '<S428>/Gain1'
   *  Product: '<S428>/Product'
   *  RelationalOperator: '<S428>/Relational Operator'
   *  Sum: '<S428>/Sum1'
   *  Sum: '<S428>/Sum5'
   *  Sum: '<S428>/Sum7'
   *  UnitDelay: '<S428>/Unit Delay'
   *  UnitDelay: '<S428>/Unit Delay1'
   */
  if (rtM->Timing.t[0] >= 0.01667) {
    rtb_Switch_eu = (rtDW.Integ4_o - rtDW.SFunction_j) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_iv - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_hl);
  } else {
    rtb_Switch_eu = rtDW.UnitDelay1_DSTATE_iq;
  }

  /* End of Switch: '<S428>/Switch' */

  /* Gain: '<S20>/Gain1' incorporates:
   *  ComplexToMagnitudeAngle: '<S419>/Complex to Magnitude-Angle'
   *  Product: '<S20>/Product'
   *  RealImagToComplex: '<S419>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rtb_UnitDelay6_e * rt_hypotd_snf(rtb_Switch_of,
    rtb_Switch_eu) * 0.5;

  /* Gain: '<S20>/Deg->Rad' incorporates:
   *  ComplexToMagnitudeAngle: '<S419>/Complex to Magnitude-Angle'
   *  Gain: '<S418>/Rad->Deg.'
   *  Gain: '<S419>/Rad->Deg.'
   *  RealImagToComplex: '<S419>/Real-Imag to Complex'
   *  Sum: '<S20>/Sum'
   */
  rtb_phi_b = (57.295779513082323 * rtb_UnitDelay7_b - 57.295779513082323 *
               rt_atan2d_snf(rtb_Switch_eu, rtb_Switch_of)) *
    0.017453292519943295;

  /* Outport: '<Root>/Out6' incorporates:
   *  Product: '<S20>/Product1'
   *  Trigonometry: '<S20>/Trigonometric Function2'
   */
  rtY.PHB = rtb_UnitDelay6_e * cos(rtb_phi_b);

  /* Outport: '<Root>/Out8' */
  rtY.VHB = rtDW.StateSpace_o1_m[41];

  /* Outport: '<Root>/Out9' */
  rtY.IHB = rtDW.StateSpace_o1_m[68];

  /* Outport: '<Root>/Out10' incorporates:
   *  Product: '<S20>/Product3'
   *  Trigonometry: '<S20>/Trigonometric Function2'
   */
  rtY.QHB = rtb_UnitDelay6_e * sin(rtb_phi_b);

  /* Sin: '<S484>/sin(wt)' */
  if (rtDW.systemEnable_j != 0) {
    rtDW.lastSin_am = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ny = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_j = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_am * 0.99999822347173384 + rtDW.lastCos_ny *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_ny * 0.99999822347173384 - rtDW.lastSin_am *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S484>/sin(wt)' */

  /* Product: '<S484>/Product' */
  rtb_phi_b = rtDW.StateSpace_o1_m[24] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S494>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_cl != 0) {
    rtDW.Integ4_mta = rtDW.Integ4_DSTATE_nf;
  } else {
    rtDW.Integ4_mta = 2.5E-6 * rtb_phi_b + rtDW.Integ4_DSTATE_nf;
  }

  /* End of DiscreteIntegrator: '<S494>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */

  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S494>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S494>/Switch' incorporates:
   *  Constant: '<S494>/K1'
   *  Constant: '<S494>/K2'
   *  Gain: '<S494>/Gain'
   *  Gain: '<S494>/Gain1'
   *  Product: '<S494>/Product'
   *  RelationalOperator: '<S494>/Relational Operator'
   *  Sum: '<S494>/Sum1'
   *  Sum: '<S494>/Sum5'
   *  Sum: '<S494>/Sum7'
   *  UnitDelay: '<S494>/Unit Delay'
   *  UnitDelay: '<S494>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_e = (rtDW.Integ4_mta - rtDW.SFunction_i) * 60.0 +
      (-0.00013333333333336367 * rtb_phi_b - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_hw);
  } else {
    rtb_Switch_e = rtDW.UnitDelay1_DSTATE_gx;
  }

  /* End of Switch: '<S494>/Switch' */

  /* Sin: '<S484>/cos(wt)' */
  if (rtDW.systemEnable_gz != 0) {
    rtDW.lastSin_jo = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_on = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_gz = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_jo * 0.0018849544759281464 + rtDW.lastCos_on
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_on * 0.0018849544759281464 - rtDW.lastSin_jo
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S484>/cos(wt)' */

  /* Product: '<S484>/Product1' */
  rtb_Product1_fg = rtDW.StateSpace_o1_m[24] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S492>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i2 != 0) {
    rtDW.Integ4_oc = rtDW.Integ4_DSTATE_j5;
  } else {
    rtDW.Integ4_oc = 2.5E-6 * rtb_Product1_fg + rtDW.Integ4_DSTATE_j5;
  }

  /* End of DiscreteIntegrator: '<S492>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */

  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S492>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S492>/Switch' incorporates:
   *  Constant: '<S492>/K1'
   *  Constant: '<S492>/K2'
   *  Gain: '<S492>/Gain'
   *  Gain: '<S492>/Gain1'
   *  Product: '<S492>/Product'
   *  RelationalOperator: '<S492>/Relational Operator'
   *  Sum: '<S492>/Sum1'
   *  Sum: '<S492>/Sum5'
   *  Sum: '<S492>/Sum7'
   *  UnitDelay: '<S492>/Unit Delay'
   *  UnitDelay: '<S492>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_ec = (rtDW.Integ4_oc - rtDW.SFunction_ge) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_fg - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ai);
  } else {
    rtb_Switch_ec = rtDW.UnitDelay1_DSTATE_di;
  }

  /* End of Switch: '<S492>/Switch' */

  /* ComplexToMagnitudeAngle: '<S484>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S484>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_e, rtb_Switch_ec);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_ec, rtb_Switch_e);

  /* Gain: '<S482>/deg->rad' incorporates:
   *  Gain: '<S484>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S482>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S485>/sin(wt)' */
  if (rtDW.systemEnable_lb != 0) {
    rtDW.lastSin_pp = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ob = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_lb = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_pp * 0.99999822347173384 + rtDW.lastCos_ob *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_ob * 0.99999822347173384 - rtDW.lastSin_pp *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S485>/sin(wt)' */

  /* Product: '<S485>/Product' */
  rtb_Product_aa = rtDW.StateSpace_o1_m[25] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S500>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bc != 0) {
    rtDW.Integ4_do = rtDW.Integ4_DSTATE_a;
  } else {
    rtDW.Integ4_do = 2.5E-6 * rtb_Product_aa + rtDW.Integ4_DSTATE_a;
  }

  /* End of DiscreteIntegrator: '<S500>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */

  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S500>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S500>/Switch' incorporates:
   *  Constant: '<S500>/K1'
   *  Constant: '<S500>/K2'
   *  Gain: '<S500>/Gain'
   *  Gain: '<S500>/Gain1'
   *  Product: '<S500>/Product'
   *  RelationalOperator: '<S500>/Relational Operator'
   *  Sum: '<S500>/Sum1'
   *  Sum: '<S500>/Sum5'
   *  Sum: '<S500>/Sum7'
   *  UnitDelay: '<S500>/Unit Delay'
   *  UnitDelay: '<S500>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_nl = (rtDW.Integ4_do - rtDW.SFunction_jm) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_aa - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_lw);
  } else {
    rtb_Switch_nl = rtDW.UnitDelay1_DSTATE_m5;
  }

  /* End of Switch: '<S500>/Switch' */

  /* Sin: '<S485>/cos(wt)' */
  if (rtDW.systemEnable_i != 0) {
    rtDW.lastSin_i = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_b = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_i = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_i * 0.0018849544759281464 + rtDW.lastCos_b *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_b * 0.0018849544759281464 - rtDW.lastSin_i *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S485>/cos(wt)' */

  /* Product: '<S485>/Product1' */
  rtb_Product1_if = rtDW.StateSpace_o1_m[25] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S498>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gs != 0) {
    rtDW.Integ4_nk = rtDW.Integ4_DSTATE_k;
  } else {
    rtDW.Integ4_nk = 2.5E-6 * rtb_Product1_if + rtDW.Integ4_DSTATE_k;
  }

  /* End of DiscreteIntegrator: '<S498>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */

  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S498>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S498>/Switch' incorporates:
   *  Constant: '<S498>/K1'
   *  Constant: '<S498>/K2'
   *  Gain: '<S498>/Gain'
   *  Gain: '<S498>/Gain1'
   *  Product: '<S498>/Product'
   *  RelationalOperator: '<S498>/Relational Operator'
   *  Sum: '<S498>/Sum1'
   *  Sum: '<S498>/Sum5'
   *  Sum: '<S498>/Sum7'
   *  UnitDelay: '<S498>/Unit Delay'
   *  UnitDelay: '<S498>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_h = (rtDW.Integ4_nk - rtDW.SFunction_et) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_if - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_ei);
  } else {
    rtb_Switch_h = rtDW.UnitDelay1_DSTATE_by;
  }

  /* End of Switch: '<S498>/Switch' */

  /* ComplexToMagnitudeAngle: '<S485>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S485>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_nl, rtb_Switch_h);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_h, rtb_Switch_nl);

  /* Gain: '<S482>/deg->rad1' incorporates:
   *  Gain: '<S485>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S482>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S486>/sin(wt)' */
  if (rtDW.systemEnable_bk != 0) {
    rtDW.lastSin_hb = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_i4 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bk = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_hb * 0.99999822347173384 + rtDW.lastCos_i4 *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_i4 * 0.99999822347173384 - rtDW.lastSin_hb *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S486>/sin(wt)' */

  /* Product: '<S486>/Product' */
  rtb_Product_p = rtDW.StateSpace_o1_m[26] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S506>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jz != 0) {
    rtDW.Integ4_pl = rtDW.Integ4_DSTATE_kd;
  } else {
    rtDW.Integ4_pl = 2.5E-6 * rtb_Product_p + rtDW.Integ4_DSTATE_kd;
  }

  /* End of DiscreteIntegrator: '<S506>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S507>/S-Function' incorporates:
   *  Constant: '<S506>/K1'
   */

  /* Level2 S-Function Block: '<S507>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S506>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S506>/Switch' incorporates:
   *  Constant: '<S506>/K1'
   *  Constant: '<S506>/K2'
   *  Gain: '<S506>/Gain'
   *  Gain: '<S506>/Gain1'
   *  Product: '<S506>/Product'
   *  RelationalOperator: '<S506>/Relational Operator'
   *  Sum: '<S506>/Sum1'
   *  Sum: '<S506>/Sum5'
   *  Sum: '<S506>/Sum7'
   *  UnitDelay: '<S506>/Unit Delay'
   *  UnitDelay: '<S506>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_on = (rtDW.Integ4_pl - rtDW.SFunction_ko) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_p - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_jz);
  } else {
    rtb_Switch_on = rtDW.UnitDelay1_DSTATE_a1;
  }

  /* End of Switch: '<S506>/Switch' */

  /* Sin: '<S486>/cos(wt)' */
  if (rtDW.systemEnable_oz != 0) {
    rtDW.lastSin_fw = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_p = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_oz = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_fw * 0.0018849544759281464 + rtDW.lastCos_p *
                       0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_p * 0.0018849544759281464 - rtDW.lastSin_fw *
                       0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S486>/cos(wt)' */

  /* Product: '<S486>/Product1' */
  rtb_Product1_b4 = rtDW.StateSpace_o1_m[26] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S504>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bm != 0) {
    rtDW.Integ4_nkx = rtDW.Integ4_DSTATE_me;
  } else {
    rtDW.Integ4_nkx = 2.5E-6 * rtb_Product1_b4 + rtDW.Integ4_DSTATE_me;
  }

  /* End of DiscreteIntegrator: '<S504>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S505>/S-Function' incorporates:
   *  Constant: '<S504>/K1'
   */

  /* Level2 S-Function Block: '<S505>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S504>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S504>/Switch' incorporates:
   *  Constant: '<S504>/K1'
   *  Constant: '<S504>/K2'
   *  Gain: '<S504>/Gain'
   *  Gain: '<S504>/Gain1'
   *  Product: '<S504>/Product'
   *  RelationalOperator: '<S504>/Relational Operator'
   *  Sum: '<S504>/Sum1'
   *  Sum: '<S504>/Sum5'
   *  Sum: '<S504>/Sum7'
   *  UnitDelay: '<S504>/Unit Delay'
   *  UnitDelay: '<S504>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_m = (rtDW.Integ4_nkx - rtDW.SFunction_ey) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_b4 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_b2);
  } else {
    rtb_Switch_m = rtDW.UnitDelay1_DSTATE_ea;
  }

  /* End of Switch: '<S504>/Switch' */

  /* ComplexToMagnitudeAngle: '<S486>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S486>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_on, rtb_Switch_m);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_m, rtb_Switch_on);

  /* Gain: '<S482>/deg->rad2' incorporates:
   *  Gain: '<S486>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S482>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Outputs for Enabled SubSystem: '<S482>/Pos. Seq. Computation' */
  /* Constant: '<S482>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_en);

  /* End of Outputs for SubSystem: '<S482>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S482>/Neg. Seq. Computation' */
  /* Constant: '<S482>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_l);

  /* End of Outputs for SubSystem: '<S482>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S482>/Zero Seq. Computation' */
  /* Constant: '<S482>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &rtDW.Gain3_o);

  /* End of Outputs for SubSystem: '<S482>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S482>/Complex to Magnitude-Angle' */
  rtb_UnitDelay1_d[0] = rt_hypotd_snf(rtDW.Gain3_en.re, rtDW.Gain3_en.im);
  rtb_UnitDelay4_h[0] = rt_atan2d_snf(rtDW.Gain3_en.im, rtDW.Gain3_en.re);

  /* Sin: '<S508>/sin(wt)' */
  if (rtDW.systemEnable_cd != 0) {
    rtDW.lastSin_dz = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_b4 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_cd = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_dz * 0.99999822347173384 + rtDW.lastCos_b4 *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_b4 * 0.99999822347173384 - rtDW.lastSin_dz *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S508>/sin(wt)' */

  /* Product: '<S508>/Product' */
  rtb_Product_bo = rtDW.StateSpace_o1_m[57] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S518>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ke != 0) {
    rtDW.Integ4_mr = rtDW.Integ4_DSTATE_ip;
  } else {
    rtDW.Integ4_mr = 2.5E-6 * rtb_Product_bo + rtDW.Integ4_DSTATE_ip;
  }

  /* End of DiscreteIntegrator: '<S518>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S519>/S-Function' incorporates:
   *  Constant: '<S518>/K1'
   */

  /* Level2 S-Function Block: '<S519>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S518>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S518>/Switch' incorporates:
   *  Constant: '<S518>/K1'
   *  Constant: '<S518>/K2'
   *  Gain: '<S518>/Gain'
   *  Gain: '<S518>/Gain1'
   *  Product: '<S518>/Product'
   *  RelationalOperator: '<S518>/Relational Operator'
   *  Sum: '<S518>/Sum1'
   *  Sum: '<S518>/Sum5'
   *  Sum: '<S518>/Sum7'
   *  UnitDelay: '<S518>/Unit Delay'
   *  UnitDelay: '<S518>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_fc = (rtDW.Integ4_mr - rtDW.SFunction_iz) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_bo - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_fp);
  } else {
    rtb_Switch_fc = rtDW.UnitDelay1_DSTATE_ma;
  }

  /* End of Switch: '<S518>/Switch' */

  /* Sin: '<S508>/cos(wt)' */
  if (rtDW.systemEnable_jg != 0) {
    rtDW.lastSin_jd = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ih = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_jg = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_jd * 0.0018849544759281464 + rtDW.lastCos_ih
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_ih * 0.0018849544759281464 - rtDW.lastSin_jd
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S508>/cos(wt)' */

  /* Product: '<S508>/Product1' */
  rtb_Product1_c5 = rtDW.StateSpace_o1_m[57] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S516>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_oh != 0) {
    rtDW.Integ4_dg = rtDW.Integ4_DSTATE_dq;
  } else {
    rtDW.Integ4_dg = 2.5E-6 * rtb_Product1_c5 + rtDW.Integ4_DSTATE_dq;
  }

  /* End of DiscreteIntegrator: '<S516>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */

  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S516>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S516>/Switch' incorporates:
   *  Constant: '<S516>/K1'
   *  Constant: '<S516>/K2'
   *  Gain: '<S516>/Gain'
   *  Gain: '<S516>/Gain1'
   *  Product: '<S516>/Product'
   *  RelationalOperator: '<S516>/Relational Operator'
   *  Sum: '<S516>/Sum1'
   *  Sum: '<S516>/Sum5'
   *  Sum: '<S516>/Sum7'
   *  UnitDelay: '<S516>/Unit Delay'
   *  UnitDelay: '<S516>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_id = (rtDW.Integ4_dg - rtDW.SFunction_ff) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_c5 - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_gf);
  } else {
    rtb_Switch_id = rtDW.UnitDelay1_DSTATE_e2;
  }

  /* End of Switch: '<S516>/Switch' */

  /* ComplexToMagnitudeAngle: '<S508>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S508>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_fc, rtb_Switch_id);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_id, rtb_Switch_fc);

  /* Gain: '<S483>/deg->rad' incorporates:
   *  Gain: '<S508>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S483>/Magnitude-Angle to Complex' */
  rtb_MagnitudeAngletoComplex.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S509>/sin(wt)' */
  if (rtDW.systemEnable_av != 0) {
    rtDW.lastSin_nj = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_hr = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_av = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_nj * 0.99999822347173384 + rtDW.lastCos_hr *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_hr * 0.99999822347173384 - rtDW.lastSin_nj *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S509>/sin(wt)' */

  /* Product: '<S509>/Product' */
  rtb_Product_i = rtDW.StateSpace_o1_m[58] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S524>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_lx != 0) {
    rtDW.Integ4_e = rtDW.Integ4_DSTATE_le;
  } else {
    rtDW.Integ4_e = 2.5E-6 * rtb_Product_i + rtDW.Integ4_DSTATE_le;
  }

  /* End of DiscreteIntegrator: '<S524>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */

  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S524>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S524>/Switch' incorporates:
   *  Constant: '<S524>/K1'
   *  Constant: '<S524>/K2'
   *  Gain: '<S524>/Gain'
   *  Gain: '<S524>/Gain1'
   *  Product: '<S524>/Product'
   *  RelationalOperator: '<S524>/Relational Operator'
   *  Sum: '<S524>/Sum1'
   *  Sum: '<S524>/Sum5'
   *  Sum: '<S524>/Sum7'
   *  UnitDelay: '<S524>/Unit Delay'
   *  UnitDelay: '<S524>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_lq = (rtDW.Integ4_e - rtDW.SFunction_b) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_i - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_d);
  } else {
    rtb_Switch_lq = rtDW.UnitDelay1_DSTATE_gb;
  }

  /* End of Switch: '<S524>/Switch' */

  /* Sin: '<S509>/cos(wt)' */
  if (rtDW.systemEnable_oh != 0) {
    rtDW.lastSin_o2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_dm = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_oh = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_o2 * 0.0018849544759281464 + rtDW.lastCos_dm
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_dm * 0.0018849544759281464 - rtDW.lastSin_o2
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S509>/cos(wt)' */

  /* Product: '<S509>/Product1' */
  rtb_Product1_ol = rtDW.StateSpace_o1_m[58] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S522>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_of != 0) {
    rtDW.Integ4_g4 = rtDW.Integ4_DSTATE_ox;
  } else {
    rtDW.Integ4_g4 = 2.5E-6 * rtb_Product1_ol + rtDW.Integ4_DSTATE_ox;
  }

  /* End of DiscreteIntegrator: '<S522>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */

  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S522>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S522>/Switch' incorporates:
   *  Constant: '<S522>/K1'
   *  Constant: '<S522>/K2'
   *  Gain: '<S522>/Gain'
   *  Gain: '<S522>/Gain1'
   *  Product: '<S522>/Product'
   *  RelationalOperator: '<S522>/Relational Operator'
   *  Sum: '<S522>/Sum1'
   *  Sum: '<S522>/Sum5'
   *  Sum: '<S522>/Sum7'
   *  UnitDelay: '<S522>/Unit Delay'
   *  UnitDelay: '<S522>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_p0 = (rtDW.Integ4_g4 - rtDW.SFunction_gv) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_ol - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_hz);
  } else {
    rtb_Switch_p0 = rtDW.UnitDelay1_DSTATE_dz;
  }

  /* End of Switch: '<S522>/Switch' */

  /* ComplexToMagnitudeAngle: '<S509>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S509>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_lq, rtb_Switch_p0);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_p0, rtb_Switch_lq);

  /* Gain: '<S483>/deg->rad1' incorporates:
   *  Gain: '<S509>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S483>/Magnitude-Angle to Complex1' */
  rtb_MagnitudeAngletoComplex1.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_MagnitudeAngletoComplex1.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Sin: '<S510>/sin(wt)' */
  if (rtDW.systemEnable_bn != 0) {
    rtDW.lastSin_e2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_m = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bn = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_e2 * 0.99999822347173384 + rtDW.lastCos_m *
                       -0.0018849544759281136) * 0.99999822347173384 +
                      (rtDW.lastCos_m * 0.99999822347173384 - rtDW.lastSin_e2 *
                       -0.0018849544759281136) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S510>/sin(wt)' */

  /* Product: '<S510>/Product' */
  rtb_Product_lv = rtDW.StateSpace_o1_m[59] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S530>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_p != 0) {
    rtDW.Integ4_ao = rtDW.Integ4_DSTATE_gb;
  } else {
    rtDW.Integ4_ao = 2.5E-6 * rtb_Product_lv + rtDW.Integ4_DSTATE_gb;
  }

  /* End of DiscreteIntegrator: '<S530>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */

  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S530>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S530>/Switch' incorporates:
   *  Constant: '<S530>/K1'
   *  Constant: '<S530>/K2'
   *  Gain: '<S530>/Gain'
   *  Gain: '<S530>/Gain1'
   *  Product: '<S530>/Product'
   *  RelationalOperator: '<S530>/Relational Operator'
   *  Sum: '<S530>/Sum1'
   *  Sum: '<S530>/Sum5'
   *  Sum: '<S530>/Sum7'
   *  UnitDelay: '<S530>/Unit Delay'
   *  UnitDelay: '<S530>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_k = (rtDW.Integ4_ao - rtDW.SFunction_l5) * 60.0 +
      (-0.00013333333333336367 * rtb_Product_lv - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_cm);
  } else {
    rtb_Switch_k = rtDW.UnitDelay1_DSTATE_jz;
  }

  /* End of Switch: '<S530>/Switch' */

  /* Sin: '<S510>/cos(wt)' */
  if (rtDW.systemEnable_na != 0) {
    rtDW.lastSin_dm = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ie = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_na = 0;
  }

  rtb_UnitDelay6_e = ((rtDW.lastSin_dm * 0.0018849544759281464 + rtDW.lastCos_ie
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_ie * 0.0018849544759281464 - rtDW.lastSin_dm
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0;

  /* End of Sin: '<S510>/cos(wt)' */

  /* Product: '<S510>/Product1' */
  rtb_Product1_jq = rtDW.StateSpace_o1_m[59] * rtb_UnitDelay6_e;

  /* DiscreteIntegrator: '<S528>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_on != 0) {
    rtDW.Integ4_mk = rtDW.Integ4_DSTATE_ia;
  } else {
    rtDW.Integ4_mk = 2.5E-6 * rtb_Product1_jq + rtDW.Integ4_DSTATE_ia;
  }

  /* End of DiscreteIntegrator: '<S528>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */

  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnOutputs(rts,0);
  }

  /* DigitalClock: '<S528>/Digital  Clock' */
  rtb_UnitDelay6_e = rtM->Timing.t[0];

  /* Switch: '<S528>/Switch' incorporates:
   *  Constant: '<S528>/K1'
   *  Constant: '<S528>/K2'
   *  Gain: '<S528>/Gain'
   *  Gain: '<S528>/Gain1'
   *  Product: '<S528>/Product'
   *  RelationalOperator: '<S528>/Relational Operator'
   *  Sum: '<S528>/Sum1'
   *  Sum: '<S528>/Sum5'
   *  Sum: '<S528>/Sum7'
   *  UnitDelay: '<S528>/Unit Delay'
   *  UnitDelay: '<S528>/Unit Delay1'
   */
  if (rtb_UnitDelay6_e >= 0.01667) {
    rtb_Switch_kp = (rtDW.Integ4_mk - rtDW.SFunction_gy) * 60.0 +
      (-0.00013333333333336367 * rtb_Product1_jq - 6.66666666667273E-5 *
       rtDW.UnitDelay_DSTATE_lx);
  } else {
    rtb_Switch_kp = rtDW.UnitDelay1_DSTATE_pq;
  }

  /* End of Switch: '<S528>/Switch' */

  /* ComplexToMagnitudeAngle: '<S510>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S510>/Real-Imag to Complex'
   */
  rtb_UnitDelay6_e = rt_hypotd_snf(rtb_Switch_k, rtb_Switch_kp);
  rtb_UnitDelay7_b = rt_atan2d_snf(rtb_Switch_kp, rtb_Switch_k);

  /* Gain: '<S483>/deg->rad2' incorporates:
   *  Gain: '<S510>/Rad->Deg.'
   */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay7_b *
    0.017453292519943295;

  /* MagnitudeAngleToComplex: '<S483>/Magnitude-Angle to Complex2' */
  rtb_RealImagtoComplex_l.re = rtb_UnitDelay6_e * cos(rtb_UnitDelay7_b);
  rtb_RealImagtoComplex_l.im = rtb_UnitDelay6_e * sin(rtb_UnitDelay7_b);

  /* Outputs for Enabled SubSystem: '<S483>/Pos. Seq. Computation' */
  /* Constant: '<S483>/Constant' */
  PosSeqComputation(1.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_f);

  /* End of Outputs for SubSystem: '<S483>/Pos. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S483>/Neg. Seq. Computation' */
  /* Constant: '<S483>/Constant1' */
  NegSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                    rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                    &rtDW.Gain3_kl);

  /* End of Outputs for SubSystem: '<S483>/Neg. Seq. Computation' */

  /* Outputs for Enabled SubSystem: '<S483>/Zero Seq. Computation' */
  /* Constant: '<S483>/Constant2' */
  ZeroSeqComputation(0.0, rtb_MagnitudeAngletoComplex,
                     rtb_MagnitudeAngletoComplex1, rtb_RealImagtoComplex_l,
                     &rtDW.Gain3_k);

  /* End of Outputs for SubSystem: '<S483>/Zero Seq. Computation' */

  /* ComplexToMagnitudeAngle: '<S483>/Complex to Magnitude-Angle' */
  rtb_UnitDelay3[0] = rt_hypotd_snf(rtDW.Gain3_f.re, rtDW.Gain3_f.im);
  rtb_UnitDelay_ai[0] = rt_atan2d_snf(rtDW.Gain3_f.im, rtDW.Gain3_f.re);

  /* Product: '<S22>/Product' */
  rtb_UnitDelay6_e = rtb_UnitDelay1_d[0] * rtb_UnitDelay3[0];

  /* Gain: '<S22>/Gain1' */
  rtb_UnitDelay6_e *= 1.5;

  /* Gain: '<S482>/rad->deg1' */
  rtb_UnitDelay7_b = 57.295779513082323 * rtb_UnitDelay4_h[0];

  /* Gain: '<S22>/Deg->Rad' incorporates:
   *  Gain: '<S483>/rad->deg1'
   *  Sum: '<S22>/Sum'
   */
  rtb_phi_f = (rtb_UnitDelay7_b - 57.295779513082323 * rtb_UnitDelay_ai[0]) *
    0.017453292519943295;

  /* Product: '<S22>/Product1' incorporates:
   *  Trigonometry: '<S22>/Trigonometric Function2'
   */
  rtb_UnitDelay7_b = rtb_UnitDelay6_e * cos(rtb_phi_f);

  /* Product: '<S22>/Product3' incorporates:
   *  Trigonometry: '<S22>/Trigonometric Function2'
   */
  rtb_UnitDelay6_e *= sin(rtb_phi_f);

  /* Outport: '<Root>/Out7' */
  rtY.PQstat[0] = rtb_UnitDelay7_b;
  rtY.PQstat[1] = rtb_UnitDelay6_e;

  /* Outport: '<Root>/Out30' */
  rtY.Vstat[0] = rtDW.StateSpace_o1_m[24];

  /* Outport: '<Root>/Out31' */
  rtY.Istat[0] = rtDW.StateSpace_o1_m[57];

  /* Outport: '<Root>/Out30' */
  rtY.Vstat[1] = rtDW.StateSpace_o1_m[25];

  /* Outport: '<Root>/Out31' */
  rtY.Istat[1] = rtDW.StateSpace_o1_m[58];

  /* Outport: '<Root>/Out30' */
  rtY.Vstat[2] = rtDW.StateSpace_o1_m[26];

  /* Outport: '<Root>/Out31' */
  rtY.Istat[2] = rtDW.StateSpace_o1_m[59];

  /* UnitDelay: '<S5>/Unit Delay2' */
  rtb_phi_f = rtDW.UnitDelay2_DSTATE;

  /* RateTransition: '<S83>/Rate Transition5' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition5_Buffer = rtb_phi_f;
  }

  /* End of RateTransition: '<S83>/Rate Transition5' */

  /* UnitDelay: '<S5>/Unit Delay1' */
  rtb_UnitDelay1_d[0] = rtDW.UnitDelay1_DSTATE_o0[0];
  rtb_UnitDelay1_d[1] = rtDW.UnitDelay1_DSTATE_o0[1];
  rtb_UnitDelay1_d[2] = rtDW.UnitDelay1_DSTATE_o0[2];

  /* RateTransition: '<S83>/Rate Transition6' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition6_Buffer[0] = rtb_UnitDelay1_d[0];
    rtDW.RateTransition6_Buffer[1] = rtb_UnitDelay1_d[1];
    rtDW.RateTransition6_Buffer[2] = rtb_UnitDelay1_d[2];

    /* RateTransition: '<S83>/Rate Transition1' */
    rtDW.RateTransition1_Buffer[0] = rtb_Product1_eq[0];
    rtDW.RateTransition1_Buffer[1] = rtb_Product1_eq[1];
    rtDW.RateTransition1_Buffer[2] = rtb_Product1_eq[2];
  }

  /* End of RateTransition: '<S83>/Rate Transition6' */

  /* Outport: '<Root>/Out14' */
  rtY.Vsec_3L_LLA = rtDW.StateSpace_o1_m[27];

  /* Outport: '<Root>/Out15' */
  rtY.Vsec_3L_LLB = rtDW.StateSpace_o1_m[28];

  /* Outport: '<Root>/Out16' */
  rtY.Vsec_3L_LLC = rtDW.StateSpace_o1_m[29];

  /* Sum: '<S10>/Add' */
  rtb_Add = rtDW.StateSpace_o1_m[37] + rtDW.StateSpace_o1_m[38];

  /* Outport: '<Root>/Out17' */
  rtY.Vdc_3L = rtb_Add;

  /* Outport: '<Root>/Out18' */
  rtY.VdcP_3L = rtDW.StateSpace_o1_m[37];

  /* Outport: '<Root>/Out19' */
  rtY.VdcM_3L = rtDW.StateSpace_o1_m[38];

  /* UnitDelay: '<S5>/Unit Delay5' */
  rtb_UnitDelay5_ax = rtDW.UnitDelay5_DSTATE_a;

  /* RateTransition: '<S84>/Rate Transition5' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition5_Buffer_a = rtb_UnitDelay5_ax;
  }

  /* End of RateTransition: '<S84>/Rate Transition5' */

  /* UnitDelay: '<S5>/Unit Delay4' */
  rtb_UnitDelay4_h[0] = rtDW.UnitDelay4_DSTATE_i[0];
  rtb_UnitDelay4_h[1] = rtDW.UnitDelay4_DSTATE_i[1];
  rtb_UnitDelay4_h[2] = rtDW.UnitDelay4_DSTATE_i[2];

  /* RateTransition: '<S84>/Rate Transition6' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition6_Buffer_d[0] = rtb_UnitDelay4_h[0];
    rtDW.RateTransition6_Buffer_d[1] = rtb_UnitDelay4_h[1];
    rtDW.RateTransition6_Buffer_d[2] = rtb_UnitDelay4_h[2];

    /* RateTransition: '<S84>/Rate Transition1' */
    rtDW.RateTransition1_Buffer_n[0] = rtb_Product1_fq[0];
    rtDW.RateTransition1_Buffer_n[1] = rtb_Product1_fq[1];
    rtDW.RateTransition1_Buffer_n[2] = rtb_Product1_fq[2];
  }

  /* End of RateTransition: '<S84>/Rate Transition6' */

  /* Outport: '<Root>/Out29' */
  rtY.Vdc_stat = rtDW.StateSpace_o1_m[39];

  /* UnitDelay: '<S5>/Unit Delay6' */
  rtb_UnitDelay6_e = rtDW.UnitDelay6_DSTATE_o2;

  /* RateTransition: '<S75>/Rate Transition1' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition1_Buffer_b = rtb_UnitDelay6_e;

    /* RateTransition: '<Root>/Rate Transition1' */
    rtDW.RateTransition1_Buffer_p = rtDW.StateSpace_o1_m[76];

    /* RateTransition: '<Root>/Rate Transition2' */
    rtDW.RateTransition2_Buffer = rtDW.RateTransition2;
  }

  /* End of RateTransition: '<S75>/Rate Transition1' */

  /* Gain: '<S5>/Rad2Rpm1' incorporates:
   *  DiscreteIntegrator: '<S346>/Discrete-Time Integrator'
   */
  rtb_UnitDelay6_e = 9.5492965855137211 * rtDW.DiscreteTimeIntegrator_DSTATE;

  /* Outport: '<Root>/Out36' */
  rtY.w_motor = rtb_UnitDelay6_e;

  /* UnitDelay: '<S5>/Unit Delay3' */
  rtb_UnitDelay3[0] = rtDW.UnitDelay3_DSTATE[0];
  rtb_UnitDelay3[1] = rtDW.UnitDelay3_DSTATE[1];
  rtb_UnitDelay3[2] = rtDW.UnitDelay3_DSTATE[2];

  /* RateTransition: '<S84>/Rate Transition2' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition2_Buffer_g[0] = rtb_UnitDelay3[0];
    rtDW.RateTransition2_Buffer_g[1] = rtb_UnitDelay3[1];
    rtDW.RateTransition2_Buffer_g[2] = rtb_UnitDelay3[2];
  }

  /* End of RateTransition: '<S84>/Rate Transition2' */

  /* Sum: '<S330>/sum3' incorporates:
   *  Gain: '<S330>/A21'
   *  Gain: '<S330>/A22'
   *  UnitDelay: '<S329>/Delay_x1'
   *  UnitDelay: '<S329>/Delay_x2'
   */
  rtb_sum3_d = -424.07342148553317 * rtDW.Delay_x1_DSTATE_p +
    0.90896529536924042 * rtDW.Delay_x2_DSTATE_c;

  /* Gain: '<S331>/B11' incorporates:
   *  UnitDelay: '<S84>/Unit Delay'
   */
  rtb_B11_h = 2.3862066192115771E-6 * rtDW.UnitDelay_DSTATE_o;

  /* Gain: '<S331>/B21' incorporates:
   *  UnitDelay: '<S84>/Unit Delay'
   */
  rtb_B21_n = 0.95448264768462021 * rtDW.UnitDelay_DSTATE_o;

  /* UnitDelay: '<S5>/Unit Delay7' */
  rtb_UnitDelay7_b = rtDW.UnitDelay7_DSTATE_a;

  /* RateTransition: '<S75>/Rate Transition3' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition3_Buffer = rtb_UnitDelay7_b;
  }

  /* End of RateTransition: '<S75>/Rate Transition3' */

  /* UnitDelay: '<S5>/Unit Delay' */
  rtb_UnitDelay_ai[0] = rtDW.UnitDelay_DSTATE_ds[0];
  rtb_UnitDelay_ai[1] = rtDW.UnitDelay_DSTATE_ds[1];
  rtb_UnitDelay_ai[2] = rtDW.UnitDelay_DSTATE_ds[2];

  /* RateTransition: '<S83>/Rate Transition2' */
  if (rtM->Timing.RateInteraction.TID0_1 == 1) {
    rtDW.RateTransition2_Buffer_i[0] = rtb_UnitDelay_ai[0];
    rtDW.RateTransition2_Buffer_i[1] = rtb_UnitDelay_ai[1];
    rtDW.RateTransition2_Buffer_i[2] = rtb_UnitDelay_ai[2];
  }

  /* End of RateTransition: '<S83>/Rate Transition2' */

  /* Sum: '<S251>/sum3' incorporates:
   *  Gain: '<S251>/A21'
   *  Gain: '<S251>/A22'
   *  UnitDelay: '<S250>/Delay_x1'
   *  UnitDelay: '<S250>/Delay_x2'
   */
  rtb_UnitDelay7_b = -424.07342148553317 * rtDW.Delay_x1_DSTATE +
    0.90896529536924042 * rtDW.Delay_x2_DSTATE;

  /* Gain: '<S252>/B11' incorporates:
   *  UnitDelay: '<S83>/Unit Delay'
   */
  rtb_B11_n = 2.3862066192115771E-6 * rtDW.UnitDelay_DSTATE;

  /* Gain: '<S252>/B21' incorporates:
   *  UnitDelay: '<S83>/Unit Delay'
   */
  rtb_B21_h = 0.95448264768462021 * rtDW.UnitDelay_DSTATE;

  /* Gain: '<S346>/Field-armature mutual inductance' */
  rtb_Fieldarmaturemutualinductan = 2.621 * rtDW.StateSpace;

  /* DiscreteIntegrator: '<S546>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_o3 != 0) {
    rtDW.Integ4_c1 = rtDW.Integ4_DSTATE_oe;
  } else {
    rtDW.Integ4_c1 = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_DSTATE_oe;
  }

  /* End of DiscreteIntegrator: '<S546>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S547>/S-Function' incorporates:
   *  Constant: '<S546>/K1'
   */

  /* Level2 S-Function Block: '<S547>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S614>/cos(wt)' */
  if (rtDW.systemEnable_bz != 0) {
    rtDW.lastSin_g = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ko = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bz = 0;
  }

  /* Product: '<S614>/Product1' incorporates:
   *  Sin: '<S614>/cos(wt)'
   */
  rtb_Product1_hh = ((rtDW.lastSin_g * 0.0018849544759281464 + rtDW.lastCos_ko *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_ko * 0.0018849544759281464 - rtDW.lastSin_g *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[24];

  /* DiscreteIntegrator: '<S622>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_og != 0) {
    rtDW.Integ4_is = rtDW.Integ4_DSTATE_n5;
  } else {
    rtDW.Integ4_is = 2.5E-6 * rtb_Product1_hh + rtDW.Integ4_DSTATE_n5;
  }

  /* End of DiscreteIntegrator: '<S622>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */

  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S614>/sin(wt)' */
  if (rtDW.systemEnable_e5 != 0) {
    rtDW.lastSin_ne = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_n3 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e5 = 0;
  }

  /* Product: '<S614>/Product' incorporates:
   *  Sin: '<S614>/sin(wt)'
   */
  rtb_Product_g = ((rtDW.lastSin_ne * 0.99999822347173384 + rtDW.lastCos_n3 *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_n3 * 0.99999822347173384 - rtDW.lastSin_ne *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[24];

  /* DiscreteIntegrator: '<S624>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gy != 0) {
    rtDW.Integ4_np = rtDW.Integ4_DSTATE_c;
  } else {
    rtDW.Integ4_np = 2.5E-6 * rtb_Product_g + rtDW.Integ4_DSTATE_c;
  }

  /* End of DiscreteIntegrator: '<S624>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */

  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S615>/cos(wt)' */
  if (rtDW.systemEnable_bj != 0) {
    rtDW.lastSin_am5 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gn = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bj = 0;
  }

  /* Product: '<S615>/Product1' incorporates:
   *  Sin: '<S615>/cos(wt)'
   */
  rtb_Product1_m4 = ((rtDW.lastSin_am5 * 0.0018849544759281464 + rtDW.lastCos_gn
                      * 0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_gn * 0.0018849544759281464 - rtDW.lastSin_am5
                      * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[25];

  /* DiscreteIntegrator: '<S628>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_nt != 0) {
    rtDW.Integ4_nw = rtDW.Integ4_DSTATE_cd;
  } else {
    rtDW.Integ4_nw = 2.5E-6 * rtb_Product1_m4 + rtDW.Integ4_DSTATE_cd;
  }

  /* End of DiscreteIntegrator: '<S628>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */

  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S615>/sin(wt)' */
  if (rtDW.systemEnable_dif != 0) {
    rtDW.lastSin_on = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gs = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_dif = 0;
  }

  /* Product: '<S615>/Product' incorporates:
   *  Sin: '<S615>/sin(wt)'
   */
  rtb_Product_h = ((rtDW.lastSin_on * 0.99999822347173384 + rtDW.lastCos_gs *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_gs * 0.99999822347173384 - rtDW.lastSin_on *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[25];

  /* DiscreteIntegrator: '<S630>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ax != 0) {
    rtDW.Integ4_pz = rtDW.Integ4_DSTATE_lz;
  } else {
    rtDW.Integ4_pz = 2.5E-6 * rtb_Product_h + rtDW.Integ4_DSTATE_lz;
  }

  /* End of DiscreteIntegrator: '<S630>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */

  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S616>/cos(wt)' */
  if (rtDW.systemEnable_k != 0) {
    rtDW.lastSin_h5 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_pj = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_k = 0;
  }

  /* Product: '<S616>/Product1' incorporates:
   *  Sin: '<S616>/cos(wt)'
   */
  rtb_Product1_cr = ((rtDW.lastSin_h5 * 0.0018849544759281464 + rtDW.lastCos_pj *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_pj * 0.0018849544759281464 - rtDW.lastSin_h5 *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[26];

  /* DiscreteIntegrator: '<S634>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ob != 0) {
    rtDW.Integ4_i0 = rtDW.Integ4_DSTATE_ne;
  } else {
    rtDW.Integ4_i0 = 2.5E-6 * rtb_Product1_cr + rtDW.Integ4_DSTATE_ne;
  }

  /* End of DiscreteIntegrator: '<S634>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S635>/S-Function' incorporates:
   *  Constant: '<S634>/K1'
   */

  /* Level2 S-Function Block: '<S635>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S616>/sin(wt)' */
  if (rtDW.systemEnable_go != 0) {
    rtDW.lastSin_n1 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ihc = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_go = 0;
  }

  /* Product: '<S616>/Product' incorporates:
   *  Sin: '<S616>/sin(wt)'
   */
  rtb_Product_mv = ((rtDW.lastSin_n1 * 0.99999822347173384 + rtDW.lastCos_ihc *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ihc * 0.99999822347173384 - rtDW.lastSin_n1 *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[26];

  /* DiscreteIntegrator: '<S636>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_pc != 0) {
    rtDW.Integ4_j1 = rtDW.Integ4_DSTATE_df;
  } else {
    rtDW.Integ4_j1 = 2.5E-6 * rtb_Product_mv + rtDW.Integ4_DSTATE_df;
  }

  /* End of DiscreteIntegrator: '<S636>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S637>/S-Function' incorporates:
   *  Constant: '<S636>/K1'
   */

  /* Level2 S-Function Block: '<S637>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S638>/cos(wt)' */
  if (rtDW.systemEnable_fq != 0) {
    rtDW.lastSin_ds = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_k2 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fq = 0;
  }

  /* Product: '<S638>/Product1' incorporates:
   *  Sin: '<S638>/cos(wt)'
   */
  rtb_Product1_ec = ((rtDW.lastSin_ds * 0.0018849544759281464 + rtDW.lastCos_k2 *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_k2 * 0.0018849544759281464 - rtDW.lastSin_ds *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[57];

  /* DiscreteIntegrator: '<S646>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ka != 0) {
    rtDW.Integ4_di = rtDW.Integ4_DSTATE_am;
  } else {
    rtDW.Integ4_di = 2.5E-6 * rtb_Product1_ec + rtDW.Integ4_DSTATE_am;
  }

  /* End of DiscreteIntegrator: '<S646>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */

  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S638>/sin(wt)' */
  if (rtDW.systemEnable_kf != 0) {
    rtDW.lastSin_ft = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_le = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_kf = 0;
  }

  /* Product: '<S638>/Product' incorporates:
   *  Sin: '<S638>/sin(wt)'
   */
  rtb_Product_db = ((rtDW.lastSin_ft * 0.99999822347173384 + rtDW.lastCos_le *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_le * 0.99999822347173384 - rtDW.lastSin_ft *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[57];

  /* DiscreteIntegrator: '<S648>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ft != 0) {
    rtDW.Integ4_dd = rtDW.Integ4_DSTATE_ct;
  } else {
    rtDW.Integ4_dd = 2.5E-6 * rtb_Product_db + rtDW.Integ4_DSTATE_ct;
  }

  /* End of DiscreteIntegrator: '<S648>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */

  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S639>/cos(wt)' */
  if (rtDW.systemEnable_ip != 0) {
    rtDW.lastSin_ik = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gx = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ip = 0;
  }

  /* Product: '<S639>/Product1' incorporates:
   *  Sin: '<S639>/cos(wt)'
   */
  rtb_Product1_lp5 = ((rtDW.lastSin_ik * 0.0018849544759281464 + rtDW.lastCos_gx
                       * 0.99999822347173384) * 0.99999822347173384 +
                      (rtDW.lastCos_gx * 0.0018849544759281464 - rtDW.lastSin_ik
                       * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[58];

  /* DiscreteIntegrator: '<S652>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_js != 0) {
    rtDW.Integ4_a3 = rtDW.Integ4_DSTATE_dn;
  } else {
    rtDW.Integ4_a3 = 2.5E-6 * rtb_Product1_lp5 + rtDW.Integ4_DSTATE_dn;
  }

  /* End of DiscreteIntegrator: '<S652>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */

  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S639>/sin(wt)' */
  if (rtDW.systemEnable_g1 != 0) {
    rtDW.lastSin_gg = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_kz = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_g1 = 0;
  }

  /* Product: '<S639>/Product' incorporates:
   *  Sin: '<S639>/sin(wt)'
   */
  rtb_Product_cki = ((rtDW.lastSin_gg * 0.99999822347173384 + rtDW.lastCos_kz *
                      -0.0018849544759281136) * 0.99999822347173384 +
                     (rtDW.lastCos_kz * 0.99999822347173384 - rtDW.lastSin_gg *
                      -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[58];

  /* DiscreteIntegrator: '<S654>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jw != 0) {
    rtDW.Integ4_lc = rtDW.Integ4_DSTATE_f;
  } else {
    rtDW.Integ4_lc = 2.5E-6 * rtb_Product_cki + rtDW.Integ4_DSTATE_f;
  }

  /* End of DiscreteIntegrator: '<S654>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */

  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S640>/cos(wt)' */
  if (rtDW.systemEnable_e3 != 0) {
    rtDW.lastSin_c = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_a5 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_e3 = 0;
  }

  /* Product: '<S640>/Product1' incorporates:
   *  Sin: '<S640>/cos(wt)'
   */
  rtb_Product1_gf = ((rtDW.lastSin_c * 0.0018849544759281464 + rtDW.lastCos_a5 *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_a5 * 0.0018849544759281464 - rtDW.lastSin_c *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[59];

  /* DiscreteIntegrator: '<S658>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_h5 != 0) {
    rtDW.Integ4_hp = rtDW.Integ4_DSTATE_fv;
  } else {
    rtDW.Integ4_hp = 2.5E-6 * rtb_Product1_gf + rtDW.Integ4_DSTATE_fv;
  }

  /* End of DiscreteIntegrator: '<S658>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S659>/S-Function' incorporates:
   *  Constant: '<S658>/K1'
   */

  /* Level2 S-Function Block: '<S659>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S640>/sin(wt)' */
  if (rtDW.systemEnable_bl != 0) {
    rtDW.lastSin_mp = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_pe = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bl = 0;
  }

  /* Product: '<S640>/Product' incorporates:
   *  Sin: '<S640>/sin(wt)'
   */
  rtb_Product_jn = ((rtDW.lastSin_mp * 0.99999822347173384 + rtDW.lastCos_pe *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_pe * 0.99999822347173384 - rtDW.lastSin_mp *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[59];

  /* DiscreteIntegrator: '<S660>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_k5 != 0) {
    rtDW.Integ4_ce = rtDW.Integ4_DSTATE_ex;
  } else {
    rtDW.Integ4_ce = 2.5E-6 * rtb_Product_jn + rtDW.Integ4_DSTATE_ex;
  }

  /* End of DiscreteIntegrator: '<S660>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S661>/S-Function' incorporates:
   *  Constant: '<S660>/K1'
   */

  /* Level2 S-Function Block: '<S661>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S548>/cos(wt)' */
  if (rtDW.systemEnable_pz != 0) {
    rtDW.lastSin_nh = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_kw = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_pz = 0;
  }

  /* Product: '<S548>/Product1' incorporates:
   *  Sin: '<S548>/cos(wt)'
   */
  rtb_Product1_l2 = ((rtDW.lastSin_nh * 0.0018849544759281464 + rtDW.lastCos_kw *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_kw * 0.0018849544759281464 - rtDW.lastSin_nh *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[41];

  /* DiscreteIntegrator: '<S552>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bj != 0) {
    rtDW.Integ4_mu = rtDW.Integ4_DSTATE_nc;
  } else {
    rtDW.Integ4_mu = 2.5E-6 * rtb_Product1_l2 + rtDW.Integ4_DSTATE_nc;
  }

  /* End of DiscreteIntegrator: '<S552>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S553>/S-Function' incorporates:
   *  Constant: '<S552>/K1'
   */

  /* Level2 S-Function Block: '<S553>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S548>/sin(wt)' */
  if (rtDW.systemEnable_avi != 0) {
    rtDW.lastSin_mi = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bb = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_avi = 0;
  }

  /* Product: '<S548>/Product' incorporates:
   *  Sin: '<S548>/sin(wt)'
   */
  rtb_Product_ae = ((rtDW.lastSin_mi * 0.99999822347173384 + rtDW.lastCos_bb *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_bb * 0.99999822347173384 - rtDW.lastSin_mi *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[41];

  /* DiscreteIntegrator: '<S554>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ba != 0) {
    rtDW.Integ4_ddm = rtDW.Integ4_DSTATE_nd;
  } else {
    rtDW.Integ4_ddm = 2.5E-6 * rtb_Product_ae + rtDW.Integ4_DSTATE_nd;
  }

  /* End of DiscreteIntegrator: '<S554>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */

  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S549>/cos(wt)' */
  if (rtDW.systemEnable_ci != 0) {
    rtDW.lastSin_et = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ju = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ci = 0;
  }

  /* Product: '<S549>/Product1' incorporates:
   *  Sin: '<S549>/cos(wt)'
   */
  rtb_Product1_oo = ((rtDW.lastSin_et * 0.0018849544759281464 + rtDW.lastCos_ju *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_ju * 0.0018849544759281464 - rtDW.lastSin_et *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[68];

  /* DiscreteIntegrator: '<S558>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_gl != 0) {
    rtDW.Integ4_m1 = rtDW.Integ4_DSTATE_li;
  } else {
    rtDW.Integ4_m1 = 2.5E-6 * rtb_Product1_oo + rtDW.Integ4_DSTATE_li;
  }

  /* End of DiscreteIntegrator: '<S558>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S559>/S-Function' incorporates:
   *  Constant: '<S558>/K1'
   */

  /* Level2 S-Function Block: '<S559>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S549>/sin(wt)' */
  if (rtDW.systemEnable_bj1 != 0) {
    rtDW.lastSin_ac = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bd = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_bj1 = 0;
  }

  /* Product: '<S549>/Product' incorporates:
   *  Sin: '<S549>/sin(wt)'
   */
  rtb_Product_d = ((rtDW.lastSin_ac * 0.99999822347173384 + rtDW.lastCos_bd *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_bd * 0.99999822347173384 - rtDW.lastSin_ac *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[68];

  /* DiscreteIntegrator: '<S560>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_fs != 0) {
    rtDW.Integ4_nr = rtDW.Integ4_DSTATE_j5d;
  } else {
    rtDW.Integ4_nr = 2.5E-6 * rtb_Product_d + rtDW.Integ4_DSTATE_j5d;
  }

  /* End of DiscreteIntegrator: '<S560>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S561>/S-Function' incorporates:
   *  Constant: '<S560>/K1'
   */

  /* Level2 S-Function Block: '<S561>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S564>/cos(wt)' */
  if (rtDW.systemEnable_co != 0) {
    rtDW.lastSin_at = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ci = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_co = 0;
  }

  /* Product: '<S564>/Product1' incorporates:
   *  Sin: '<S564>/cos(wt)'
   */
  rtb_Product1_aa = ((rtDW.lastSin_at * 0.0018849544759281464 + rtDW.lastCos_ci *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_ci * 0.0018849544759281464 - rtDW.lastSin_at *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[30];

  /* DiscreteIntegrator: '<S572>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_cm != 0) {
    rtDW.Integ4_ab = rtDW.Integ4_DSTATE_av;
  } else {
    rtDW.Integ4_ab = 2.5E-6 * rtb_Product1_aa + rtDW.Integ4_DSTATE_av;
  }

  /* End of DiscreteIntegrator: '<S572>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */

  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S564>/sin(wt)' */
  if (rtDW.systemEnable_pd != 0) {
    rtDW.lastSin_la = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bbd = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_pd = 0;
  }

  /* Product: '<S564>/Product' incorporates:
   *  Sin: '<S564>/sin(wt)'
   */
  rtb_Product_p5i = ((rtDW.lastSin_la * 0.99999822347173384 + rtDW.lastCos_bbd *
                      -0.0018849544759281136) * 0.99999822347173384 +
                     (rtDW.lastCos_bbd * 0.99999822347173384 - rtDW.lastSin_la *
                      -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[30];

  /* DiscreteIntegrator: '<S574>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_cc != 0) {
    rtDW.Integ4_cc = rtDW.Integ4_DSTATE_leb;
  } else {
    rtDW.Integ4_cc = 2.5E-6 * rtb_Product_p5i + rtDW.Integ4_DSTATE_leb;
  }

  /* End of DiscreteIntegrator: '<S574>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */

  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S565>/cos(wt)' */
  if (rtDW.systemEnable_i2 != 0) {
    rtDW.lastSin_gh = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_lz = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_i2 = 0;
  }

  /* Product: '<S565>/Product1' incorporates:
   *  Sin: '<S565>/cos(wt)'
   */
  rtb_Product1_mm = ((rtDW.lastSin_gh * 0.0018849544759281464 + rtDW.lastCos_lz *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_lz * 0.0018849544759281464 - rtDW.lastSin_gh *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[31];

  /* DiscreteIntegrator: '<S578>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ix != 0) {
    rtDW.Integ4_m3 = rtDW.Integ4_DSTATE_b;
  } else {
    rtDW.Integ4_m3 = 2.5E-6 * rtb_Product1_mm + rtDW.Integ4_DSTATE_b;
  }

  /* End of DiscreteIntegrator: '<S578>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */

  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S565>/sin(wt)' */
  if (rtDW.systemEnable_ov != 0) {
    rtDW.lastSin_lo = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_gsk = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_ov = 0;
  }

  /* Product: '<S565>/Product' incorporates:
   *  Sin: '<S565>/sin(wt)'
   */
  rtb_Product_d3 = ((rtDW.lastSin_lo * 0.99999822347173384 + rtDW.lastCos_gsk *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_gsk * 0.99999822347173384 - rtDW.lastSin_lo *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[31];

  /* DiscreteIntegrator: '<S580>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_jo != 0) {
    rtDW.Integ4_ocz = rtDW.Integ4_DSTATE_e5;
  } else {
    rtDW.Integ4_ocz = 2.5E-6 * rtb_Product_d3 + rtDW.Integ4_DSTATE_e5;
  }

  /* End of DiscreteIntegrator: '<S580>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */

  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S566>/cos(wt)' */
  if (rtDW.systemEnable_mj != 0) {
    rtDW.lastSin_fa = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_hf = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_mj = 0;
  }

  /* Product: '<S566>/Product1' incorporates:
   *  Sin: '<S566>/cos(wt)'
   */
  rtb_Product1_e5 = ((rtDW.lastSin_fa * 0.0018849544759281464 + rtDW.lastCos_hf *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_hf * 0.0018849544759281464 - rtDW.lastSin_fa *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[32];

  /* DiscreteIntegrator: '<S584>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bu != 0) {
    rtDW.Integ4_frw = rtDW.Integ4_DSTATE_eb;
  } else {
    rtDW.Integ4_frw = 2.5E-6 * rtb_Product1_e5 + rtDW.Integ4_DSTATE_eb;
  }

  /* End of DiscreteIntegrator: '<S584>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S585>/S-Function' incorporates:
   *  Constant: '<S584>/K1'
   */

  /* Level2 S-Function Block: '<S585>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S566>/sin(wt)' */
  if (rtDW.systemEnable_nf != 0) {
    rtDW.lastSin_lk = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ig = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_nf = 0;
  }

  /* Product: '<S566>/Product' incorporates:
   *  Sin: '<S566>/sin(wt)'
   */
  rtb_Product_m = ((rtDW.lastSin_lk * 0.99999822347173384 + rtDW.lastCos_ig *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_ig * 0.99999822347173384 - rtDW.lastSin_lk *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[32];

  /* DiscreteIntegrator: '<S586>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i0 != 0) {
    rtDW.Integ4_ah = rtDW.Integ4_DSTATE_cq;
  } else {
    rtDW.Integ4_ah = 2.5E-6 * rtb_Product_m + rtDW.Integ4_DSTATE_cq;
  }

  /* End of DiscreteIntegrator: '<S586>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S587>/S-Function' incorporates:
   *  Constant: '<S586>/K1'
   */

  /* Level2 S-Function Block: '<S587>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S588>/cos(wt)' */
  if (rtDW.systemEnable_mx != 0) {
    rtDW.lastSin_gh2 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ew = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_mx = 0;
  }

  /* Product: '<S588>/Product1' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S588>/cos(wt)'
   */
  rtb_Product1_d = ((rtDW.lastSin_gh2 * 0.0018849544759281464 + rtDW.lastCos_ew *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_ew * 0.0018849544759281464 - rtDW.lastSin_gh2 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1_m[60];

  /* DiscreteIntegrator: '<S596>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_af != 0) {
    rtDW.Integ4_jz = rtDW.Integ4_DSTATE_hc;
  } else {
    rtDW.Integ4_jz = 2.5E-6 * rtb_Product1_d + rtDW.Integ4_DSTATE_hc;
  }

  /* End of DiscreteIntegrator: '<S596>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S597>/S-Function' incorporates:
   *  Constant: '<S596>/K1'
   */

  /* Level2 S-Function Block: '<S597>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S588>/sin(wt)' */
  if (rtDW.systemEnable_mx0 != 0) {
    rtDW.lastSin_nr = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_op = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_mx0 = 0;
  }

  /* Product: '<S588>/Product' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S588>/sin(wt)'
   */
  rtb_Product_k = ((rtDW.lastSin_nr * 0.99999822347173384 + rtDW.lastCos_op *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_op * 0.99999822347173384 - rtDW.lastSin_nr *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1_m[60];

  /* DiscreteIntegrator: '<S598>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ks != 0) {
    rtDW.Integ4_oe = rtDW.Integ4_DSTATE_m3;
  } else {
    rtDW.Integ4_oe = 2.5E-6 * rtb_Product_k + rtDW.Integ4_DSTATE_m3;
  }

  /* End of DiscreteIntegrator: '<S598>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */

  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S589>/cos(wt)' */
  if (rtDW.systemEnable_gl != 0) {
    rtDW.lastSin_fxm = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h0 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_gl = 0;
  }

  /* Product: '<S589>/Product1' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S589>/cos(wt)'
   */
  rtb_Product1_le = ((rtDW.lastSin_fxm * 0.0018849544759281464 + rtDW.lastCos_h0
                      * 0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_h0 * 0.0018849544759281464 - rtDW.lastSin_fxm
                      * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1_m[61];

  /* DiscreteIntegrator: '<S602>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_fu != 0) {
    rtDW.Integ4_ea = rtDW.Integ4_DSTATE_bo;
  } else {
    rtDW.Integ4_ea = 2.5E-6 * rtb_Product1_le + rtDW.Integ4_DSTATE_bo;
  }

  /* End of DiscreteIntegrator: '<S602>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S603>/S-Function' incorporates:
   *  Constant: '<S602>/K1'
   */

  /* Level2 S-Function Block: '<S603>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S589>/sin(wt)' */
  if (rtDW.systemEnable_df != 0) {
    rtDW.lastSin_o2f = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_niz = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_df = 0;
  }

  /* Product: '<S589>/Product' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S589>/sin(wt)'
   */
  rtb_Product_a = ((rtDW.lastSin_o2f * 0.99999822347173384 + rtDW.lastCos_niz *
                    -0.0018849544759281136) * 0.99999822347173384 +
                   (rtDW.lastCos_niz * 0.99999822347173384 - rtDW.lastSin_o2f *
                    -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1_m[61];

  /* DiscreteIntegrator: '<S604>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ns != 0) {
    rtDW.Integ4_no = rtDW.Integ4_DSTATE_jx;
  } else {
    rtDW.Integ4_no = 2.5E-6 * rtb_Product_a + rtDW.Integ4_DSTATE_jx;
  }

  /* End of DiscreteIntegrator: '<S604>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */

  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S590>/cos(wt)' */
  if (rtDW.systemEnable_h1 != 0) {
    rtDW.lastSin_p0 = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fu = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_h1 = 0;
  }

  /* Product: '<S590>/Product1' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S590>/cos(wt)'
   */
  rtb_Product1_e = ((rtDW.lastSin_p0 * 0.0018849544759281464 + rtDW.lastCos_fu *
                     0.99999822347173384) * 0.99999822347173384 +
                    (rtDW.lastCos_fu * 0.0018849544759281464 - rtDW.lastSin_p0 *
                     0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1_m[62];

  /* DiscreteIntegrator: '<S608>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_or != 0) {
    rtDW.Integ4_ex = rtDW.Integ4_DSTATE_g5;
  } else {
    rtDW.Integ4_ex = 2.5E-6 * rtb_Product1_e + rtDW.Integ4_DSTATE_g5;
  }

  /* End of DiscreteIntegrator: '<S608>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S609>/S-Function' incorporates:
   *  Constant: '<S608>/K1'
   */

  /* Level2 S-Function Block: '<S609>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S590>/sin(wt)' */
  if (rtDW.systemEnable_iv != 0) {
    rtDW.lastSin_nx = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_ez = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_iv = 0;
  }

  /* Product: '<S590>/Product' incorporates:
   *  Gain: '<Root>/to'
   *  Sin: '<S590>/sin(wt)'
   */
  rtb_Product_jv = ((rtDW.lastSin_nx * 0.99999822347173384 + rtDW.lastCos_ez *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_ez * 0.99999822347173384 - rtDW.lastSin_nx *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    -rtDW.StateSpace_o1_m[62];

  /* DiscreteIntegrator: '<S610>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_a0 != 0) {
    rtDW.Integ4_ij = rtDW.Integ4_DSTATE_my;
  } else {
    rtDW.Integ4_ij = 2.5E-6 * rtb_Product_jv + rtDW.Integ4_DSTATE_my;
  }

  /* End of DiscreteIntegrator: '<S610>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S611>/S-Function' incorporates:
   *  Constant: '<S610>/K1'
   */

  /* Level2 S-Function Block: '<S611>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S662>/cos(wt)' */
  if (rtDW.systemEnable_jo != 0) {
    rtDW.lastSin_eb = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_h2 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_jo = 0;
  }

  /* Product: '<S662>/Product1' incorporates:
   *  Sin: '<S662>/cos(wt)'
   */
  rtb_Product1_br = ((rtDW.lastSin_eb * 0.0018849544759281464 + rtDW.lastCos_h2 *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_h2 * 0.0018849544759281464 - rtDW.lastSin_eb *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[30];

  /* DiscreteIntegrator: '<S670>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ic != 0) {
    rtDW.Integ4_fg = rtDW.Integ4_DSTATE_pv;
  } else {
    rtDW.Integ4_fg = 2.5E-6 * rtb_Product1_br + rtDW.Integ4_DSTATE_pv;
  }

  /* End of DiscreteIntegrator: '<S670>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S671>/S-Function' incorporates:
   *  Constant: '<S670>/K1'
   */

  /* Level2 S-Function Block: '<S671>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S662>/sin(wt)' */
  if (rtDW.systemEnable_fh != 0) {
    rtDW.lastSin_pc = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_fuy = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_fh = 0;
  }

  /* Product: '<S662>/Product' incorporates:
   *  Sin: '<S662>/sin(wt)'
   */
  rtb_Product_kb = ((rtDW.lastSin_pc * 0.99999822347173384 + rtDW.lastCos_fuy *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_fuy * 0.99999822347173384 - rtDW.lastSin_pc *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[30];

  /* DiscreteIntegrator: '<S672>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bz != 0) {
    rtDW.Integ4_kv = rtDW.Integ4_DSTATE_ij;
  } else {
    rtDW.Integ4_kv = 2.5E-6 * rtb_Product_kb + rtDW.Integ4_DSTATE_ij;
  }

  /* End of DiscreteIntegrator: '<S672>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S673>/S-Function' incorporates:
   *  Constant: '<S672>/K1'
   */

  /* Level2 S-Function Block: '<S673>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S663>/cos(wt)' */
  if (rtDW.systemEnable_lo != 0) {
    rtDW.lastSin_ae = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_kf = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_lo = 0;
  }

  /* Product: '<S663>/Product1' incorporates:
   *  Sin: '<S663>/cos(wt)'
   */
  rtb_Product1_ce = ((rtDW.lastSin_ae * 0.0018849544759281464 + rtDW.lastCos_kf *
                      0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_kf * 0.0018849544759281464 - rtDW.lastSin_ae *
                      0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[31];

  /* DiscreteIntegrator: '<S676>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ds != 0) {
    rtDW.Integ4_ks = rtDW.Integ4_DSTATE_n2;
  } else {
    rtDW.Integ4_ks = 2.5E-6 * rtb_Product1_ce + rtDW.Integ4_DSTATE_n2;
  }

  /* End of DiscreteIntegrator: '<S676>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S677>/S-Function' incorporates:
   *  Constant: '<S676>/K1'
   */

  /* Level2 S-Function Block: '<S677>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S663>/sin(wt)' */
  if (rtDW.systemEnable_jc != 0) {
    rtDW.lastSin_mk = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_pk = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_jc = 0;
  }

  /* Product: '<S663>/Product' incorporates:
   *  Sin: '<S663>/sin(wt)'
   */
  rtb_Product_pg = ((rtDW.lastSin_mk * 0.99999822347173384 + rtDW.lastCos_pk *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_pk * 0.99999822347173384 - rtDW.lastSin_mk *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[31];

  /* DiscreteIntegrator: '<S678>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_ow != 0) {
    rtDW.Integ4_dl = rtDW.Integ4_DSTATE_dy;
  } else {
    rtDW.Integ4_dl = 2.5E-6 * rtb_Product_pg + rtDW.Integ4_DSTATE_dy;
  }

  /* End of DiscreteIntegrator: '<S678>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S679>/S-Function' incorporates:
   *  Constant: '<S678>/K1'
   */

  /* Level2 S-Function Block: '<S679>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S664>/cos(wt)' */
  if (rtDW.systemEnable_pq != 0) {
    rtDW.lastSin_pu = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_bdo = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_pq = 0;
  }

  /* Product: '<S664>/Product1' incorporates:
   *  Sin: '<S664>/cos(wt)'
   */
  rtb_Product1_pz = ((rtDW.lastSin_pu * 0.0018849544759281464 + rtDW.lastCos_bdo
                      * 0.99999822347173384) * 0.99999822347173384 +
                     (rtDW.lastCos_bdo * 0.0018849544759281464 - rtDW.lastSin_pu
                      * 0.99999822347173384) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[32];

  /* DiscreteIntegrator: '<S682>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_i1 != 0) {
    rtDW.Integ4_kd = rtDW.Integ4_DSTATE_hd;
  } else {
    rtDW.Integ4_kd = 2.5E-6 * rtb_Product1_pz + rtDW.Integ4_DSTATE_hd;
  }

  /* End of DiscreteIntegrator: '<S682>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S683>/S-Function' incorporates:
   *  Constant: '<S682>/K1'
   */

  /* Level2 S-Function Block: '<S683>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnOutputs(rts,0);
  }

  /* Sin: '<S664>/sin(wt)' */
  if (rtDW.systemEnable_n5 != 0) {
    rtDW.lastSin_cp = sin(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.lastCos_k1 = cos(376.99111843077515 * rtM->Timing.t[0]);
    rtDW.systemEnable_n5 = 0;
  }

  /* Product: '<S664>/Product' incorporates:
   *  Sin: '<S664>/sin(wt)'
   */
  rtb_Product_pk = ((rtDW.lastSin_cp * 0.99999822347173384 + rtDW.lastCos_k1 *
                     -0.0018849544759281136) * 0.99999822347173384 +
                    (rtDW.lastCos_k1 * 0.99999822347173384 - rtDW.lastSin_cp *
                     -0.0018849544759281136) * 0.0018849544759281136) * 2.0 *
    rtDW.StateSpace_o1_m[32];

  /* DiscreteIntegrator: '<S684>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_oo != 0) {
    rtDW.Integ4_id = rtDW.Integ4_DSTATE_pa;
  } else {
    rtDW.Integ4_id = 2.5E-6 * rtb_Product_pk + rtDW.Integ4_DSTATE_pa;
  }

  /* End of DiscreteIntegrator: '<S684>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S685>/S-Function' incorporates:
   *  Constant: '<S684>/K1'
   */

  /* Level2 S-Function Block: '<S685>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S544>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_co != 0) {
    rtDW.Integ4_ddl = rtDW.Integ4_DSTATE_px;
  } else {
    rtDW.Integ4_ddl = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_DSTATE_px;
  }

  /* End of DiscreteIntegrator: '<S544>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */

  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S540>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_pb != 0) {
    rtDW.Integ4_pt = rtDW.Integ4_DSTATE_exz;
  } else {
    rtDW.Integ4_pt = 2.5E-6 * rtb_sinwt + rtDW.Integ4_DSTATE_exz;
  }

  /* End of DiscreteIntegrator: '<S540>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S541>/S-Function' incorporates:
   *  Constant: '<S540>/K1'
   */

  /* Level2 S-Function Block: '<S541>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnOutputs(rts,0);
  }

  /* DiscreteIntegrator: '<S542>/Integ4' */
  if (rtDW.Integ4_SYSTEM_ENABLE_bzw != 0) {
    rtDW.Integ4_pf = rtDW.Integ4_DSTATE_hs;
  } else {
    rtDW.Integ4_pf = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_DSTATE_hs;
  }

  /* End of DiscreteIntegrator: '<S542>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */

  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnOutputs(rts,0);
  }

  /* Update for S-Function (sfun_spssw_discc): '<S953>/State-Space' incorporates:
   *  Constant: '<S354>/DC'
   */

  /* S-Function block: <S953>/State-Space */
  {
    const real_T *As = (real_T*)rtDW.StateSpace_PWORK.AS;
    const real_T *Bs = (real_T*)rtDW.StateSpace_PWORK.BS;
    real_T *xtmp = (real_T*)rtDW.StateSpace_PWORK.XTMP;
    real_T accum;

    /* Calculate new states... */
    accum = 0.0;
    accum += *(As++) * rtDW.StateSpace_DSTATE;
    accum += *(Bs++) * 500.0;
    xtmp[0] = accum;
    rtDW.StateSpace_DSTATE = xtmp[0];
  }

  /* Update for Sin: '<S5>/Uref2' */
  HoldSine = rtDW.lastSin;
  rtDW.lastSin = rtDW.lastSin * 0.99999876629970352 + rtDW.lastCos *
    0.0015707956808308789;
  rtDW.lastCos = rtDW.lastCos * 0.99999876629970352 - HoldSine *
    0.0015707956808308789;

  /* Update for UnitDelay: '<S370>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE = rtDW.StateSpace_o1_m[40];

  /* Update for UnitDelay: '<S370>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE = rtb_Uref2;

  /* Update for UnitDelay: '<S366>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE[0] = rtDW.StateSpace_o1[4];
  rtDW.UnitDelay1_DSTATE[1] = rtDW.StateSpace_o1[3];

  /* Update for S-Function (sfun_spssw_discc): '<S954>/State-Space' incorporates:
   *  Constant: '<S381>/eee'
   *  Constant: '<S383>/eee'
   *  Constant: '<S959>/SwitchCurrents'
   */

  /* S-Function block: <S954>/State-Space */
  {
    const real_T *As = (real_T*)rtDW.StateSpace_PWORK_n.AS;
    const real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_n.BS;
    real_T *xtmp = (real_T*)rtDW.StateSpace_PWORK_n.XTMP;
    real_T accum;

    /* Calculate new states... */
    accum = 0.0;
    accum += *(As++) * rtDW.StateSpace_DSTATE_d[0];
    accum += *(As++) * rtDW.StateSpace_DSTATE_d[1];
    accum += *(Bs++) * (0.0);
    accum += *(Bs++) * (0.0);
    accum += *(Bs++) * rtDW.V_ji[1];
    accum += *(Bs++) * rtDW.V_ji[0];
    accum += *(Bs++) * 0.001;
    accum += *(Bs++) * 0.001;
    xtmp[0] = accum;
    accum = 0.0;
    accum += *(As++) * rtDW.StateSpace_DSTATE_d[0];
    accum += *(As++) * rtDW.StateSpace_DSTATE_d[1];
    accum += *(Bs++) * (0.0);
    accum += *(Bs++) * (0.0);
    accum += *(Bs++) * rtDW.V_ji[1];
    accum += *(Bs++) * rtDW.V_ji[0];
    accum += *(Bs++) * 0.001;
    accum += *(Bs++) * 0.001;
    xtmp[1] = accum;
    rtDW.StateSpace_DSTATE_d[0] = xtmp[0];
    rtDW.StateSpace_DSTATE_d[1] = xtmp[1];

    {
      int_T *gState = (int_T*)rtDW.StateSpace_PWORK_n.G_STATE;

      /* Store switch gates values for next step */
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
    }
  }

  /* Update for Sin: '<Root>/Vload' */
  HoldSine = rtDW.lastSin_n;
  rtDW.lastSin_n = rtDW.lastSin_n * 0.99999998766299447 + rtDW.lastCos_f *
    0.00015707963203352558;
  rtDW.lastCos_f = rtDW.lastCos_f * 0.99999998766299447 - HoldSine *
    0.00015707963203352558;

  /* Update for UnitDelay: '<S65>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_g = rtDW.StateSpace_o1_m[36];

  /* Update for UnitDelay: '<S65>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_h = rtb_Add8;

  /* Update for UnitDelay: '<S61>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_k = rtDW.StateSpace_o1_m[65];

  /* Update for UnitDelay: '<S47>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_e = rtDW.StateSpace_o1_m[34];

  /* Update for UnitDelay: '<S47>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_o = rtb_UnitDelay5_o;

  /* Update for UnitDelay: '<S43>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_i = rtDW.StateSpace_o1_m[64];

  /* Signum: '<S351>/Sign' incorporates:
   *  DiscreteIntegrator: '<S346>/Discrete-Time Integrator'
   */
  if (rtDW.DiscreteTimeIntegrator_DSTATE < 0.0) {
    HoldSine = -1.0;
  } else if (rtDW.DiscreteTimeIntegrator_DSTATE > 0.0) {
    HoldSine = 1.0;
  } else if (rtDW.DiscreteTimeIntegrator_DSTATE == 0.0) {
    HoldSine = 0.0;
  } else {
    HoldSine = (rtNaN);
  }

  /* End of Signum: '<S351>/Sign' */

  /* Update for DiscreteIntegrator: '<S346>/Discrete-Time Integrator' incorporates:
   *  Constant: '<Root>/Load Torque'
   *  Gain: '<S346>/Gain2'
   *  Gain: '<S351>/Gain'
   *  Gain: '<S351>/Gain1'
   *  Product: '<S346>/Product1'
   *  Sum: '<S346>/Sum'
   *  Sum: '<S351>/Sum'
   *  UnitDelay: '<S346>/KE filter'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE += ((rtDW.StateSpace_o1_m[67] *
    rtDW.KEfilter_DSTATE - 1000.0) - (0.0 * HoldSine + 0.272 *
    rtDW.DiscreteTimeIntegrator_DSTATE)) * 0.1 * 5.0E-6;

  /* Update for UnitDelay: '<S346>/KE filter' */
  rtDW.KEfilter_DSTATE = rtb_Fieldarmaturemutualinductan;

  /* Update for UnitDelay: '<S83>/Unit Delay' */
  rtDW.UnitDelay_DSTATE = rtb_phi_f;

  /* Update for UnitDelay: '<S250>/Delay_x1' incorporates:
   *  Gain: '<S251>/A11'
   *  Gain: '<S251>/A12'
   *  Sum: '<S250>/A*x1(k) + B*u1(k) '
   *  Sum: '<S251>/sum2'
   *  UnitDelay: '<S250>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE = (0.99893981644628616 * rtDW.Delay_x1_DSTATE +
    4.7724132384231262E-6 * rtDW.Delay_x2_DSTATE) + rtb_B11_n;

  /* Update for UnitDelay: '<S250>/Delay_x2' incorporates:
   *  Sum: '<S250>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE = rtb_UnitDelay7_b + rtb_B21_h;

  /* Update for UnitDelay: '<S736>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_c = rtDW.StateSpace_o1_m[56];

  /* Update for UnitDelay: '<S736>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_l = rtb_Fcn_iz;

  /* Update for UnitDelay: '<S736>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE = rtDW.StateSpace_o1_m[44];

  /* Update for UnitDelay: '<S736>/Unit Delay7' */
  rtDW.UnitDelay7_DSTATE = rtb_Fcn1;

  /* Update for UnitDelay: '<S688>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ky[0] = rtDW.StateSpace_o1_m[84];
  rtDW.UnitDelay1_DSTATE_ky[1] = rtDW.StateSpace_o1_m[79];

  /* Update for UnitDelay: '<S84>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_o = rtb_UnitDelay5_ax;

  /* Update for UnitDelay: '<S329>/Delay_x1' incorporates:
   *  Gain: '<S330>/A11'
   *  Gain: '<S330>/A12'
   *  Sum: '<S329>/A*x1(k) + B*u1(k) '
   *  Sum: '<S330>/sum2'
   *  UnitDelay: '<S329>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_p = (0.99893981644628616 * rtDW.Delay_x1_DSTATE_p +
    4.7724132384231262E-6 * rtDW.Delay_x2_DSTATE_c) + rtb_B11_h;

  /* Update for UnitDelay: '<S329>/Delay_x2' incorporates:
   *  Sum: '<S329>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_c = rtb_sum3_d + rtb_B21_n;

  /* Update for UnitDelay: '<S828>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_g0 = rtDW.StateSpace_o1_m[47];

  /* Update for UnitDelay: '<S828>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_hc = rtb_UnitDelay5_di;

  /* Update for UnitDelay: '<S822>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_b[0] = rtDW.StateSpace_o1_m[72];
  rtDW.UnitDelay1_DSTATE_b[1] = rtDW.StateSpace_o1_m[87];

  /* Update for UnitDelay: '<S886>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_i = rtDW.StateSpace_o1_m[54];

  /* Update for UnitDelay: '<S886>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_i = rtb_UnitDelay5_f;

  /* Update for UnitDelay: '<S882>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_d[0] = rtDW.StateSpace_o1_m[80];
  rtDW.UnitDelay1_DSTATE_d[1] = rtDW.StateSpace_o1_m[73];

  /* Update for UnitDelay: '<S692>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_l = rtDW.StateSpace_o1_m[52];

  /* Update for UnitDelay: '<S692>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_g = rtb_UnitDelay5_h0;

  /* Update for UnitDelay: '<S692>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE_p = rtDW.StateSpace_o1_m[42];

  /* Update for UnitDelay: '<S692>/Unit Delay7' */
  rtDW.UnitDelay7_DSTATE_d = rtb_UnitDelay4_c;

  /* Update for UnitDelay: '<S787>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_b = rtDW.StateSpace_o1_m[49];

  /* Update for UnitDelay: '<S787>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_b = rtb_UnitDelay5_aw;

  /* Update for UnitDelay: '<S763>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ka[0] = rtDW.StateSpace_o1_m[71];
  rtDW.UnitDelay1_DSTATE_ka[1] = rtDW.StateSpace_o1_m[83];

  /* Update for UnitDelay: '<S866>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_lw = rtDW.StateSpace_o1_m[48];

  /* Update for UnitDelay: '<S866>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_d = rtb_UnitDelay5_l;

  /* Update for UnitDelay: '<S824>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_l[0] = rtDW.StateSpace_o1_m[86];
  rtDW.UnitDelay1_DSTATE_l[1] = rtDW.StateSpace_o1_m[85];

  /* Update for UnitDelay: '<S768>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_ij = rtDW.StateSpace_o1_m[45];

  /* Update for UnitDelay: '<S768>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_o0 = rtb_UnitDelay5_de;

  /* Update for UnitDelay: '<S847>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_bb = rtDW.StateSpace_o1_m[50];

  /* Update for UnitDelay: '<S847>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_iz = rtb_UnitDelay5_e;

  /* Update for UnitDelay: '<S806>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_ik = rtDW.StateSpace_o1_m[46];

  /* Update for UnitDelay: '<S806>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_le = rtb_UnitDelay5_a2;

  /* Update for UnitDelay: '<S686>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_a[0] = rtDW.StateSpace_o1_m[81];

  /* Update for UnitDelay: '<S762>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_f[0] = rtDW.StateSpace_o1_m[74];

  /* Update for UnitDelay: '<S823>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_c[0] = rtDW.StateSpace_o1_m[88];

  /* Update for UnitDelay: '<S764>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_j[0] = rtDW.StateSpace_o1_m[90];

  /* Update for UnitDelay: '<S686>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_a[1] = rtDW.StateSpace_o1_m[82];

  /* Update for UnitDelay: '<S762>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_f[1] = rtDW.StateSpace_o1_m[75];

  /* Update for UnitDelay: '<S823>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_c[1] = rtDW.StateSpace_o1_m[89];

  /* Update for UnitDelay: '<S764>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_j[1] = rtDW.StateSpace_o1_m[91];

  /* Update for Sin: '<S5>/Uref1' */
  HoldSine = rtDW.lastSin_b;
  rtDW.lastSin_b = rtDW.lastSin_b * 0.99999822347173384 + rtDW.lastCos_h *
    0.0018849544759281136;
  rtDW.lastCos_h = rtDW.lastCos_h * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for UnitDelay: '<S394>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_g0i = rtDW.StateSpace_o1_m[53];

  /* Update for UnitDelay: '<S394>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_n = rtb_ComplextoMagnitudeAngle__nj;

  /* Update for UnitDelay: '<S390>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_d3[0] = rtDW.StateSpace_o1_m[70];
  rtDW.UnitDelay1_DSTATE_d3[1] = rtDW.StateSpace_o1_m[69];

  /* Update for UnitDelay: '<S714>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_k = rtDW.StateSpace_o1_m[55];

  /* Update for UnitDelay: '<S714>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_h5 = rtb_UnitDelay5_g;

  /* Update for UnitDelay: '<S714>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE_c = rtDW.StateSpace_o1_m[43];

  /* Update for UnitDelay: '<S714>/Unit Delay7' */
  rtDW.UnitDelay7_DSTATE_n = rtb_UnitDelay4_lk;

  /* Update for UnitDelay: '<S687>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_k3[0] = rtDW.StateSpace_o1_m[78];
  rtDW.UnitDelay1_DSTATE_k3[1] = rtDW.StateSpace_o1_m[77];

  /* Update for S-Function (sfun_spssw_discc): '<S955>/State-Space' incorporates:
   *  Constant: '<S355>/DC'
   *  Constant: '<S405>/eee'
   *  Constant: '<S407>/eee'
   *  Constant: '<S54>/eee'
   *  Constant: '<S705>/eee'
   *  Constant: '<S707>/eee'
   *  Constant: '<S727>/eee'
   *  Constant: '<S729>/eee'
   *  Constant: '<S72>/eee'
   *  Constant: '<S749>/eee'
   *  Constant: '<S751>/eee'
   *  Constant: '<S779>/eee'
   *  Constant: '<S781>/eee'
   *  Constant: '<S798>/eee'
   *  Constant: '<S800>/eee'
   *  Constant: '<S817>/eee'
   *  Constant: '<S819>/eee'
   *  Constant: '<S839>/eee'
   *  Constant: '<S841>/eee'
   *  Constant: '<S858>/eee'
   *  Constant: '<S860>/eee'
   *  Constant: '<S877>/eee'
   *  Constant: '<S879>/eee'
   *  Constant: '<S897>/eee'
   *  Constant: '<S899>/eee'
   *  Constant: '<S963>/SwitchCurrents'
   */

  /* S-Function block: <S955>/State-Space */
  {
    const real_T *As = (real_T*)rtDW.StateSpace_PWORK_f.AS;
    const real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_f.BS;
    real_T *xtmp = (real_T*)rtDW.StateSpace_PWORK_f.XTMP;
    real_T accum;

    /* Calculate new states... */
    {
      int_T i1;
      real_T *xd = &rtDW.StateSpace_DSTATE_l[0];
      for (i1=0; i1 < 38; i1++) {
        accum = 0.0;

        {
          int_T i2;
          real_T *xd = &rtDW.StateSpace_DSTATE_l[0];
          for (i2=0; i2 < 38; i2++) {
            accum += *(As++) * xd[i2];
          }
        }

        {
          int_T i2;
          const real_T *u0 = rtConstP.SwitchCurrents_Value;
          for (i2=0; i2 < 24; i2++) {
            accum += *(Bs++) * u0[i2];
          }

          accum += *(Bs++) * 500.0;
          accum += *(Bs++) * rtDW.Vload;
          accum += *(Bs++) * rtDW.V_jp;
          accum += *(Bs++) * rtDW.V_c;
          accum += *(Bs++) * rtDW.Product;
          accum += *(Bs++) * rtDW.V_k[0];
          accum += *(Bs++) * rtDW.V_oe[1];
          accum += *(Bs++) * rtDW.V[0];
          accum += *(Bs++) * rtDW.V_o2[1];
          accum += *(Bs++) * rtDW.V_o2[0];
          accum += *(Bs++) * rtDW.V_in[0];
          accum += *(Bs++) * rtDW.V_in[1];
          accum += *(Bs++) * rtDW.V_o[0];
          accum += *(Bs++) * rtDW.V_o[1];
          accum += *(Bs++) * rtDW.V_ow[0];
          accum += *(Bs++) * rtDW.V_ow[1];
          accum += *(Bs++) * rtDW.V_i[0];
          accum += *(Bs++) * rtDW.V_i[1];
          accum += *(Bs++) * rtDW.V_oe[0];
          accum += *(Bs++) * rtDW.V_j[1];
          accum += *(Bs++) * rtDW.V_j[0];
          accum += *(Bs++) * rtDW.V_b[1];
          accum += *(Bs++) * rtDW.V_b[0];
          accum += *(Bs++) * rtDW.V[1];
          accum += *(Bs++) * rtDW.V_k[1];
          accum += *(Bs++) * rtDW.V_n[1];
          accum += *(Bs++) * rtDW.V_n[0];
          accum += *(Bs++) * rtDW.Idc_a2;
          accum += *(Bs++) * rtDW.Idc_b;
          accum += *(Bs++) * rtDW.Idc_jt;
          accum += *(Bs++) * rtDW.Idc_nv[1];
          accum += *(Bs++) * rtDW.Idc_d[1];
          accum += *(Bs++) * rtDW.Idc_h[1];
          accum += *(Bs++) * rtDW.Idc_a;
          accum += *(Bs++) * rtDW.Idc_ay;
          accum += *(Bs++) * rtDW.Idc_o;
          accum += *(Bs++) * rtDW.Idc_e;
          accum += *(Bs++) * rtDW.Idc_j;
          accum += *(Bs++) * rtDW.Idc_n;
          accum += *(Bs++) * rtDW.Idc_nv[0];
          accum += *(Bs++) * rtDW.Idc;
          accum += *(Bs++) * rtDW.Idc_g;
          accum += *(Bs++) * rtDW.Idc_h[0];
          accum += *(Bs++) * rtDW.Idc_d[0];
          accum += *(Bs++) * rtDW.Sum5[0];
          accum += *(Bs++) * rtDW.Sum5[1];
          accum += *(Bs++) * rtDW.Sum5[2];
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
          accum += *(Bs++) * 0.001;
        }

        xtmp[i1] = accum;
      }
    }

    {
      int_T i1;
      real_T *xd = &rtDW.StateSpace_DSTATE_l[0];
      for (i1=0; i1 < 38; i1++) {
        xd[i1] = xtmp[i1];
      }
    }

    {
      int_T *gState = (int_T*)rtDW.StateSpace_PWORK_f.G_STATE;

      /* Store switch gates values for next step */
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
      *(gState++) = (int_T) 0.0;
    }
  }

  /* Update for Sin: '<S434>/sin(wt)' */
  HoldSine = rtDW.lastSin_o;
  rtDW.lastSin_o = rtDW.lastSin_o * 0.99999822347173384 + rtDW.lastCos_n *
    0.0018849544759281136;
  rtDW.lastCos_n = rtDW.lastCos_n * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S444>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE = 0U;
  rtDW.Integ4_DSTATE = 2.5E-6 * rtb_Switch2 + rtDW.Integ4;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */
  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S444>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_p = rtb_Switch2;

  /* Update for UnitDelay: '<S444>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m = rtb_Switch3;

  /* Update for Sin: '<S434>/cos(wt)' */
  HoldSine = rtDW.lastSin_j;
  rtDW.lastSin_j = rtDW.lastSin_j * 0.99999822347173384 + rtDW.lastCos_i *
    0.0018849544759281136;
  rtDW.lastCos_i = rtDW.lastCos_i * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S442>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_e = 0U;
  rtDW.Integ4_DSTATE_e = 2.5E-6 * rtb_Product1_a3 + rtDW.Integ4_p;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */
  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S442>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_c = rtb_Product1_a3;

  /* Update for UnitDelay: '<S442>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lc = rtb_Switch_p;

  /* Update for Sin: '<S435>/sin(wt)' */
  HoldSine = rtDW.lastSin_h;
  rtDW.lastSin_h = rtDW.lastSin_h * 0.99999822347173384 + rtDW.lastCos_j *
    0.0018849544759281136;
  rtDW.lastCos_j = rtDW.lastCos_j * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S450>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_c = 0U;
  rtDW.Integ4_DSTATE_d = 2.5E-6 * rtb_Product_jl + rtDW.Integ4_d;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */
  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S450>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_g = rtb_Product_jl;

  /* Update for UnitDelay: '<S450>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_fh = rtb_Switch_j5;

  /* Update for Sin: '<S435>/cos(wt)' */
  HoldSine = rtDW.lastSin_hi;
  rtDW.lastSin_hi = rtDW.lastSin_hi * 0.99999822347173384 + rtDW.lastCos_o *
    0.0018849544759281136;
  rtDW.lastCos_o = rtDW.lastCos_o * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S448>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i = 0U;
  rtDW.Integ4_DSTATE_dw = 2.5E-6 * rtb_Product1_cj + rtDW.Integ4_h;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */
  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S448>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_e = rtb_Product1_cj;

  /* Update for UnitDelay: '<S448>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jg = rtb_Switch_a4;

  /* Update for Sin: '<S436>/sin(wt)' */
  HoldSine = rtDW.lastSin_e;
  rtDW.lastSin_e = rtDW.lastSin_e * 0.99999822347173384 + rtDW.lastCos_fk *
    0.0018849544759281136;
  rtDW.lastCos_fk = rtDW.lastCos_fk * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S456>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n = 0U;
  rtDW.Integ4_DSTATE_p = 2.5E-6 * rtb_Product_e + rtDW.Integ4_a;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S457>/S-Function' incorporates:
   *  Constant: '<S456>/K1'
   */
  /* Level2 S-Function Block: '<S457>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S456>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_l = rtb_Product_e;

  /* Update for UnitDelay: '<S456>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_n = rtb_Switch_lc;

  /* Update for Sin: '<S436>/cos(wt)' */
  HoldSine = rtDW.lastSin_k;
  rtDW.lastSin_k = rtDW.lastSin_k * 0.99999822347173384 + rtDW.lastCos_g *
    0.0018849544759281136;
  rtDW.lastCos_g = rtDW.lastCos_g * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S454>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k = 0U;
  rtDW.Integ4_DSTATE_pr = 2.5E-6 * rtb_Product1_cu + rtDW.Integ4_c;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S455>/S-Function' incorporates:
   *  Constant: '<S454>/K1'
   */
  /* Level2 S-Function Block: '<S455>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S454>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_eo = rtb_Product1_cu;

  /* Update for UnitDelay: '<S454>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_h = rtb_Switch_d5;

  /* Update for Sin: '<S458>/sin(wt)' */
  HoldSine = rtDW.lastSin_ob;
  rtDW.lastSin_ob = rtDW.lastSin_ob * 0.99999822347173384 + rtDW.lastCos_k *
    0.0018849544759281136;
  rtDW.lastCos_k = rtDW.lastCos_k * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S468>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_g = 0U;
  rtDW.Integ4_DSTATE_o = 2.5E-6 * rtb_Product_bk + rtDW.Integ4_ae;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */
  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S468>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_h = rtb_Product_bk;

  /* Update for UnitDelay: '<S468>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_au = rtb_Switch_g;

  /* Update for Sin: '<S458>/cos(wt)' */
  HoldSine = rtDW.lastSin_f;
  rtDW.lastSin_f = rtDW.lastSin_f * 0.99999822347173384 + rtDW.lastCos_e *
    0.0018849544759281136;
  rtDW.lastCos_e = rtDW.lastCos_e * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S466>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ex = 0U;
  rtDW.Integ4_DSTATE_i = 2.5E-6 * rtb_Product1_om + rtDW.Integ4_k;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S467>/S-Function' incorporates:
   *  Constant: '<S466>/K1'
   */
  /* Level2 S-Function Block: '<S467>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S466>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_f = rtb_Product1_om;

  /* Update for UnitDelay: '<S466>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_av = rtb_Switch_i;

  /* Update for Sin: '<S459>/sin(wt)' */
  HoldSine = rtDW.lastSin_h0;
  rtDW.lastSin_h0 = rtDW.lastSin_h0 * 0.99999822347173384 + rtDW.lastCos_ov *
    0.0018849544759281136;
  rtDW.lastCos_ov = rtDW.lastCos_ov * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S474>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kl = 0U;
  rtDW.Integ4_DSTATE_g = 2.5E-6 * rtb_Product_gi + rtDW.Integ4_dh;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */
  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S474>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_b = rtb_Product_gi;

  /* Update for UnitDelay: '<S474>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_mw = rtb_Switch_fr;

  /* Update for Sin: '<S459>/cos(wt)' */
  HoldSine = rtDW.lastSin_a;
  rtDW.lastSin_a = rtDW.lastSin_a * 0.99999822347173384 + rtDW.lastCos_hg *
    0.0018849544759281136;
  rtDW.lastCos_hg = rtDW.lastCos_hg * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S472>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_l = 0U;
  rtDW.Integ4_DSTATE_m = 2.5E-6 * rtb_Product1_m1 + rtDW.Integ4_b;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S473>/S-Function' incorporates:
   *  Constant: '<S472>/K1'
   */
  /* Level2 S-Function Block: '<S473>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S472>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_lm = rtb_Product1_m1;

  /* Update for UnitDelay: '<S472>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o = rtb_Switch_b;

  /* Update for Sin: '<S460>/sin(wt)' */
  HoldSine = rtDW.lastSin_fx;
  rtDW.lastSin_fx = rtDW.lastSin_fx * 0.99999822347173384 + rtDW.lastCos_c *
    0.0018849544759281136;
  rtDW.lastCos_c = rtDW.lastCos_c * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S480>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k2 = 0U;
  rtDW.Integ4_DSTATE_j = 2.5E-6 * rtb_Product_o + rtDW.Integ4_hq;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S481>/S-Function' incorporates:
   *  Constant: '<S480>/K1'
   */
  /* Level2 S-Function Block: '<S481>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S480>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_i = rtb_Product_o;

  /* Update for UnitDelay: '<S480>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jl = rtb_Switch_f;

  /* Update for Sin: '<S460>/cos(wt)' */
  HoldSine = rtDW.lastSin_f2;
  rtDW.lastSin_f2 = rtDW.lastSin_f2 * 0.99999822347173384 + rtDW.lastCos_ni *
    0.0018849544759281136;
  rtDW.lastCos_ni = rtDW.lastCos_ni * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S478>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_j = 0U;
  rtDW.Integ4_DSTATE_l = 2.5E-6 * rtb_Product1_ly + rtDW.Integ4_j;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S479>/S-Function' incorporates:
   *  Constant: '<S478>/K1'
   */
  /* Level2 S-Function Block: '<S479>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S478>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ps = rtb_Product1_ly;

  /* Update for UnitDelay: '<S478>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ha = rtb_Switch_fz;

  /* Update for Sin: '<S902>/sin(wt)' */
  HoldSine = rtDW.lastSin_fm;
  rtDW.lastSin_fm = rtDW.lastSin_fm * 0.99999822347173384 + rtDW.lastCos_e4 *
    0.0018849544759281136;
  rtDW.lastCos_e4 = rtDW.lastCos_e4 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S912>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o = 0U;
  rtDW.Integ4_DSTATE_os = 2.5E-6 * rtb_Product_kx + rtDW.Integ4_f;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S913>/S-Function' incorporates:
   *  Constant: '<S912>/K1'
   */
  /* Level2 S-Function Block: '<S913>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S912>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_or = rtb_Product_kx;

  /* Update for UnitDelay: '<S912>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ay = rtb_Switch_c;

  /* Update for Sin: '<S902>/cos(wt)' */
  HoldSine = rtDW.lastSin_f5;
  rtDW.lastSin_f5 = rtDW.lastSin_f5 * 0.99999822347173384 + rtDW.lastCos_l *
    0.0018849544759281136;
  rtDW.lastCos_l = rtDW.lastCos_l * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S910>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_km = 0U;
  rtDW.Integ4_DSTATE_lo = 2.5E-6 * rtb_Product1_a + rtDW.Integ4_aa;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S911>/S-Function' incorporates:
   *  Constant: '<S910>/K1'
   */
  /* Level2 S-Function Block: '<S911>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S910>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_a = rtb_Product1_a;

  /* Update for UnitDelay: '<S910>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_e = rtb_Switch_d;

  /* Update for Sin: '<S903>/sin(wt)' */
  HoldSine = rtDW.lastSin_fmt;
  rtDW.lastSin_fmt = rtDW.lastSin_fmt * 0.99999822347173384 + rtDW.lastCos_ns *
    0.0018849544759281136;
  rtDW.lastCos_ns = rtDW.lastCos_ns * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S918>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_f = 0U;
  rtDW.Integ4_DSTATE_n = 2.5E-6 * rtb_Product_h5 + rtDW.Integ4_f0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S919>/S-Function' incorporates:
   *  Constant: '<S918>/K1'
   */
  /* Level2 S-Function Block: '<S919>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S918>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ln = rtb_Product_h5;

  /* Update for UnitDelay: '<S918>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ca = rtb_Switch_a;

  /* Update for Sin: '<S903>/cos(wt)' */
  HoldSine = rtDW.lastSin_d;
  rtDW.lastSin_d = rtDW.lastSin_d * 0.99999822347173384 + rtDW.lastCos_a *
    0.0018849544759281136;
  rtDW.lastCos_a = rtDW.lastCos_a * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S916>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fy = 0U;
  rtDW.Integ4_DSTATE_lc = 2.5E-6 * rtb_Product1_dm + rtDW.Integ4_i;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S917>/S-Function' incorporates:
   *  Constant: '<S916>/K1'
   */
  /* Level2 S-Function Block: '<S917>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S916>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_n = rtb_Product1_dm;

  /* Update for UnitDelay: '<S916>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ag = rtb_Switch_kul;

  /* Update for Sin: '<S904>/sin(wt)' */
  HoldSine = rtDW.lastSin_d1;
  rtDW.lastSin_d1 = rtDW.lastSin_d1 * 0.99999822347173384 + rtDW.lastCos_d *
    0.0018849544759281136;
  rtDW.lastCos_d = rtDW.lastCos_d * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S924>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n0 = 0U;
  rtDW.Integ4_DSTATE_o0 = 2.5E-6 * rtb_Product_gk + rtDW.Integ4_l;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S925>/S-Function' incorporates:
   *  Constant: '<S924>/K1'
   */
  /* Level2 S-Function Block: '<S925>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S924>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_gs = rtb_Product_gk;

  /* Update for UnitDelay: '<S924>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_cr = rtb_Switch_lu;

  /* Update for Sin: '<S904>/cos(wt)' */
  HoldSine = rtDW.lastSin_l;
  rtDW.lastSin_l = rtDW.lastSin_l * 0.99999822347173384 + rtDW.lastCos_l0 *
    0.0018849544759281136;
  rtDW.lastCos_l0 = rtDW.lastCos_l0 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S922>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_d = 0U;
  rtDW.Integ4_DSTATE_pu = 2.5E-6 * rtb_Product1_id + rtDW.Integ4_g;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S923>/S-Function' incorporates:
   *  Constant: '<S922>/K1'
   */
  /* Level2 S-Function Block: '<S923>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S922>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_p3 = rtb_Product1_id;

  /* Update for UnitDelay: '<S922>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_p = rtb_Switch_pr;

  /* Update for DiscreteIntegrator: '<S410>/Integ4' incorporates:
   *  Product: '<Root>/Product'
   */
  rtDW.Integ4_SYSTEM_ENABLE_a = 0U;
  rtDW.Integ4_DSTATE_jc = 2.5E-6 * rtb_sinwt + rtDW.Integ4_m;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S411>/S-Function' incorporates:
   *  Constant: '<S410>/K1'
   */
  /* Level2 S-Function Block: '<S411>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S410>/Unit Delay' incorporates:
   *  Product: '<Root>/Product'
   */
  rtDW.UnitDelay_DSTATE_bm = rtb_sinwt;

  /* Update for UnitDelay: '<S410>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m0 = rtb_phi;

  /* Update for DiscreteIntegrator: '<S412>/Integ4' incorporates:
   *  Product: '<Root>/Product1'
   */
  rtDW.Integ4_SYSTEM_ENABLE_h = 0U;
  rtDW.Integ4_DSTATE_id = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_fr;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */
  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S412>/Unit Delay' incorporates:
   *  Product: '<Root>/Product1'
   */
  rtDW.UnitDelay_DSTATE_cr = rtb_Product1_g_tmp;

  /* Update for UnitDelay: '<S412>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_g = rtb_Switch_lo;

  /* Update for DiscreteIntegrator: '<S414>/Integ4' incorporates:
   *  Product: '<Root>/Product2'
   */
  rtDW.Integ4_SYSTEM_ENABLE_m = 0U;
  rtDW.Integ4_DSTATE_h = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_mt;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */
  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S414>/Unit Delay' incorporates:
   *  Product: '<Root>/Product2'
   */
  rtDW.UnitDelay_DSTATE_m = rtb_Product2_tmp;

  /* Update for UnitDelay: '<S414>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ags = rtb_Switch_pa;

  /* Update for DiscreteIntegrator: '<S416>/Integ4' incorporates:
   *  Product: '<Root>/Product3'
   */
  rtDW.Integ4_SYSTEM_ENABLE_o0 = 0U;
  rtDW.Integ4_DSTATE_oi = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_ge;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S417>/S-Function' incorporates:
   *  Constant: '<S416>/K1'
   */
  /* Level2 S-Function Block: '<S417>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S416>/Unit Delay' incorporates:
   *  Product: '<Root>/Product3'
   */
  rtDW.UnitDelay_DSTATE_ez = rtb_Product3_h_tmp;

  /* Update for UnitDelay: '<S416>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lg = rtb_Switch_pt;

  /* Update for Sin: '<S418>/sin(wt)' */
  HoldSine = rtDW.lastSin_m;
  rtDW.lastSin_m = rtDW.lastSin_m * 0.99999822347173384 + rtDW.lastCos_ovt *
    0.0018849544759281136;
  rtDW.lastCos_ovt = rtDW.lastCos_ovt * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S424>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_b = 0U;
  rtDW.Integ4_DSTATE_pg = 2.5E-6 * rtb_Product_f + rtDW.Integ4_lf;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */
  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S424>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_aq = rtb_Product_f;

  /* Update for UnitDelay: '<S424>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jx = rtb_Switch_ly;

  /* Update for Sin: '<S418>/cos(wt)' */
  HoldSine = rtDW.lastSin_fl;
  rtDW.lastSin_fl = rtDW.lastSin_fl * 0.99999822347173384 + rtDW.lastCos_nl *
    0.0018849544759281136;
  rtDW.lastCos_nl = rtDW.lastCos_nl * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S422>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_en = 0U;
  rtDW.Integ4_DSTATE_oi0 = 2.5E-6 * rtb_Product1_aw + rtDW.Integ4_bp;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S423>/S-Function' incorporates:
   *  Constant: '<S422>/K1'
   */
  /* Level2 S-Function Block: '<S423>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S422>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_cn = rtb_Product1_aw;

  /* Update for UnitDelay: '<S422>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_kp = rtb_Switch_o;

  /* Update for Sin: '<S419>/sin(wt)' */
  HoldSine = rtDW.lastSin_p;
  rtDW.lastSin_p = rtDW.lastSin_p * 0.99999822347173384 + rtDW.lastCos_fl *
    0.0018849544759281136;
  rtDW.lastCos_fl = rtDW.lastCos_fl * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S430>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a3 = 0U;
  rtDW.Integ4_DSTATE_io = 2.5E-6 * rtb_Product_h4 + rtDW.Integ4_n;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S431>/S-Function' incorporates:
   *  Constant: '<S430>/K1'
   */
  /* Level2 S-Function Block: '<S431>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S430>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_j = rtb_Product_h4;

  /* Update for UnitDelay: '<S430>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lz = rtb_Switch_of;

  /* Update for Sin: '<S419>/cos(wt)' */
  HoldSine = rtDW.lastSin_e1;
  rtDW.lastSin_e1 = rtDW.lastSin_e1 * 0.99999822347173384 + rtDW.lastCos_h5 *
    0.0018849544759281136;
  rtDW.lastCos_h5 = rtDW.lastCos_h5 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S428>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kb = 0U;
  rtDW.Integ4_DSTATE_hw = 2.5E-6 * rtb_Product1_iv + rtDW.Integ4_o;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S429>/S-Function' incorporates:
   *  Constant: '<S428>/K1'
   */
  /* Level2 S-Function Block: '<S429>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S428>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_hl = rtb_Product1_iv;

  /* Update for UnitDelay: '<S428>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_iq = rtb_Switch_eu;

  /* Update for Sin: '<S484>/sin(wt)' */
  HoldSine = rtDW.lastSin_am;
  rtDW.lastSin_am = rtDW.lastSin_am * 0.99999822347173384 + rtDW.lastCos_ny *
    0.0018849544759281136;
  rtDW.lastCos_ny = rtDW.lastCos_ny * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S494>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cl = 0U;
  rtDW.Integ4_DSTATE_nf = 2.5E-6 * rtb_phi_b + rtDW.Integ4_mta;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */
  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S494>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_hw = rtb_phi_b;

  /* Update for UnitDelay: '<S494>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_gx = rtb_Switch_e;

  /* Update for Sin: '<S484>/cos(wt)' */
  HoldSine = rtDW.lastSin_jo;
  rtDW.lastSin_jo = rtDW.lastSin_jo * 0.99999822347173384 + rtDW.lastCos_on *
    0.0018849544759281136;
  rtDW.lastCos_on = rtDW.lastCos_on * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S492>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i2 = 0U;
  rtDW.Integ4_DSTATE_j5 = 2.5E-6 * rtb_Product1_fg + rtDW.Integ4_oc;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */
  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S492>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ai = rtb_Product1_fg;

  /* Update for UnitDelay: '<S492>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_di = rtb_Switch_ec;

  /* Update for Sin: '<S485>/sin(wt)' */
  HoldSine = rtDW.lastSin_pp;
  rtDW.lastSin_pp = rtDW.lastSin_pp * 0.99999822347173384 + rtDW.lastCos_ob *
    0.0018849544759281136;
  rtDW.lastCos_ob = rtDW.lastCos_ob * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S500>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bc = 0U;
  rtDW.Integ4_DSTATE_a = 2.5E-6 * rtb_Product_aa + rtDW.Integ4_do;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */
  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S500>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_lw = rtb_Product_aa;

  /* Update for UnitDelay: '<S500>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m5 = rtb_Switch_nl;

  /* Update for Sin: '<S485>/cos(wt)' */
  HoldSine = rtDW.lastSin_i;
  rtDW.lastSin_i = rtDW.lastSin_i * 0.99999822347173384 + rtDW.lastCos_b *
    0.0018849544759281136;
  rtDW.lastCos_b = rtDW.lastCos_b * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S498>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gs = 0U;
  rtDW.Integ4_DSTATE_k = 2.5E-6 * rtb_Product1_if + rtDW.Integ4_nk;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */
  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S498>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ei = rtb_Product1_if;

  /* Update for UnitDelay: '<S498>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_by = rtb_Switch_h;

  /* Update for Sin: '<S486>/sin(wt)' */
  HoldSine = rtDW.lastSin_hb;
  rtDW.lastSin_hb = rtDW.lastSin_hb * 0.99999822347173384 + rtDW.lastCos_i4 *
    0.0018849544759281136;
  rtDW.lastCos_i4 = rtDW.lastCos_i4 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S506>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jz = 0U;
  rtDW.Integ4_DSTATE_kd = 2.5E-6 * rtb_Product_p + rtDW.Integ4_pl;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S507>/S-Function' incorporates:
   *  Constant: '<S506>/K1'
   */
  /* Level2 S-Function Block: '<S507>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S506>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_jz = rtb_Product_p;

  /* Update for UnitDelay: '<S506>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_a1 = rtb_Switch_on;

  /* Update for Sin: '<S486>/cos(wt)' */
  HoldSine = rtDW.lastSin_fw;
  rtDW.lastSin_fw = rtDW.lastSin_fw * 0.99999822347173384 + rtDW.lastCos_p *
    0.0018849544759281136;
  rtDW.lastCos_p = rtDW.lastCos_p * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S504>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bm = 0U;
  rtDW.Integ4_DSTATE_me = 2.5E-6 * rtb_Product1_b4 + rtDW.Integ4_nkx;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S505>/S-Function' incorporates:
   *  Constant: '<S504>/K1'
   */
  /* Level2 S-Function Block: '<S505>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S504>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_b2 = rtb_Product1_b4;

  /* Update for UnitDelay: '<S504>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ea = rtb_Switch_m;

  /* Update for Sin: '<S508>/sin(wt)' */
  HoldSine = rtDW.lastSin_dz;
  rtDW.lastSin_dz = rtDW.lastSin_dz * 0.99999822347173384 + rtDW.lastCos_b4 *
    0.0018849544759281136;
  rtDW.lastCos_b4 = rtDW.lastCos_b4 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S518>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ke = 0U;
  rtDW.Integ4_DSTATE_ip = 2.5E-6 * rtb_Product_bo + rtDW.Integ4_mr;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S519>/S-Function' incorporates:
   *  Constant: '<S518>/K1'
   */
  /* Level2 S-Function Block: '<S519>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S518>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_fp = rtb_Product_bo;

  /* Update for UnitDelay: '<S518>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ma = rtb_Switch_fc;

  /* Update for Sin: '<S508>/cos(wt)' */
  HoldSine = rtDW.lastSin_jd;
  rtDW.lastSin_jd = rtDW.lastSin_jd * 0.99999822347173384 + rtDW.lastCos_ih *
    0.0018849544759281136;
  rtDW.lastCos_ih = rtDW.lastCos_ih * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S516>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oh = 0U;
  rtDW.Integ4_DSTATE_dq = 2.5E-6 * rtb_Product1_c5 + rtDW.Integ4_dg;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */
  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S516>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_gf = rtb_Product1_c5;

  /* Update for UnitDelay: '<S516>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_e2 = rtb_Switch_id;

  /* Update for Sin: '<S509>/sin(wt)' */
  HoldSine = rtDW.lastSin_nj;
  rtDW.lastSin_nj = rtDW.lastSin_nj * 0.99999822347173384 + rtDW.lastCos_hr *
    0.0018849544759281136;
  rtDW.lastCos_hr = rtDW.lastCos_hr * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S524>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_lx = 0U;
  rtDW.Integ4_DSTATE_le = 2.5E-6 * rtb_Product_i + rtDW.Integ4_e;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */
  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S524>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_d = rtb_Product_i;

  /* Update for UnitDelay: '<S524>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_gb = rtb_Switch_lq;

  /* Update for Sin: '<S509>/cos(wt)' */
  HoldSine = rtDW.lastSin_o2;
  rtDW.lastSin_o2 = rtDW.lastSin_o2 * 0.99999822347173384 + rtDW.lastCos_dm *
    0.0018849544759281136;
  rtDW.lastCos_dm = rtDW.lastCos_dm * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S522>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_of = 0U;
  rtDW.Integ4_DSTATE_ox = 2.5E-6 * rtb_Product1_ol + rtDW.Integ4_g4;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */
  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S522>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_hz = rtb_Product1_ol;

  /* Update for UnitDelay: '<S522>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_dz = rtb_Switch_p0;

  /* Update for Sin: '<S510>/sin(wt)' */
  HoldSine = rtDW.lastSin_e2;
  rtDW.lastSin_e2 = rtDW.lastSin_e2 * 0.99999822347173384 + rtDW.lastCos_m *
    0.0018849544759281136;
  rtDW.lastCos_m = rtDW.lastCos_m * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S530>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_p = 0U;
  rtDW.Integ4_DSTATE_gb = 2.5E-6 * rtb_Product_lv + rtDW.Integ4_ao;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */
  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S530>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_cm = rtb_Product_lv;

  /* Update for UnitDelay: '<S530>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jz = rtb_Switch_k;

  /* Update for Sin: '<S510>/cos(wt)' */
  HoldSine = rtDW.lastSin_dm;
  rtDW.lastSin_dm = rtDW.lastSin_dm * 0.99999822347173384 + rtDW.lastCos_ie *
    0.0018849544759281136;
  rtDW.lastCos_ie = rtDW.lastCos_ie * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S528>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_on = 0U;
  rtDW.Integ4_DSTATE_ia = 2.5E-6 * rtb_Product1_jq + rtDW.Integ4_mk;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */
  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S528>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_lx = rtb_Product1_jq;

  /* Update for UnitDelay: '<S528>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_pq = rtb_Switch_kp;

  /* Update for UnitDelay: '<S5>/Unit Delay2' */
  rtDW.UnitDelay2_DSTATE = rtb_Add;

  /* Update for UnitDelay: '<S5>/Unit Delay5' */
  rtDW.UnitDelay5_DSTATE_a = rtDW.StateSpace_o1_m[39];

  /* Update for UnitDelay: '<S5>/Unit Delay6' */
  rtDW.UnitDelay6_DSTATE_o2 = rtb_UnitDelay6_e;

  /* Update for UnitDelay: '<S5>/Unit Delay7' */
  rtDW.UnitDelay7_DSTATE_a = rtDW.StateSpace_o1_m[76];

  /* Update for UnitDelay: '<S5>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0[0] = rtDW.StateSpace_o1_m[60];

  /* Update for UnitDelay: '<S5>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE_i[0] = rtDW.StateSpace_o1_m[57];

  /* Update for UnitDelay: '<S5>/Unit Delay3' */
  rtDW.UnitDelay3_DSTATE[0] = rtDW.StateSpace_o1_m[24];

  /* Update for UnitDelay: '<S5>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ds[0] = rtDW.StateSpace_o1_m[30];

  /* Update for UnitDelay: '<S5>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0[1] = rtDW.StateSpace_o1_m[61];

  /* Update for UnitDelay: '<S5>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE_i[1] = rtDW.StateSpace_o1_m[58];

  /* Update for UnitDelay: '<S5>/Unit Delay3' */
  rtDW.UnitDelay3_DSTATE[1] = rtDW.StateSpace_o1_m[25];

  /* Update for UnitDelay: '<S5>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ds[1] = rtDW.StateSpace_o1_m[31];

  /* Update for UnitDelay: '<S5>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0[2] = rtDW.StateSpace_o1_m[62];

  /* Update for UnitDelay: '<S5>/Unit Delay4' */
  rtDW.UnitDelay4_DSTATE_i[2] = rtDW.StateSpace_o1_m[59];

  /* Update for UnitDelay: '<S5>/Unit Delay3' */
  rtDW.UnitDelay3_DSTATE[2] = rtDW.StateSpace_o1_m[26];

  /* Update for UnitDelay: '<S5>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_ds[2] = rtDW.StateSpace_o1_m[32];

  /* Update for DiscreteIntegrator: '<S546>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o3 = 0U;
  rtDW.Integ4_DSTATE_oe = 2.5E-6 * rtb_Product3_h_tmp + rtDW.Integ4_c1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S547>/S-Function' incorporates:
   *  Constant: '<S546>/K1'
   */
  /* Level2 S-Function Block: '<S547>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S614>/cos(wt)' */
  HoldSine = rtDW.lastSin_g;
  rtDW.lastSin_g = rtDW.lastSin_g * 0.99999822347173384 + rtDW.lastCos_ko *
    0.0018849544759281136;
  rtDW.lastCos_ko = rtDW.lastCos_ko * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S622>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_og = 0U;
  rtDW.Integ4_DSTATE_n5 = 2.5E-6 * rtb_Product1_hh + rtDW.Integ4_is;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */
  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S614>/sin(wt)' */
  HoldSine = rtDW.lastSin_ne;
  rtDW.lastSin_ne = rtDW.lastSin_ne * 0.99999822347173384 + rtDW.lastCos_n3 *
    0.0018849544759281136;
  rtDW.lastCos_n3 = rtDW.lastCos_n3 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S624>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gy = 0U;
  rtDW.Integ4_DSTATE_c = 2.5E-6 * rtb_Product_g + rtDW.Integ4_np;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */
  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S615>/cos(wt)' */
  HoldSine = rtDW.lastSin_am5;
  rtDW.lastSin_am5 = rtDW.lastSin_am5 * 0.99999822347173384 + rtDW.lastCos_gn *
    0.0018849544759281136;
  rtDW.lastCos_gn = rtDW.lastCos_gn * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S628>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nt = 0U;
  rtDW.Integ4_DSTATE_cd = 2.5E-6 * rtb_Product1_m4 + rtDW.Integ4_nw;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */
  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S615>/sin(wt)' */
  HoldSine = rtDW.lastSin_on;
  rtDW.lastSin_on = rtDW.lastSin_on * 0.99999822347173384 + rtDW.lastCos_gs *
    0.0018849544759281136;
  rtDW.lastCos_gs = rtDW.lastCos_gs * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S630>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ax = 0U;
  rtDW.Integ4_DSTATE_lz = 2.5E-6 * rtb_Product_h + rtDW.Integ4_pz;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */
  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S616>/cos(wt)' */
  HoldSine = rtDW.lastSin_h5;
  rtDW.lastSin_h5 = rtDW.lastSin_h5 * 0.99999822347173384 + rtDW.lastCos_pj *
    0.0018849544759281136;
  rtDW.lastCos_pj = rtDW.lastCos_pj * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S634>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ob = 0U;
  rtDW.Integ4_DSTATE_ne = 2.5E-6 * rtb_Product1_cr + rtDW.Integ4_i0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S635>/S-Function' incorporates:
   *  Constant: '<S634>/K1'
   */
  /* Level2 S-Function Block: '<S635>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S616>/sin(wt)' */
  HoldSine = rtDW.lastSin_n1;
  rtDW.lastSin_n1 = rtDW.lastSin_n1 * 0.99999822347173384 + rtDW.lastCos_ihc *
    0.0018849544759281136;
  rtDW.lastCos_ihc = rtDW.lastCos_ihc * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S636>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pc = 0U;
  rtDW.Integ4_DSTATE_df = 2.5E-6 * rtb_Product_mv + rtDW.Integ4_j1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S637>/S-Function' incorporates:
   *  Constant: '<S636>/K1'
   */
  /* Level2 S-Function Block: '<S637>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S638>/cos(wt)' */
  HoldSine = rtDW.lastSin_ds;
  rtDW.lastSin_ds = rtDW.lastSin_ds * 0.99999822347173384 + rtDW.lastCos_k2 *
    0.0018849544759281136;
  rtDW.lastCos_k2 = rtDW.lastCos_k2 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S646>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ka = 0U;
  rtDW.Integ4_DSTATE_am = 2.5E-6 * rtb_Product1_ec + rtDW.Integ4_di;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */
  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S638>/sin(wt)' */
  HoldSine = rtDW.lastSin_ft;
  rtDW.lastSin_ft = rtDW.lastSin_ft * 0.99999822347173384 + rtDW.lastCos_le *
    0.0018849544759281136;
  rtDW.lastCos_le = rtDW.lastCos_le * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S648>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ft = 0U;
  rtDW.Integ4_DSTATE_ct = 2.5E-6 * rtb_Product_db + rtDW.Integ4_dd;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */
  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S639>/cos(wt)' */
  HoldSine = rtDW.lastSin_ik;
  rtDW.lastSin_ik = rtDW.lastSin_ik * 0.99999822347173384 + rtDW.lastCos_gx *
    0.0018849544759281136;
  rtDW.lastCos_gx = rtDW.lastCos_gx * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S652>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_js = 0U;
  rtDW.Integ4_DSTATE_dn = 2.5E-6 * rtb_Product1_lp5 + rtDW.Integ4_a3;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */
  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S639>/sin(wt)' */
  HoldSine = rtDW.lastSin_gg;
  rtDW.lastSin_gg = rtDW.lastSin_gg * 0.99999822347173384 + rtDW.lastCos_kz *
    0.0018849544759281136;
  rtDW.lastCos_kz = rtDW.lastCos_kz * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S654>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jw = 0U;
  rtDW.Integ4_DSTATE_f = 2.5E-6 * rtb_Product_cki + rtDW.Integ4_lc;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */
  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S640>/cos(wt)' */
  HoldSine = rtDW.lastSin_c;
  rtDW.lastSin_c = rtDW.lastSin_c * 0.99999822347173384 + rtDW.lastCos_a5 *
    0.0018849544759281136;
  rtDW.lastCos_a5 = rtDW.lastCos_a5 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S658>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h5 = 0U;
  rtDW.Integ4_DSTATE_fv = 2.5E-6 * rtb_Product1_gf + rtDW.Integ4_hp;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S659>/S-Function' incorporates:
   *  Constant: '<S658>/K1'
   */
  /* Level2 S-Function Block: '<S659>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S640>/sin(wt)' */
  HoldSine = rtDW.lastSin_mp;
  rtDW.lastSin_mp = rtDW.lastSin_mp * 0.99999822347173384 + rtDW.lastCos_pe *
    0.0018849544759281136;
  rtDW.lastCos_pe = rtDW.lastCos_pe * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S660>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k5 = 0U;
  rtDW.Integ4_DSTATE_ex = 2.5E-6 * rtb_Product_jn + rtDW.Integ4_ce;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S661>/S-Function' incorporates:
   *  Constant: '<S660>/K1'
   */
  /* Level2 S-Function Block: '<S661>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S548>/cos(wt)' */
  HoldSine = rtDW.lastSin_nh;
  rtDW.lastSin_nh = rtDW.lastSin_nh * 0.99999822347173384 + rtDW.lastCos_kw *
    0.0018849544759281136;
  rtDW.lastCos_kw = rtDW.lastCos_kw * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S552>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bj = 0U;
  rtDW.Integ4_DSTATE_nc = 2.5E-6 * rtb_Product1_l2 + rtDW.Integ4_mu;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S553>/S-Function' incorporates:
   *  Constant: '<S552>/K1'
   */
  /* Level2 S-Function Block: '<S553>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S548>/sin(wt)' */
  HoldSine = rtDW.lastSin_mi;
  rtDW.lastSin_mi = rtDW.lastSin_mi * 0.99999822347173384 + rtDW.lastCos_bb *
    0.0018849544759281136;
  rtDW.lastCos_bb = rtDW.lastCos_bb * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S554>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ba = 0U;
  rtDW.Integ4_DSTATE_nd = 2.5E-6 * rtb_Product_ae + rtDW.Integ4_ddm;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */
  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S549>/cos(wt)' */
  HoldSine = rtDW.lastSin_et;
  rtDW.lastSin_et = rtDW.lastSin_et * 0.99999822347173384 + rtDW.lastCos_ju *
    0.0018849544759281136;
  rtDW.lastCos_ju = rtDW.lastCos_ju * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S558>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gl = 0U;
  rtDW.Integ4_DSTATE_li = 2.5E-6 * rtb_Product1_oo + rtDW.Integ4_m1;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S559>/S-Function' incorporates:
   *  Constant: '<S558>/K1'
   */
  /* Level2 S-Function Block: '<S559>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S549>/sin(wt)' */
  HoldSine = rtDW.lastSin_ac;
  rtDW.lastSin_ac = rtDW.lastSin_ac * 0.99999822347173384 + rtDW.lastCos_bd *
    0.0018849544759281136;
  rtDW.lastCos_bd = rtDW.lastCos_bd * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S560>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fs = 0U;
  rtDW.Integ4_DSTATE_j5d = 2.5E-6 * rtb_Product_d + rtDW.Integ4_nr;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S561>/S-Function' incorporates:
   *  Constant: '<S560>/K1'
   */
  /* Level2 S-Function Block: '<S561>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S564>/cos(wt)' */
  HoldSine = rtDW.lastSin_at;
  rtDW.lastSin_at = rtDW.lastSin_at * 0.99999822347173384 + rtDW.lastCos_ci *
    0.0018849544759281136;
  rtDW.lastCos_ci = rtDW.lastCos_ci * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S572>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cm = 0U;
  rtDW.Integ4_DSTATE_av = 2.5E-6 * rtb_Product1_aa + rtDW.Integ4_ab;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */
  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S564>/sin(wt)' */
  HoldSine = rtDW.lastSin_la;
  rtDW.lastSin_la = rtDW.lastSin_la * 0.99999822347173384 + rtDW.lastCos_bbd *
    0.0018849544759281136;
  rtDW.lastCos_bbd = rtDW.lastCos_bbd * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S574>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cc = 0U;
  rtDW.Integ4_DSTATE_leb = 2.5E-6 * rtb_Product_p5i + rtDW.Integ4_cc;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */
  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S565>/cos(wt)' */
  HoldSine = rtDW.lastSin_gh;
  rtDW.lastSin_gh = rtDW.lastSin_gh * 0.99999822347173384 + rtDW.lastCos_lz *
    0.0018849544759281136;
  rtDW.lastCos_lz = rtDW.lastCos_lz * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S578>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ix = 0U;
  rtDW.Integ4_DSTATE_b = 2.5E-6 * rtb_Product1_mm + rtDW.Integ4_m3;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */
  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S565>/sin(wt)' */
  HoldSine = rtDW.lastSin_lo;
  rtDW.lastSin_lo = rtDW.lastSin_lo * 0.99999822347173384 + rtDW.lastCos_gsk *
    0.0018849544759281136;
  rtDW.lastCos_gsk = rtDW.lastCos_gsk * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S580>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jo = 0U;
  rtDW.Integ4_DSTATE_e5 = 2.5E-6 * rtb_Product_d3 + rtDW.Integ4_ocz;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */
  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S566>/cos(wt)' */
  HoldSine = rtDW.lastSin_fa;
  rtDW.lastSin_fa = rtDW.lastSin_fa * 0.99999822347173384 + rtDW.lastCos_hf *
    0.0018849544759281136;
  rtDW.lastCos_hf = rtDW.lastCos_hf * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S584>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bu = 0U;
  rtDW.Integ4_DSTATE_eb = 2.5E-6 * rtb_Product1_e5 + rtDW.Integ4_frw;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S585>/S-Function' incorporates:
   *  Constant: '<S584>/K1'
   */
  /* Level2 S-Function Block: '<S585>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S566>/sin(wt)' */
  HoldSine = rtDW.lastSin_lk;
  rtDW.lastSin_lk = rtDW.lastSin_lk * 0.99999822347173384 + rtDW.lastCos_ig *
    0.0018849544759281136;
  rtDW.lastCos_ig = rtDW.lastCos_ig * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S586>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i0 = 0U;
  rtDW.Integ4_DSTATE_cq = 2.5E-6 * rtb_Product_m + rtDW.Integ4_ah;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S587>/S-Function' incorporates:
   *  Constant: '<S586>/K1'
   */
  /* Level2 S-Function Block: '<S587>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S588>/cos(wt)' */
  HoldSine = rtDW.lastSin_gh2;
  rtDW.lastSin_gh2 = rtDW.lastSin_gh2 * 0.99999822347173384 + rtDW.lastCos_ew *
    0.0018849544759281136;
  rtDW.lastCos_ew = rtDW.lastCos_ew * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S596>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_af = 0U;
  rtDW.Integ4_DSTATE_hc = 2.5E-6 * rtb_Product1_d + rtDW.Integ4_jz;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S597>/S-Function' incorporates:
   *  Constant: '<S596>/K1'
   */
  /* Level2 S-Function Block: '<S597>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S588>/sin(wt)' */
  HoldSine = rtDW.lastSin_nr;
  rtDW.lastSin_nr = rtDW.lastSin_nr * 0.99999822347173384 + rtDW.lastCos_op *
    0.0018849544759281136;
  rtDW.lastCos_op = rtDW.lastCos_op * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S598>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ks = 0U;
  rtDW.Integ4_DSTATE_m3 = 2.5E-6 * rtb_Product_k + rtDW.Integ4_oe;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */
  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S589>/cos(wt)' */
  HoldSine = rtDW.lastSin_fxm;
  rtDW.lastSin_fxm = rtDW.lastSin_fxm * 0.99999822347173384 + rtDW.lastCos_h0 *
    0.0018849544759281136;
  rtDW.lastCos_h0 = rtDW.lastCos_h0 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S602>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fu = 0U;
  rtDW.Integ4_DSTATE_bo = 2.5E-6 * rtb_Product1_le + rtDW.Integ4_ea;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S603>/S-Function' incorporates:
   *  Constant: '<S602>/K1'
   */
  /* Level2 S-Function Block: '<S603>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S589>/sin(wt)' */
  HoldSine = rtDW.lastSin_o2f;
  rtDW.lastSin_o2f = rtDW.lastSin_o2f * 0.99999822347173384 + rtDW.lastCos_niz *
    0.0018849544759281136;
  rtDW.lastCos_niz = rtDW.lastCos_niz * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S604>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ns = 0U;
  rtDW.Integ4_DSTATE_jx = 2.5E-6 * rtb_Product_a + rtDW.Integ4_no;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */
  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S590>/cos(wt)' */
  HoldSine = rtDW.lastSin_p0;
  rtDW.lastSin_p0 = rtDW.lastSin_p0 * 0.99999822347173384 + rtDW.lastCos_fu *
    0.0018849544759281136;
  rtDW.lastCos_fu = rtDW.lastCos_fu * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S608>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_or = 0U;
  rtDW.Integ4_DSTATE_g5 = 2.5E-6 * rtb_Product1_e + rtDW.Integ4_ex;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S609>/S-Function' incorporates:
   *  Constant: '<S608>/K1'
   */
  /* Level2 S-Function Block: '<S609>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S590>/sin(wt)' */
  HoldSine = rtDW.lastSin_nx;
  rtDW.lastSin_nx = rtDW.lastSin_nx * 0.99999822347173384 + rtDW.lastCos_ez *
    0.0018849544759281136;
  rtDW.lastCos_ez = rtDW.lastCos_ez * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S610>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a0 = 0U;
  rtDW.Integ4_DSTATE_my = 2.5E-6 * rtb_Product_jv + rtDW.Integ4_ij;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S611>/S-Function' incorporates:
   *  Constant: '<S610>/K1'
   */
  /* Level2 S-Function Block: '<S611>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S662>/cos(wt)' */
  HoldSine = rtDW.lastSin_eb;
  rtDW.lastSin_eb = rtDW.lastSin_eb * 0.99999822347173384 + rtDW.lastCos_h2 *
    0.0018849544759281136;
  rtDW.lastCos_h2 = rtDW.lastCos_h2 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S670>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ic = 0U;
  rtDW.Integ4_DSTATE_pv = 2.5E-6 * rtb_Product1_br + rtDW.Integ4_fg;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S671>/S-Function' incorporates:
   *  Constant: '<S670>/K1'
   */
  /* Level2 S-Function Block: '<S671>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S662>/sin(wt)' */
  HoldSine = rtDW.lastSin_pc;
  rtDW.lastSin_pc = rtDW.lastSin_pc * 0.99999822347173384 + rtDW.lastCos_fuy *
    0.0018849544759281136;
  rtDW.lastCos_fuy = rtDW.lastCos_fuy * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S672>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bz = 0U;
  rtDW.Integ4_DSTATE_ij = 2.5E-6 * rtb_Product_kb + rtDW.Integ4_kv;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S673>/S-Function' incorporates:
   *  Constant: '<S672>/K1'
   */
  /* Level2 S-Function Block: '<S673>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S663>/cos(wt)' */
  HoldSine = rtDW.lastSin_ae;
  rtDW.lastSin_ae = rtDW.lastSin_ae * 0.99999822347173384 + rtDW.lastCos_kf *
    0.0018849544759281136;
  rtDW.lastCos_kf = rtDW.lastCos_kf * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S676>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ds = 0U;
  rtDW.Integ4_DSTATE_n2 = 2.5E-6 * rtb_Product1_ce + rtDW.Integ4_ks;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S677>/S-Function' incorporates:
   *  Constant: '<S676>/K1'
   */
  /* Level2 S-Function Block: '<S677>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S663>/sin(wt)' */
  HoldSine = rtDW.lastSin_mk;
  rtDW.lastSin_mk = rtDW.lastSin_mk * 0.99999822347173384 + rtDW.lastCos_pk *
    0.0018849544759281136;
  rtDW.lastCos_pk = rtDW.lastCos_pk * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S678>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ow = 0U;
  rtDW.Integ4_DSTATE_dy = 2.5E-6 * rtb_Product_pg + rtDW.Integ4_dl;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S679>/S-Function' incorporates:
   *  Constant: '<S678>/K1'
   */
  /* Level2 S-Function Block: '<S679>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S664>/cos(wt)' */
  HoldSine = rtDW.lastSin_pu;
  rtDW.lastSin_pu = rtDW.lastSin_pu * 0.99999822347173384 + rtDW.lastCos_bdo *
    0.0018849544759281136;
  rtDW.lastCos_bdo = rtDW.lastCos_bdo * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S682>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i1 = 0U;
  rtDW.Integ4_DSTATE_hd = 2.5E-6 * rtb_Product1_pz + rtDW.Integ4_kd;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S683>/S-Function' incorporates:
   *  Constant: '<S682>/K1'
   */
  /* Level2 S-Function Block: '<S683>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for Sin: '<S664>/sin(wt)' */
  HoldSine = rtDW.lastSin_cp;
  rtDW.lastSin_cp = rtDW.lastSin_cp * 0.99999822347173384 + rtDW.lastCos_k1 *
    0.0018849544759281136;
  rtDW.lastCos_k1 = rtDW.lastCos_k1 * 0.99999822347173384 - HoldSine *
    0.0018849544759281136;

  /* Update for DiscreteIntegrator: '<S684>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oo = 0U;
  rtDW.Integ4_DSTATE_pa = 2.5E-6 * rtb_Product_pk + rtDW.Integ4_id;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S685>/S-Function' incorporates:
   *  Constant: '<S684>/K1'
   */
  /* Level2 S-Function Block: '<S685>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S544>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_co = 0U;
  rtDW.Integ4_DSTATE_px = 2.5E-6 * rtb_Product2_tmp + rtDW.Integ4_ddl;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */
  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S540>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pb = 0U;
  rtDW.Integ4_DSTATE_exz = 2.5E-6 * rtb_sinwt + rtDW.Integ4_pt;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S541>/S-Function' incorporates:
   *  Constant: '<S540>/K1'
   */
  /* Level2 S-Function Block: '<S541>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for DiscreteIntegrator: '<S542>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bzw = 0U;
  rtDW.Integ4_DSTATE_hs = 2.5E-6 * rtb_Product1_g_tmp + rtDW.Integ4_pf;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */
  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnUpdate(rts,0);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update absolute time */
  /* The "clockTick0" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick0"
   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick0 and the high bits
   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++rtM->Timing.clockTick0)) {
    ++rtM->Timing.clockTickH0;
  }

  rtM->Timing.t[0] = rtM->Timing.clockTick0 * rtM->Timing.stepSize0 +
    rtM->Timing.clockTickH0 * rtM->Timing.stepSize0 * 4294967296.0;
}

/* Model step function for TID1 */
void power_converters_switching_function_step1(void) /* Sample time: [5.0E-5s, 0.0s] */
{
  real_T rtb_Gain_o3;
  real_T rtb_Product2_ft;
  real_T rtb_Gain1_pe[3];
  boolean_T rtb_RelationalOperator_dk;
  real_T rtb_Gain_eb;
  real_T rtb_Add3_d;
  boolean_T rtb_RelationalOperator_hg;
  real_T tmp;
  real_T rtb_ComplextoRealImag_o2;
  real_T rtb_DigitalClock;
  real_T rtb_DiscreteTimeIntegrator_k;
  real_T rtb_RateLimiter;
  real_T rtb_Saturation1;
  real_T rtb_sum3;
  real_T rtb_Saturation2;
  real_T rtb_Switch_i;
  real_T rtb_RoundingFunction_l;
  real_T rtb_RoundingFunction_k;
  real_T Initial;
  real_T Initial_a;
  real_T Divide_e;
  int32_T i;
  real_T rtb_sum3_h_idx_1;
  real_T rtb_sum3_h_idx_0;
  real_T rtb_sum3_hq_idx_0;
  real_T rtb_yk_h_idx_1;
  real_T rtb_yk_h_idx_0;
  real_T rtb_yk_m_idx_0;
  real_T rtb_RealImagtoComplex_re;
  real_T rtb_RealImagtoComplex_im;

  /* Gain: '<S197>/Gain' incorporates:
   *  Constant: '<S83>/Vdc_ref_3L'
   *  RateTransition: '<S83>/Rate Transition5'
   *  Sum: '<S197>/Sum'
   */
  rtb_Gain_o3 = (rtDW.RateTransition5_Buffer - 1000.0) * 0.001;

  /* Sum: '<S254>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S254>/Discrete-Time Integrator'
   *  Gain: '<S254>/Kp4'
   */
  rtb_Product2_ft = 2.5 * rtb_Gain_o3 + rtDW.DiscreteTimeIntegrator_DSTATE_i;

  /* Saturate: '<S254>/Saturation2' */
  if (rtb_Product2_ft > 1.5) {
    rtb_Product2_ft = 1.5;
  } else {
    if (rtb_Product2_ft < -1.5) {
      rtb_Product2_ft = -1.5;
    }
  }

  /* End of Saturate: '<S254>/Saturation2' */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S256>/Gain1' incorporates:
     *  Gain: '<S256>/Gain3'
     *  Gain: '<S83>/I->pu2'
     *  RateTransition: '<S83>/Rate Transition6'
     */
    rtb_Gain1_pe[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (0.030618621784789721 * rtDW.RateTransition6_Buffer[2]) +
      (rtConstP.pooled30[i + 3] * (0.030618621784789721 *
      rtDW.RateTransition6_Buffer[1]) + 0.030618621784789721 *
       rtDW.RateTransition6_Buffer[0] * rtConstP.pooled30[i]));
  }

  /* RelationalOperator: '<S205>/Relational Operator' incorporates:
   *  Constant: '<S205>/Constant4'
   */
  rtb_RelationalOperator_dk = (rtDW.DiscreteTimeIntegrator_DSTATE_c >
    6.2831853071795862);

  /* InitialCondition: '<S205>/Initial' incorporates:
   *  Constant: '<S205>/Constant4'
   *  Sum: '<S205>/Subtract'
   */
  if (rtDW.Initial_FirstOutputTime) {
    rtDW.Initial_FirstOutputTime = false;
    Initial = 0.0;
  } else {
    Initial = rtDW.DiscreteTimeIntegrator_DSTATE_c - 6.2831853071795862;
  }

  /* End of InitialCondition: '<S205>/Initial' */

  /* DiscreteIntegrator: '<S205>/Discrete-Time Integrator' */
  if (rtb_RelationalOperator_dk && (rtDW.DiscreteTimeIntegrator_PrevRese <= 0))
  {
    rtDW.DiscreteTimeIntegrator_DSTATE_c = Initial;
  }

  /* Outputs for Enabled SubSystem: '<S255>/Subsystem1' */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_c,
             &rtDW.Fcn_g3, &rtDW.Fcn1_gm);

  /* End of Outputs for SubSystem: '<S255>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S255>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_py, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_jl,
                    &rtDW.Fcn1_on);

  /* End of Outputs for SubSystem: '<S255>/Subsystem - pi//2 delay' */

  /* Sum: '<S246>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S246>/D*u(k)'
   *  Gain: '<S249>/C11'
   *  Gain: '<S249>/C12'
   *  Sum: '<S249>/sum2'
   *  Switch: '<S255>/Switch'
   *  UnitDelay: '<S246>/Delay_x1'
   *  UnitDelay: '<S246>/Delay_x2'
   */
  rtb_yk_m_idx_0 = (4438.1999107119682 * rtDW.Delay_x1_DSTATE_i[0] +
                    0.074961614832529166 * rtDW.Delay_x2_DSTATE_p[0]) +
    0.037480807416264583 * rtDW.Fcn_jl;
  Initial = (4438.1999107119682 * rtDW.Delay_x1_DSTATE_i[1] +
             0.074961614832529166 * rtDW.Delay_x2_DSTATE_p[1]) +
    0.037480807416264583 * rtDW.Fcn1_on;

  /* Outport: '<Root>/Out11' */
  //rtY.3LId[0] = rtb_Product2_ft;
  //rtY.3LId[1] = rtb_yk_m_idx_0;
  rtY._3LId[0] = rtb_Product2_ft;
  rtY._3LId[1] = rtb_yk_m_idx_0;

  /* Outport: '<Root>/Out12' */
  //rtY.3LIq = Initial;
  rtY._3LIq = Initial;

  /* Outport: '<Root>/Out13' incorporates:
   *  Math: '<S83>/Math Function'
   *  RateTransition: '<S83>/Rate Transition1'
   */
  //rtY.3Lm = rt_hypotd_snf(rtDW.RateTransition1_Buffer[0],
  //  rtDW.RateTransition1_Buffer[1]);
  rtY._3Lm = rt_hypotd_snf(rtDW.RateTransition1_Buffer[0],
    rtDW.RateTransition1_Buffer[1]);

  /* Gain: '<S273>/Gain' incorporates:
   *  Constant: '<S84>/Vdc_ref_stat'
   *  RateTransition: '<S84>/Rate Transition5'
   *  Sum: '<S273>/Sum'
   */
  rtb_Gain_eb = (rtDW.RateTransition5_Buffer_a - 2400.0) *
    0.00041666666666666669;

  /* Sum: '<S333>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S333>/Discrete-Time Integrator'
   *  Gain: '<S333>/Kp4'
   */
  rtb_Add3_d = 10.0 * rtb_Gain_eb + rtDW.DiscreteTimeIntegrator_DSTATE_j;

  /* Saturate: '<S333>/Saturation2' */
  if (rtb_Add3_d > 1.5) {
    rtb_Add3_d = 1.5;
  } else {
    if (rtb_Add3_d < -1.5) {
      rtb_Add3_d = -1.5;
    }
  }

  /* End of Saturate: '<S333>/Saturation2' */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S335>/Gain1' incorporates:
     *  Gain: '<S335>/Gain3'
     *  Gain: '<S84>/I->pu2'
     *  RateTransition: '<S84>/Rate Transition6'
     */
    rtb_Gain1_pe[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (0.015309310892394861 * rtDW.RateTransition6_Buffer_d[2]) +
      (rtConstP.pooled30[i + 3] * (0.015309310892394861 *
      rtDW.RateTransition6_Buffer_d[1]) + 0.015309310892394861 *
       rtDW.RateTransition6_Buffer_d[0] * rtConstP.pooled30[i]));
  }

  /* RelationalOperator: '<S284>/Relational Operator' incorporates:
   *  Constant: '<S284>/Constant4'
   */
  rtb_RelationalOperator_hg = (rtDW.DiscreteTimeIntegrator_DSTATE_o >
    6.2831853071795862);

  /* InitialCondition: '<S284>/Initial' incorporates:
   *  Constant: '<S284>/Constant4'
   *  Sum: '<S284>/Subtract'
   */
  if (rtDW.Initial_FirstOutputTime_m) {
    rtDW.Initial_FirstOutputTime_m = false;
    Initial_a = 0.0;
  } else {
    Initial_a = rtDW.DiscreteTimeIntegrator_DSTATE_o - 6.2831853071795862;
  }

  /* End of InitialCondition: '<S284>/Initial' */

  /* DiscreteIntegrator: '<S284>/Discrete-Time Integrator' */
  if (rtb_RelationalOperator_hg && (rtDW.DiscreteTimeIntegrator_PrevRe_g <= 0))
  {
    rtDW.DiscreteTimeIntegrator_DSTATE_o = Initial_a;
  }

  /* Outputs for Enabled SubSystem: '<S334>/Subsystem1' */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_o,
             &rtDW.Fcn_j, &rtDW.Fcn1_i);

  /* End of Outputs for SubSystem: '<S334>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S334>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_nf, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_d,
                    &rtDW.Fcn1_j);

  /* End of Outputs for SubSystem: '<S334>/Subsystem - pi//2 delay' */

  /* Sum: '<S325>/C*X(k)+D*u(k)' incorporates:
   *  Gain: '<S325>/D*u(k)'
   *  Gain: '<S328>/C11'
   *  Gain: '<S328>/C12'
   *  Sum: '<S328>/sum2'
   *  Switch: '<S334>/Switch'
   *  UnitDelay: '<S325>/Delay_x1'
   *  UnitDelay: '<S325>/Delay_x2'
   */
  rtb_yk_h_idx_0 = (4438.1999107119682 * rtDW.Delay_x1_DSTATE_pm[0] +
                    0.074961614832529166 * rtDW.Delay_x2_DSTATE_d[0]) +
    0.037480807416264583 * rtDW.Fcn_d;
  rtb_yk_h_idx_1 = (4438.1999107119682 * rtDW.Delay_x1_DSTATE_pm[1] +
                    0.074961614832529166 * rtDW.Delay_x2_DSTATE_d[1]) +
    0.037480807416264583 * rtDW.Fcn1_j;

  /* Outport: '<Root>/Out26' */
  rtY.statId[0] = rtb_Add3_d;
  rtY.statId[1] = rtb_yk_h_idx_0;

  /* Outputs for Enabled SubSystem: '<S205>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S206>/Enable'
   */
  /* Outputs for Enabled SubSystem: '<S284>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S285>/Enable'
   */
  /* Step: '<Root>/Statcom Qref (var)' incorporates:
   *  DigitalClock: '<S215>/Digital  Clock'
   *  DigitalClock: '<S218>/Digital  Clock'
   *  DigitalClock: '<S231>/Digital  Clock'
   *  DigitalClock: '<S280>/Digital  Clock'
   *  DigitalClock: '<S294>/Digital  Clock'
   *  DigitalClock: '<S297>/Digital  Clock'
   *  DigitalClock: '<S310>/Digital  Clock'
   *  Step: '<Root>/wref_motor'
   */
  Divide_e = rtM->Timing.t[1];

  /* End of Outputs for SubSystem: '<S284>/Automatic Gain Control' */
  /* End of Outputs for SubSystem: '<S205>/Automatic Gain Control' */
  if (Divide_e < 0.6) {
    i = -1000000;
  } else {
    i = 1500000;
  }

  /* End of Step: '<Root>/Statcom Qref (var)' */

  /* Gain: '<S84>/Mvar->pu' */
  Initial_a = 5.0E-7 * (real_T)i;

  /* RateLimiter: '<S268>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = Initial_a - rtDW.PrevY;
  if (rtb_DiscreteTimeIntegrator_k > 0.006) {
    Initial_a = rtDW.PrevY + 0.006;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.006) {
      Initial_a = rtDW.PrevY + -0.006;
    }
  }

  rtDW.PrevY = Initial_a;

  /* End of RateLimiter: '<S268>/Rate Limiter' */

  /* Fcn: '<S268>/Mag_V ' incorporates:
   *  Switch: '<S334>/Switch'
   */
  tmp = rtDW.Fcn_d * rtDW.Fcn_d + rtDW.Fcn1_j * rtDW.Fcn1_j;
  if (tmp < 0.0) {
    tmp = -sqrt(-tmp);
  } else {
    tmp = sqrt(tmp);
  }

  /* DiscreteIntegrator: '<S280>/Integ4' incorporates:
   *  Fcn: '<S268>/Mag_V '
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ei != 0) {
    rtDW.Integ4_j0 = rtDW.Integ4_DSTATE_gg;
  } else {
    rtDW.Integ4_j0 = 2.5E-5 * tmp + rtDW.Integ4_DSTATE_gg;
  }

  /* End of DiscreteIntegrator: '<S280>/Integ4' */

  /* S-Function (sfun_discreteVariableDelay): '<S281>/S-Function' incorporates:
   *  Constant: '<S280>/K1'
   */

  /* Level2 S-Function Block: '<S281>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S280>/Switch' incorporates:
   *  Constant: '<S280>/K1'
   *  Constant: '<S280>/K2'
   *  Fcn: '<S268>/Mag_V '
   *  Gain: '<S280>/Gain'
   *  Gain: '<S280>/Gain1'
   *  Product: '<S280>/Product'
   *  RelationalOperator: '<S280>/Relational Operator'
   *  Sum: '<S280>/Sum1'
   *  Sum: '<S280>/Sum5'
   *  Sum: '<S280>/Sum7'
   *  UnitDelay: '<S280>/Unit Delay'
   *  UnitDelay: '<S280>/Unit Delay1'
   */
  if (Divide_e >= 0.0167) {
    rtb_Switch_i = (rtDW.Integ4_j0 - rtDW.SFunction_m) * 60.0 +
      (-0.0013333333333333522 * tmp - 0.00066666666666670459 *
       rtDW.UnitDelay_DSTATE_pj);
  } else {
    rtb_Switch_i = rtDW.UnitDelay1_DSTATE_ai;
  }

  /* End of Switch: '<S280>/Switch' */

  /* Saturate: '<S268>/Saturation' */
  if (rtb_Switch_i <= 2.2204460492503131E-16) {
    rtb_DigitalClock = 2.2204460492503131E-16;
  } else {
    rtb_DigitalClock = rtb_Switch_i;
  }

  /* End of Saturate: '<S268>/Saturation' */

  /* Gain: '<S268>/Deg->Rad1' incorporates:
   *  Product: '<S268>/Product'
   */
  rtb_ComplextoRealImag_o2 = -(Initial_a / rtb_DigitalClock);

  /* Saturate: '<S268>/-1<Iq<+1' */
  if (rtb_ComplextoRealImag_o2 > 1.0) {
    rtb_ComplextoRealImag_o2 = 1.0;
  } else {
    if (rtb_ComplextoRealImag_o2 < -1.0) {
      rtb_ComplextoRealImag_o2 = -1.0;
    }
  }

  /* End of Saturate: '<S268>/-1<Iq<+1' */

  /* Outport: '<Root>/Out27' */
  rtY.statIq[0] = rtb_ComplextoRealImag_o2;
  rtY.statIq[1] = rtb_yk_h_idx_1;

  /* Outport: '<Root>/Out28' incorporates:
   *  Math: '<S84>/Math Function'
   *  RateTransition: '<S84>/Rate Transition1'
   */
  rtY.statm = rt_hypotd_snf(rtDW.RateTransition1_Buffer_n[0],
    rtDW.RateTransition1_Buffer_n[1]);

  /* Step: '<Root>/wref_motor' */
  if (Divide_e < 0.5) {
    Initial_a = 1200.0;
  } else {
    Initial_a = 800.0;
  }

  /* RateLimiter: '<S75>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = Initial_a - rtDW.PrevY_k;
  if (rtb_DiscreteTimeIntegrator_k > 0.1) {
    Initial_a = rtDW.PrevY_k + 0.1;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.1) {
      Initial_a = rtDW.PrevY_k + -0.1;
    }
  }

  rtDW.PrevY_k = Initial_a;

  /* End of RateLimiter: '<S75>/Rate Limiter' */

  /* Sum: '<S75>/Sum7' incorporates:
   *  RateTransition: '<S75>/Rate Transition1'
   */
  Initial_a -= rtDW.RateTransition1_Buffer_b;

  /* Sum: '<S86>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S86>/Discrete-Time Integrator'
   *  Gain: '<S86>/Kp4'
   */
  rtb_DigitalClock = 15.0 * Initial_a + rtDW.DiscreteTimeIntegrator_DSTAT_oe;

  /* Saturate: '<S86>/Saturation2' */
  if (rtb_DigitalClock > 1000.0) {
    rtb_DigitalClock = 1000.0;
  } else {
    if (rtb_DigitalClock < -1000.0) {
      rtb_DigitalClock = -1000.0;
    }
  }

  /* End of Saturate: '<S86>/Saturation2' */

  /* RateLimiter: '<S75>/Rate Limiter1' */
  rtb_DiscreteTimeIntegrator_k = rtb_DigitalClock - rtDW.PrevY_n;
  if (rtb_DiscreteTimeIntegrator_k > 1.0) {
    rtb_DigitalClock = rtDW.PrevY_n + 1.0;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -1.0) {
      rtb_DigitalClock = rtDW.PrevY_n + -1.0;
    }
  }

  rtDW.PrevY_n = rtb_DigitalClock;

  /* End of RateLimiter: '<S75>/Rate Limiter1' */

  /* Outport: '<Root>/Out34' incorporates:
   *  RateTransition: '<Root>/Rate Transition1'
   */
  rtY.Imotor[0] = rtb_DigitalClock;
  rtY.Imotor[1] = rtDW.RateTransition1_Buffer_p;

  /* Outport: '<Root>/Out35' incorporates:
   *  RateTransition: '<Root>/Rate Transition2'
   */
  rtY.D_motor = rtDW.RateTransition2_Buffer;

  /* Outputs for Enabled SubSystem: '<S284>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S285>/Enable'
   */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S320>/Gain1' incorporates:
     *  Gain: '<S269>/V->pu1'
     *  Gain: '<S301>/Gain1'
     *  Gain: '<S314>/Gain1'
     *  Gain: '<S320>/Gain3'
     *  RateTransition: '<S84>/Rate Transition2'
     */
    rtb_Gain1_pe[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (4.8989794855663556E-5 * rtDW.RateTransition2_Buffer_g[2]) +
      (rtConstP.pooled30[i + 3] * (4.8989794855663556E-5 *
      rtDW.RateTransition2_Buffer_g[1]) + 4.8989794855663556E-5 *
       rtDW.RateTransition2_Buffer_g[0] * rtConstP.pooled30[i]));
  }

  /* End of Outputs for SubSystem: '<S284>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S319>/Subsystem1' */
  /* Gain: '<S320>/Gain1' incorporates:
   *  DiscreteIntegrator: '<S284>/Discrete-Time Integrator'
   */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_o,
             &rtDW.Fcn_m, &rtDW.Fcn1_k);

  /* End of Outputs for SubSystem: '<S319>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S319>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_g, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_g,
                    &rtDW.Fcn1_c);

  /* End of Outputs for SubSystem: '<S319>/Subsystem - pi//2 delay' */

  /* Sum: '<S267>/Sum' */
  rtb_DiscreteTimeIntegrator_k = rtb_Add3_d - rtb_yk_h_idx_0;

  /* Gain: '<S267>/Rtot_pu3' incorporates:
   *  UnitDelay: '<S284>/Unit Delay'
   */
  rtb_RateLimiter = 0.016666666666666666 * rtDW.UnitDelay_DSTATE_cn4;

  /* Sum: '<S277>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S277>/Discrete-Time Integrator'
   *  Gain: '<S277>/Kp4'
   */
  rtb_RealImagtoComplex_im = 0.35 * rtb_DiscreteTimeIntegrator_k +
    rtDW.DiscreteTimeIntegrator_DSTAT_ju;

  /* Saturate: '<S277>/Saturation2' */
  if (rtb_RealImagtoComplex_im > 1.5) {
    rtb_RealImagtoComplex_im = 1.5;
  } else {
    if (rtb_RealImagtoComplex_im < -1.5) {
      rtb_RealImagtoComplex_im = -1.5;
    }
  }

  /* End of Saturate: '<S277>/Saturation2' */

  /* Sum: '<S267>/Add1' incorporates:
   *  Constant: '<S267>/Constant2'
   *  Gain: '<S267>/Gain'
   *  Product: '<S267>/Product1'
   *  Switch: '<S319>/Switch'
   */
  rtb_yk_h_idx_0 = ((rtDW.Fcn_g + rtb_RealImagtoComplex_im) +
                    0.0031999999999999997 * rtb_Add3_d) -
    rtb_ComplextoRealImag_o2 * 0.18 * rtb_RateLimiter;

  /* Sum: '<S267>/Sum1' */
  rtb_yk_h_idx_1 = rtb_ComplextoRealImag_o2 - rtb_yk_h_idx_1;

  /* Gain: '<S267>/Gain1' */
  rtb_ComplextoRealImag_o2 *= 0.0031999999999999997;

  /* Product: '<S267>/Product2' incorporates:
   *  Constant: '<S267>/Constant1'
   */
  rtb_Add3_d = rtb_Add3_d * 0.18 * rtb_RateLimiter;

  /* Sum: '<S278>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S278>/Discrete-Time Integrator'
   *  Gain: '<S278>/Kp4'
   */
  rtb_RealImagtoComplex_im = 0.35 * rtb_yk_h_idx_1 +
    rtDW.DiscreteTimeIntegrator_DSTATE_k;

  /* Saturate: '<S278>/Saturation2' */
  if (rtb_RealImagtoComplex_im > 1.5) {
    rtb_RealImagtoComplex_im = 1.5;
  } else {
    if (rtb_RealImagtoComplex_im < -1.5) {
      rtb_RealImagtoComplex_im = -1.5;
    }
  }

  /* End of Saturate: '<S278>/Saturation2' */

  /* RealImagToComplex: '<S276>/Real-Imag to Complex' incorporates:
   *  Sum: '<S267>/Add3'
   *  Switch: '<S319>/Switch'
   */
  rtb_RealImagtoComplex_im = ((rtDW.Fcn1_c + rtb_RealImagtoComplex_im) +
    rtb_ComplextoRealImag_o2) + rtb_Add3_d;

  /* Sum: '<S276>/Sum2' incorporates:
   *  ComplexToMagnitudeAngle: '<S276>/Complex to Magnitude-Angle'
   *  Constant: '<S276>/Constant3'
   *  RealImagToComplex: '<S276>/Real-Imag to Complex'
   */
  rtb_RateLimiter = rt_atan2d_snf(rtb_RealImagtoComplex_im, rtb_yk_h_idx_0) +
    0.018849555921538759;

  /* MagnitudeAngleToComplex: '<S276>/Magnitude-Angle to Complex' incorporates:
   *  ComplexToMagnitudeAngle: '<S276>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S276>/Real-Imag to Complex'
   */
  rtb_RealImagtoComplex_im = rt_hypotd_snf(rtb_yk_h_idx_0,
    rtb_RealImagtoComplex_im);
  rtb_RealImagtoComplex_re = rtb_RealImagtoComplex_im * cos(rtb_RateLimiter);
  rtb_RealImagtoComplex_im *= sin(rtb_RateLimiter);

  /* Gain: '<S277>/Kp5' */
  rtb_Add3_d = 80.0 * rtb_DiscreteTimeIntegrator_k;

  /* Saturate: '<S267>/Saturation' incorporates:
   *  ComplexToRealImag: '<S276>/Complex to Real-Imag'
   */
  if (rtb_RealImagtoComplex_re > 1.5) {
    /* Update for RateTransition: '<S84>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[0] = 1.5;
  } else if (rtb_RealImagtoComplex_re < -1.5) {
    /* Update for RateTransition: '<S84>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[0] = -1.5;
  } else {
    /* Update for RateTransition: '<S84>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[0] = rtb_RealImagtoComplex_re;
  }

  if (rtb_RealImagtoComplex_im > 1.5) {
    /* Update for RateTransition: '<S84>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[1] = 1.5;
  } else if (rtb_RealImagtoComplex_im < -1.5) {
    /* Update for RateTransition: '<S84>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[1] = -1.5;
  } else {
    /* Update for RateTransition: '<S84>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0_a[1] = rtb_RealImagtoComplex_im;
  }

  /* End of Saturate: '<S267>/Saturation' */

  /* Outputs for Enabled SubSystem: '<S284>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S285>/Enable'
   */
  if (!rtDW.AutomaticGainControl_MODE) {
    /* Enable for DiscreteIntegrator: '<S294>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_oq = 1U;

    /* Enable for DiscreteIntegrator: '<S297>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ez = 1U;
    rtDW.AutomaticGainControl_MODE = true;
  }

  /* Outputs for Enabled SubSystem: '<S300>/Subsystem1' */
  /* DiscreteIntegrator: '<S284>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_o,
             &rtDW.Fcn_m5, &rtDW.Fcn1_g1);

  /* End of Outputs for SubSystem: '<S300>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S300>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_i, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtDW.Fcn_c,
                    &rtDW.Fcn1_d);

  /* End of Outputs for SubSystem: '<S300>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S294>/Integ4' incorporates:
   *  Switch: '<S300>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_oq != 0) {
    rtDW.Integ4_cs = rtDW.Integ4_DSTATE_md;
  } else {
    rtDW.Integ4_cs = 2.5E-5 * rtDW.Fcn_c + rtDW.Integ4_DSTATE_md;
  }

  /* End of DiscreteIntegrator: '<S294>/Integ4' */

  /* Saturate: '<S294>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_cn4 > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_cn4 < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_cn4;
  }

  /* End of Saturate: '<S294>/To avoid division  by zero' */

  /* Fcn: '<S294>/Number of samples per cycle' */
  rtb_yk_h_idx_0 = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S294>/Rounding Function' */
  rtb_RoundingFunction_l = ceil(rtb_yk_h_idx_0);

  /* Gain: '<S294>/Gain' */
  rtDW.Delay_f = 5.0E-5 * rtb_RoundingFunction_l;

  /* S-Function (sfun_discreteVariableDelay): '<S296>/S-Function' */

  /* Level2 S-Function Block: '<S296>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S294>/Switch' incorporates:
   *  Constant: '<S294>/Constant'
   *  Gain: '<S295>/Gain1'
   *  Product: '<S294>/Product'
   *  Product: '<S295>/Product2'
   *  Product: '<S295>/Product4'
   *  Product: '<S295>/Product5'
   *  RelationalOperator: '<S294>/Relational Operator'
   *  Sum: '<S294>/Sum5'
   *  Sum: '<S294>/Sum7'
   *  Sum: '<S295>/Sum1'
   *  Sum: '<S295>/Sum4'
   *  Switch: '<S300>/Switch'
   *  UnitDelay: '<S284>/Unit Delay'
   *  UnitDelay: '<S294>/Unit Delay1'
   *  UnitDelay: '<S295>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S295>/Sum5' */
    rtb_RoundingFunction_l = rtb_yk_h_idx_0 - rtb_RoundingFunction_l;
    rtb_RoundingFunction_l = ((rtDW.Fcn_c - rtDW.UnitDelay_DSTATE_kr) *
      rtb_RoundingFunction_l * 0.5 + rtDW.Fcn_c) * (rtb_RoundingFunction_l /
      rtb_yk_h_idx_0) + (rtDW.Integ4_cs - rtDW.SFunction_d4) *
      rtDW.UnitDelay_DSTATE_cn4;
  } else {
    rtb_RoundingFunction_l = rtDW.UnitDelay1_DSTATE_hp;
  }

  /* End of Switch: '<S294>/Switch' */

  /* DiscreteIntegrator: '<S297>/Integ4' incorporates:
   *  Switch: '<S300>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ez != 0) {
    rtDW.Integ4_ha = rtDW.Integ4_DSTATE_e5y;
  } else {
    rtDW.Integ4_ha = 2.5E-5 * rtDW.Fcn1_d + rtDW.Integ4_DSTATE_e5y;
  }

  /* End of DiscreteIntegrator: '<S297>/Integ4' */

  /* Saturate: '<S297>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_cn4 > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_cn4 < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_cn4;
  }

  /* End of Saturate: '<S297>/To avoid division  by zero' */

  /* Fcn: '<S297>/Number of samples per cycle' */
  rtb_yk_h_idx_0 = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S297>/Rounding Function' */
  rtb_RoundingFunction_k = ceil(rtb_yk_h_idx_0);

  /* Gain: '<S297>/Gain' */
  rtDW.Delay_l = 5.0E-5 * rtb_RoundingFunction_k;

  /* S-Function (sfun_discreteVariableDelay): '<S299>/S-Function' */

  /* Level2 S-Function Block: '<S299>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S297>/Switch' incorporates:
   *  Constant: '<S297>/Constant'
   *  Gain: '<S298>/Gain1'
   *  Product: '<S297>/Product'
   *  Product: '<S298>/Product2'
   *  Product: '<S298>/Product4'
   *  Product: '<S298>/Product5'
   *  RelationalOperator: '<S297>/Relational Operator'
   *  Sum: '<S297>/Sum5'
   *  Sum: '<S297>/Sum7'
   *  Sum: '<S298>/Sum1'
   *  Sum: '<S298>/Sum4'
   *  Switch: '<S300>/Switch'
   *  UnitDelay: '<S284>/Unit Delay'
   *  UnitDelay: '<S297>/Unit Delay1'
   *  UnitDelay: '<S298>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S298>/Sum5' */
    rtb_RoundingFunction_k = rtb_yk_h_idx_0 - rtb_RoundingFunction_k;
    rtb_RoundingFunction_k = ((rtDW.Fcn1_d - rtDW.UnitDelay_DSTATE_ko) *
      rtb_RoundingFunction_k * 0.5 + rtDW.Fcn1_d) * (rtb_RoundingFunction_k /
      rtb_yk_h_idx_0) + (rtDW.Integ4_ha - rtDW.SFunction_e5) *
      rtDW.UnitDelay_DSTATE_cn4;
  } else {
    rtb_RoundingFunction_k = rtDW.UnitDelay1_DSTATE_j3;
  }

  /* End of Switch: '<S297>/Switch' */

  /* ComplexToMagnitudeAngle: '<S290>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S290>/Real-Imag to Complex'
   */
  rtb_yk_h_idx_0 = rt_hypotd_snf(rtb_RoundingFunction_l, rtb_RoundingFunction_k);

  /* Saturate: '<S285>/Saturation' */
  if (rtb_yk_h_idx_0 <= 2.2204460492503131E-16) {
    rtb_yk_h_idx_0 = 2.2204460492503131E-16;
  }

  /* End of Saturate: '<S285>/Saturation' */

  /* Math: '<S285>/Math Function'
   *
   * About '<S285>/Math Function':
   *  Operator: reciprocal
   */
  rtDW.MathFunction = 1.0 / rtb_yk_h_idx_0;

  /* Update for DiscreteIntegrator: '<S294>/Integ4' incorporates:
   *  Switch: '<S300>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_oq = 0U;
  rtDW.Integ4_DSTATE_md = 2.5E-5 * rtDW.Fcn_c + rtDW.Integ4_cs;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S296>/S-Function' */
  /* Level2 S-Function Block: '<S296>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S295>/Unit Delay' incorporates:
   *  Switch: '<S300>/Switch'
   */
  rtDW.UnitDelay_DSTATE_kr = rtDW.Fcn_c;

  /* Update for UnitDelay: '<S294>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_hp = rtb_RoundingFunction_l;

  /* Update for DiscreteIntegrator: '<S297>/Integ4' incorporates:
   *  Switch: '<S300>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_ez = 0U;
  rtDW.Integ4_DSTATE_e5y = 2.5E-5 * rtDW.Fcn1_d + rtDW.Integ4_ha;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S299>/S-Function' */
  /* Level2 S-Function Block: '<S299>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S298>/Unit Delay' incorporates:
   *  Switch: '<S300>/Switch'
   */
  rtDW.UnitDelay_DSTATE_ko = rtDW.Fcn1_d;

  /* Update for UnitDelay: '<S297>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_j3 = rtb_RoundingFunction_k;

  /* End of Outputs for SubSystem: '<S284>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S313>/Subsystem1' */
  /* DiscreteIntegrator: '<S284>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_o,
             &rtb_yk_h_idx_0, &rtDW.Fcn1_g);

  /* End of Outputs for SubSystem: '<S313>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S313>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_pj, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_o, &rtb_yk_h_idx_0,
                    &rtDW.Fcn1_b);

  /* End of Outputs for SubSystem: '<S313>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S310>/Integ4' incorporates:
   *  Switch: '<S313>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_nm != 0) {
    rtDW.Integ4_ll = rtDW.Integ4_DSTATE_ad;
  } else {
    rtDW.Integ4_ll = 2.5E-5 * rtDW.Fcn1_b + rtDW.Integ4_DSTATE_ad;
  }

  /* End of DiscreteIntegrator: '<S310>/Integ4' */

  /* Saturate: '<S310>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_cn4 > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_cn4 < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_cn4;
  }

  /* End of Saturate: '<S310>/To avoid division  by zero' */

  /* Fcn: '<S310>/Number of samples per cycle' */
  rtb_RoundingFunction_l = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S310>/Rounding Function' */
  rtb_RoundingFunction_k = ceil(rtb_RoundingFunction_l);

  /* Gain: '<S310>/Gain' */
  rtDW.Delay = 5.0E-5 * rtb_RoundingFunction_k;

  /* S-Function (sfun_discreteVariableDelay): '<S312>/S-Function' */

  /* Level2 S-Function Block: '<S312>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S310>/Switch' incorporates:
   *  Constant: '<S310>/Constant'
   *  Gain: '<S311>/Gain1'
   *  Product: '<S310>/Product'
   *  Product: '<S311>/Product2'
   *  Product: '<S311>/Product4'
   *  Product: '<S311>/Product5'
   *  RelationalOperator: '<S310>/Relational Operator'
   *  Sum: '<S310>/Sum5'
   *  Sum: '<S310>/Sum7'
   *  Sum: '<S311>/Sum1'
   *  Sum: '<S311>/Sum4'
   *  Switch: '<S313>/Switch'
   *  UnitDelay: '<S284>/Unit Delay'
   *  UnitDelay: '<S310>/Unit Delay1'
   *  UnitDelay: '<S311>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S311>/Sum5' */
    rtb_RoundingFunction_k = rtb_RoundingFunction_l - rtb_RoundingFunction_k;
    rtb_RoundingFunction_l = ((rtDW.Fcn1_b - rtDW.UnitDelay_DSTATE_c3) *
      rtb_RoundingFunction_k * 0.5 + rtDW.Fcn1_b) * (rtb_RoundingFunction_k /
      rtb_RoundingFunction_l) + (rtDW.Integ4_ll - rtDW.SFunction_ia) *
      rtDW.UnitDelay_DSTATE_cn4;
  } else {
    rtb_RoundingFunction_l = rtDW.UnitDelay1_DSTATE_o0e;
  }

  /* End of Switch: '<S310>/Switch' */

  /* Product: '<S284>/Divide' */
  rtb_RoundingFunction_k = rtb_RoundingFunction_l * rtDW.MathFunction;

  /* Sum: '<S286>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S286>/Discrete-Time Integrator'
   *  DiscreteTransferFcn: '<S286>/Discrete Derivative '
   *  Gain: '<S286>/Kp4'
   */
  rtb_yk_h_idx_0 = (90.0 * rtb_RoundingFunction_k +
                    rtDW.DiscreteTimeIntegrator_DSTATE_n) + -0.0 *
    rtDW.DiscreteDerivative_states;

  /* Saturate: '<S286>/Saturation1' */
  if (rtb_yk_h_idx_0 <= 0.0) {
    rtb_Saturation1 = 0.0;
  } else {
    rtb_Saturation1 = rtb_yk_h_idx_0;
  }

  /* End of Saturate: '<S286>/Saturation1' */

  /* Gain: '<S284>/Gain10' */
  rtb_yk_h_idx_0 = 0.15915494309189535 * rtb_Saturation1;

  /* RateLimiter: '<S284>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = rtb_yk_h_idx_0 - rtDW.PrevY_l;
  if (rtb_DiscreteTimeIntegrator_k > 0.00060000000000000006) {
    rtb_yk_h_idx_0 = rtDW.PrevY_l + 0.00060000000000000006;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.00060000000000000006) {
      rtb_yk_h_idx_0 = rtDW.PrevY_l + -0.00060000000000000006;
    }
  }

  rtDW.PrevY_l = rtb_yk_h_idx_0;

  /* End of RateLimiter: '<S284>/Rate Limiter' */

  /* Sum: '<S307>/sum3' incorporates:
   *  Gain: '<S307>/A21'
   *  Gain: '<S307>/A22'
   *  UnitDelay: '<S306>/Delay_x1'
   *  UnitDelay: '<S306>/Delay_x2'
   */
  rtb_sum3 = -1.226881692709296 * rtDW.Delay_x1_DSTATE_l + 0.988925236714054 *
    rtDW.Delay_x2_DSTATE_j;

  /* Sum: '<S326>/sum3' incorporates:
   *  Gain: '<S326>/A21'
   *  Gain: '<S326>/A22'
   *  UnitDelay: '<S325>/Delay_x1'
   *  UnitDelay: '<S325>/Delay_x2'
   */
  rtb_sum3_h_idx_0 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE_pm[0] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE_d[0];
  rtb_sum3_h_idx_1 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE_pm[1] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE_d[1];

  /* Sum: '<S75>/Sum6' incorporates:
   *  RateTransition: '<S75>/Rate Transition3'
   */
  rtb_DigitalClock -= rtDW.RateTransition3_Buffer;

  /* Sum: '<S85>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S85>/Discrete-Time Integrator'
   *  Gain: '<S85>/Kp4'
   */
  rtb_Saturation2 = 0.0015 * rtb_DigitalClock +
    rtDW.DiscreteTimeIntegrator_DSTAT_om;

  /* Saturate: '<S85>/Saturation2' */
  if (rtb_Saturation2 > 1.0) {
    rtb_Saturation2 = 1.0;
  } else {
    if (rtb_Saturation2 < 0.0) {
      rtb_Saturation2 = 0.0;
    }
  }

  /* End of Saturate: '<S85>/Saturation2' */

  /* Outputs for Enabled SubSystem: '<S205>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S206>/Enable'
   */
  for (i = 0; i < 3; i++) {
    /* Gain: '<S241>/Gain1' incorporates:
     *  Gain: '<S193>/V->pu1'
     *  Gain: '<S222>/Gain1'
     *  Gain: '<S235>/Gain1'
     *  Gain: '<S241>/Gain3'
     *  RateTransition: '<S83>/Rate Transition2'
     */
    rtb_Gain1_pe[i] = 0.66666666666666663 * (rtConstP.pooled30[i + 6] *
      (4.8989794855663556E-5 * rtDW.RateTransition2_Buffer_i[2]) +
      (rtConstP.pooled30[i + 3] * (4.8989794855663556E-5 *
      rtDW.RateTransition2_Buffer_i[1]) + 4.8989794855663556E-5 *
       rtDW.RateTransition2_Buffer_i[0] * rtConstP.pooled30[i]));
  }

  /* End of Outputs for SubSystem: '<S205>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S240>/Subsystem1' */
  /* Gain: '<S241>/Gain1' incorporates:
   *  DiscreteIntegrator: '<S205>/Discrete-Time Integrator'
   */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_c,
             &rtDW.Fcn_b, &rtDW.Fcn1_n);

  /* End of Outputs for SubSystem: '<S240>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S240>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_k, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_o,
                    &rtDW.Fcn1_om);

  /* End of Outputs for SubSystem: '<S240>/Subsystem - pi//2 delay' */

  /* Sum: '<S192>/Sum' */
  rtb_RateLimiter = rtb_Product2_ft - rtb_yk_m_idx_0;

  /* Gain: '<S192>/Rtot_pu3' incorporates:
   *  UnitDelay: '<S205>/Unit Delay'
   */
  rtb_ComplextoRealImag_o2 = 0.016666666666666666 * rtDW.UnitDelay_DSTATE_fu;

  /* Sum: '<S201>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S201>/Discrete-Time Integrator'
   *  Gain: '<S201>/Kp4'
   */
  rtb_RealImagtoComplex_im = 0.1 * rtb_RateLimiter +
    rtDW.DiscreteTimeIntegrator_DSTATE_e;

  /* Saturate: '<S201>/Saturation2' */
  if (rtb_RealImagtoComplex_im > 1.5) {
    rtb_RealImagtoComplex_im = 1.5;
  } else {
    if (rtb_RealImagtoComplex_im < -1.5) {
      rtb_RealImagtoComplex_im = -1.5;
    }
  }

  /* End of Saturate: '<S201>/Saturation2' */

  /* Sum: '<S192>/Add1' incorporates:
   *  Constant: '<S192>/Constant2'
   *  Constant: '<S83>/Iref'
   *  Gain: '<S192>/Gain'
   *  Product: '<S192>/Product1'
   *  Switch: '<S240>/Switch'
   */
  rtb_DiscreteTimeIntegrator_k = ((rtDW.Fcn_o + rtb_RealImagtoComplex_im) +
    0.0033333333333333335 * rtb_Product2_ft) - 0.0 * rtb_ComplextoRealImag_o2;

  /* Product: '<S192>/Product2' incorporates:
   *  Constant: '<S192>/Constant1'
   */
  rtb_Product2_ft = rtb_Product2_ft * 0.1 * rtb_ComplextoRealImag_o2;

  /* Sum: '<S202>/Sum6' incorporates:
   *  Constant: '<S83>/Iref'
   *  DiscreteIntegrator: '<S202>/Discrete-Time Integrator'
   *  Gain: '<S202>/Kp4'
   *  Sum: '<S192>/Sum1'
   */
  rtb_RealImagtoComplex_im = (0.0 - Initial) * 0.1 +
    rtDW.DiscreteTimeIntegrator_DSTATE_l;

  /* Saturate: '<S202>/Saturation2' */
  if (rtb_RealImagtoComplex_im > 1.5) {
    rtb_RealImagtoComplex_im = 1.5;
  } else {
    if (rtb_RealImagtoComplex_im < -1.5) {
      rtb_RealImagtoComplex_im = -1.5;
    }
  }

  /* End of Saturate: '<S202>/Saturation2' */

  /* RealImagToComplex: '<S200>/Real-Imag to Complex' incorporates:
   *  Sum: '<S192>/Add3'
   *  Switch: '<S240>/Switch'
   */
  rtb_RealImagtoComplex_im = (rtDW.Fcn1_om + rtb_RealImagtoComplex_im) +
    rtb_Product2_ft;

  /* Sum: '<S200>/Sum2' incorporates:
   *  ComplexToMagnitudeAngle: '<S200>/Complex to Magnitude-Angle'
   *  Constant: '<S200>/Constant3'
   *  RealImagToComplex: '<S200>/Real-Imag to Complex'
   */
  rtb_ComplextoRealImag_o2 = rt_atan2d_snf(rtb_RealImagtoComplex_im,
    rtb_DiscreteTimeIntegrator_k) + -0.50474921967676;

  /* MagnitudeAngleToComplex: '<S200>/Magnitude-Angle to Complex' incorporates:
   *  ComplexToMagnitudeAngle: '<S200>/Complex to Magnitude-Angle'
   *  RealImagToComplex: '<S200>/Real-Imag to Complex'
   */
  rtb_RealImagtoComplex_im = rt_hypotd_snf(rtb_DiscreteTimeIntegrator_k,
    rtb_RealImagtoComplex_im);
  rtb_RealImagtoComplex_re = rtb_RealImagtoComplex_im * cos
    (rtb_ComplextoRealImag_o2);
  rtb_RealImagtoComplex_im *= sin(rtb_ComplextoRealImag_o2);

  /* Gain: '<S201>/Kp5' */
  rtb_Product2_ft = 8.0 * rtb_RateLimiter;

  /* Outputs for Enabled SubSystem: '<S205>/Automatic Gain Control' incorporates:
   *  EnablePort: '<S206>/Enable'
   */
  if (!rtDW.AutomaticGainControl_MODE_p) {
    /* Enable for DiscreteIntegrator: '<S215>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ck = 1U;

    /* Enable for DiscreteIntegrator: '<S218>/Integ4' */
    rtDW.Integ4_SYSTEM_ENABLE_ly = 1U;
    rtDW.AutomaticGainControl_MODE_p = true;
  }

  /* Outputs for Enabled SubSystem: '<S221>/Subsystem1' */
  /* DiscreteIntegrator: '<S205>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_c,
             &rtDW.Fcn_a, &rtDW.Fcn1_l);

  /* End of Outputs for SubSystem: '<S221>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S221>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_au, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtDW.Fcn_p,
                    &rtDW.Fcn1_h);

  /* End of Outputs for SubSystem: '<S221>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S215>/Integ4' incorporates:
   *  Switch: '<S221>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ck != 0) {
    rtDW.Integ4_cu = rtDW.Integ4_DSTATE_o3;
  } else {
    rtDW.Integ4_cu = 2.5E-5 * rtDW.Fcn_p + rtDW.Integ4_DSTATE_o3;
  }

  /* End of DiscreteIntegrator: '<S215>/Integ4' */

  /* Saturate: '<S215>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_fu > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_fu < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_fu;
  }

  /* End of Saturate: '<S215>/To avoid division  by zero' */

  /* Fcn: '<S215>/Number of samples per cycle' */
  rtb_RateLimiter = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S215>/Rounding Function' */
  rtb_DiscreteTimeIntegrator_k = ceil(rtb_RateLimiter);

  /* Gain: '<S215>/Gain' */
  rtDW.Delay_ou = 5.0E-5 * rtb_DiscreteTimeIntegrator_k;

  /* S-Function (sfun_discreteVariableDelay): '<S217>/S-Function' */

  /* Level2 S-Function Block: '<S217>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S215>/Switch' incorporates:
   *  Constant: '<S215>/Constant'
   *  Gain: '<S216>/Gain1'
   *  Product: '<S215>/Product'
   *  Product: '<S216>/Product2'
   *  Product: '<S216>/Product4'
   *  Product: '<S216>/Product5'
   *  RelationalOperator: '<S215>/Relational Operator'
   *  Sum: '<S215>/Sum5'
   *  Sum: '<S215>/Sum7'
   *  Sum: '<S216>/Sum1'
   *  Sum: '<S216>/Sum4'
   *  Switch: '<S221>/Switch'
   *  UnitDelay: '<S205>/Unit Delay'
   *  UnitDelay: '<S215>/Unit Delay1'
   *  UnitDelay: '<S216>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S216>/Sum5' */
    rtb_DiscreteTimeIntegrator_k = rtb_RateLimiter -
      rtb_DiscreteTimeIntegrator_k;
    rtb_DiscreteTimeIntegrator_k = ((rtDW.Fcn_p - rtDW.UnitDelay_DSTATE_c2) *
      rtb_DiscreteTimeIntegrator_k * 0.5 + rtDW.Fcn_p) *
      (rtb_DiscreteTimeIntegrator_k / rtb_RateLimiter) + (rtDW.Integ4_cu -
      rtDW.SFunction_lp) * rtDW.UnitDelay_DSTATE_fu;
  } else {
    rtb_DiscreteTimeIntegrator_k = rtDW.UnitDelay1_DSTATE_ia;
  }

  /* End of Switch: '<S215>/Switch' */

  /* DiscreteIntegrator: '<S218>/Integ4' incorporates:
   *  Switch: '<S221>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_ly != 0) {
    rtDW.Integ4_dh0 = rtDW.Integ4_DSTATE_ei;
  } else {
    rtDW.Integ4_dh0 = 2.5E-5 * rtDW.Fcn1_h + rtDW.Integ4_DSTATE_ei;
  }

  /* End of DiscreteIntegrator: '<S218>/Integ4' */

  /* Saturate: '<S218>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_fu > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_fu < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_fu;
  }

  /* End of Saturate: '<S218>/To avoid division  by zero' */

  /* Fcn: '<S218>/Number of samples per cycle' */
  rtb_RateLimiter = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S218>/Rounding Function' */
  rtb_ComplextoRealImag_o2 = ceil(rtb_RateLimiter);

  /* Gain: '<S218>/Gain' */
  rtDW.Delay_lg = 5.0E-5 * rtb_ComplextoRealImag_o2;

  /* S-Function (sfun_discreteVariableDelay): '<S220>/S-Function' */

  /* Level2 S-Function Block: '<S220>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S218>/Switch' incorporates:
   *  Constant: '<S218>/Constant'
   *  Gain: '<S219>/Gain1'
   *  Product: '<S218>/Product'
   *  Product: '<S219>/Product2'
   *  Product: '<S219>/Product4'
   *  Product: '<S219>/Product5'
   *  RelationalOperator: '<S218>/Relational Operator'
   *  Sum: '<S218>/Sum5'
   *  Sum: '<S218>/Sum7'
   *  Sum: '<S219>/Sum1'
   *  Sum: '<S219>/Sum4'
   *  Switch: '<S221>/Switch'
   *  UnitDelay: '<S205>/Unit Delay'
   *  UnitDelay: '<S218>/Unit Delay1'
   *  UnitDelay: '<S219>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S219>/Sum5' */
    rtb_ComplextoRealImag_o2 = rtb_RateLimiter - rtb_ComplextoRealImag_o2;
    rtb_ComplextoRealImag_o2 = ((rtDW.Fcn1_h - rtDW.UnitDelay_DSTATE_m0) *
      rtb_ComplextoRealImag_o2 * 0.5 + rtDW.Fcn1_h) * (rtb_ComplextoRealImag_o2 /
      rtb_RateLimiter) + (rtDW.Integ4_dh0 - rtDW.SFunction_ca) *
      rtDW.UnitDelay_DSTATE_fu;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay1_DSTATE_ou;
  }

  /* End of Switch: '<S218>/Switch' */

  /* ComplexToMagnitudeAngle: '<S211>/Complex to Magnitude-Angle' incorporates:
   *  RealImagToComplex: '<S211>/Real-Imag to Complex'
   */
  rtb_RateLimiter = rt_hypotd_snf(rtb_DiscreteTimeIntegrator_k,
    rtb_ComplextoRealImag_o2);

  /* Saturate: '<S206>/Saturation' */
  if (rtb_RateLimiter <= 2.2204460492503131E-16) {
    rtb_RateLimiter = 2.2204460492503131E-16;
  }

  /* End of Saturate: '<S206>/Saturation' */

  /* Math: '<S206>/Math Function'
   *
   * About '<S206>/Math Function':
   *  Operator: reciprocal
   */
  rtDW.MathFunction_h = 1.0 / rtb_RateLimiter;

  /* Update for DiscreteIntegrator: '<S215>/Integ4' incorporates:
   *  Switch: '<S221>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_ck = 0U;
  rtDW.Integ4_DSTATE_o3 = 2.5E-5 * rtDW.Fcn_p + rtDW.Integ4_cu;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S217>/S-Function' */
  /* Level2 S-Function Block: '<S217>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S216>/Unit Delay' incorporates:
   *  Switch: '<S221>/Switch'
   */
  rtDW.UnitDelay_DSTATE_c2 = rtDW.Fcn_p;

  /* Update for UnitDelay: '<S215>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ia = rtb_DiscreteTimeIntegrator_k;

  /* Update for DiscreteIntegrator: '<S218>/Integ4' incorporates:
   *  Switch: '<S221>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_ly = 0U;
  rtDW.Integ4_DSTATE_ei = 2.5E-5 * rtDW.Fcn1_h + rtDW.Integ4_dh0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S220>/S-Function' */
  /* Level2 S-Function Block: '<S220>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S219>/Unit Delay' incorporates:
   *  Switch: '<S221>/Switch'
   */
  rtDW.UnitDelay_DSTATE_m0 = rtDW.Fcn1_h;

  /* Update for UnitDelay: '<S218>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ou = rtb_ComplextoRealImag_o2;

  /* End of Outputs for SubSystem: '<S205>/Automatic Gain Control' */

  /* Outputs for Enabled SubSystem: '<S234>/Subsystem1' */
  /* DiscreteIntegrator: '<S205>/Discrete-Time Integrator' */
  Subsystem1(0, &rtb_Gain1_pe[0], rtDW.DiscreteTimeIntegrator_DSTATE_c,
             &rtb_yk_m_idx_0, &rtDW.Fcn1_n1);

  /* End of Outputs for SubSystem: '<S234>/Subsystem1' */

  /* Outputs for Enabled SubSystem: '<S234>/Subsystem - pi//2 delay' */
  Subsystempi2delay(rtConstB.Compare_a, &rtb_Gain1_pe[0],
                    rtDW.DiscreteTimeIntegrator_DSTATE_c, &rtb_yk_m_idx_0,
                    &rtDW.Fcn1_f);

  /* End of Outputs for SubSystem: '<S234>/Subsystem - pi//2 delay' */

  /* DiscreteIntegrator: '<S231>/Integ4' incorporates:
   *  Switch: '<S234>/Switch'
   */
  if (rtDW.Integ4_SYSTEM_ENABLE_nr != 0) {
    rtDW.Integ4_nt = rtDW.Integ4_DSTATE_o5;
  } else {
    rtDW.Integ4_nt = 2.5E-5 * rtDW.Fcn1_f + rtDW.Integ4_DSTATE_o5;
  }

  /* End of DiscreteIntegrator: '<S231>/Integ4' */

  /* Saturate: '<S231>/To avoid division  by zero' */
  if (rtDW.UnitDelay_DSTATE_fu > 1.0E+6) {
    rtb_ComplextoRealImag_o2 = 1.0E+6;
  } else if (rtDW.UnitDelay_DSTATE_fu < 2.2204460492503131E-16) {
    rtb_ComplextoRealImag_o2 = 2.2204460492503131E-16;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay_DSTATE_fu;
  }

  /* End of Saturate: '<S231>/To avoid division  by zero' */

  /* Fcn: '<S231>/Number of samples per cycle' */
  rtb_DiscreteTimeIntegrator_k = 1.0 / rtb_ComplextoRealImag_o2 / 5.0e-5;

  /* Rounding: '<S231>/Rounding Function' */
  rtb_ComplextoRealImag_o2 = ceil(rtb_DiscreteTimeIntegrator_k);

  /* Gain: '<S231>/Gain' */
  rtDW.Delay_o = 5.0E-5 * rtb_ComplextoRealImag_o2;

  /* S-Function (sfun_discreteVariableDelay): '<S233>/S-Function' */

  /* Level2 S-Function Block: '<S233>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnOutputs(rts,1);
  }

  /* Switch: '<S231>/Switch' incorporates:
   *  Constant: '<S231>/Constant'
   *  Gain: '<S232>/Gain1'
   *  Product: '<S231>/Product'
   *  Product: '<S232>/Product2'
   *  Product: '<S232>/Product4'
   *  Product: '<S232>/Product5'
   *  RelationalOperator: '<S231>/Relational Operator'
   *  Sum: '<S231>/Sum5'
   *  Sum: '<S231>/Sum7'
   *  Sum: '<S232>/Sum1'
   *  Sum: '<S232>/Sum4'
   *  Switch: '<S234>/Switch'
   *  UnitDelay: '<S205>/Unit Delay'
   *  UnitDelay: '<S231>/Unit Delay1'
   *  UnitDelay: '<S232>/Unit Delay'
   */
  if (Divide_e >= 0.016666666666666666) {
    /* Sum: '<S232>/Sum5' */
    rtb_ComplextoRealImag_o2 = rtb_DiscreteTimeIntegrator_k -
      rtb_ComplextoRealImag_o2;
    rtb_ComplextoRealImag_o2 = ((rtDW.Fcn1_f - rtDW.UnitDelay_DSTATE_k) *
      rtb_ComplextoRealImag_o2 * 0.5 + rtDW.Fcn1_f) * (rtb_ComplextoRealImag_o2 /
      rtb_DiscreteTimeIntegrator_k) + (rtDW.Integ4_nt - rtDW.SFunction_gd) *
      rtDW.UnitDelay_DSTATE_fu;
  } else {
    rtb_ComplextoRealImag_o2 = rtDW.UnitDelay1_DSTATE_lv;
  }

  /* End of Switch: '<S231>/Switch' */

  /* Product: '<S205>/Divide' */
  Divide_e = rtb_ComplextoRealImag_o2 * rtDW.MathFunction_h;

  /* Sum: '<S207>/Sum6' incorporates:
   *  DiscreteIntegrator: '<S207>/Discrete-Time Integrator'
   *  DiscreteTransferFcn: '<S207>/Discrete Derivative '
   *  Gain: '<S207>/Kp4'
   */
  rtb_RateLimiter = (90.0 * Divide_e + rtDW.DiscreteTimeIntegrator_DSTATE_p) +
    -0.0 * rtDW.DiscreteDerivative_states_l;

  /* Saturate: '<S207>/Saturation1' */
  if (rtb_RateLimiter <= 0.0) {
    rtb_yk_m_idx_0 = 0.0;
  } else {
    rtb_yk_m_idx_0 = rtb_RateLimiter;
  }

  /* End of Saturate: '<S207>/Saturation1' */

  /* Gain: '<S205>/Gain10' */
  rtb_RateLimiter = 0.15915494309189535 * rtb_yk_m_idx_0;

  /* RateLimiter: '<S205>/Rate Limiter' */
  rtb_DiscreteTimeIntegrator_k = rtb_RateLimiter - rtDW.PrevY_a;
  if (rtb_DiscreteTimeIntegrator_k > 0.00060000000000000006) {
    rtb_RateLimiter = rtDW.PrevY_a + 0.00060000000000000006;
  } else {
    if (rtb_DiscreteTimeIntegrator_k < -0.00060000000000000006) {
      rtb_RateLimiter = rtDW.PrevY_a + -0.00060000000000000006;
    }
  }

  rtDW.PrevY_a = rtb_RateLimiter;

  /* End of RateLimiter: '<S205>/Rate Limiter' */

  /* Sum: '<S228>/sum3' incorporates:
   *  Gain: '<S228>/A21'
   *  Gain: '<S228>/A22'
   *  UnitDelay: '<S227>/Delay_x1'
   *  UnitDelay: '<S227>/Delay_x2'
   */
  rtb_DiscreteTimeIntegrator_k = -1.226881692709296 * rtDW.Delay_x1_DSTATE_g +
    0.988925236714054 * rtDW.Delay_x2_DSTATE_i;

  /* Sum: '<S247>/sum3' incorporates:
   *  Gain: '<S247>/A21'
   *  Gain: '<S247>/A22'
   *  UnitDelay: '<S246>/Delay_x1'
   *  UnitDelay: '<S246>/Delay_x2'
   */
  rtb_sum3_hq_idx_0 = -2998.4645933011561 * rtDW.Delay_x1_DSTATE_i[0] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE_p[0];

  /* Saturate: '<S192>/Saturation' */
  if (rtb_RealImagtoComplex_re > 1.5) {
    /* Update for RateTransition: '<S83>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[0] = 1.5;
  } else if (rtb_RealImagtoComplex_re < -1.5) {
    /* Update for RateTransition: '<S83>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[0] = -1.5;
  } else {
    /* Update for RateTransition: '<S83>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[0] = rtb_RealImagtoComplex_re;
  }

  /* Sum: '<S247>/sum3' incorporates:
   *  Gain: '<S247>/A21'
   *  Gain: '<S247>/A22'
   *  UnitDelay: '<S246>/Delay_x1'
   *  UnitDelay: '<S246>/Delay_x2'
   */
  rtb_RealImagtoComplex_re = -2998.4645933011561 * rtDW.Delay_x1_DSTATE_i[1] +
    0.30056319111239294 * rtDW.Delay_x2_DSTATE_p[1];

  /* Saturate: '<S192>/Saturation' */
  if (rtb_RealImagtoComplex_im > 1.5) {
    /* Update for RateTransition: '<S83>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[1] = 1.5;
  } else if (rtb_RealImagtoComplex_im < -1.5) {
    /* Update for RateTransition: '<S83>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[1] = -1.5;
  } else {
    /* Update for RateTransition: '<S83>/Rate Transition3' */
    rtDW.RateTransition3_Buffer0[1] = rtb_RealImagtoComplex_im;
  }

  /* Update for RateTransition: '<S83>/Rate Transition4' incorporates:
   *  DiscreteIntegrator: '<S205>/Discrete-Time Integrator'
   */
  rtDW.RateTransition4_Buffer0 = rtDW.DiscreteTimeIntegrator_DSTATE_c;

  /* Update for RateTransition: '<S84>/Rate Transition4' incorporates:
   *  DiscreteIntegrator: '<S284>/Discrete-Time Integrator'
   */
  rtDW.RateTransition4_Buffer0_o = rtDW.DiscreteTimeIntegrator_DSTATE_o;

  /* Update for RateTransition: '<S75>/Rate Transition2' */
  rtDW.RateTransition2_Buffer0 = rtb_Saturation2;

  /* Update for DiscreteIntegrator: '<S254>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S254>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_i += 275.0 * rtb_Gain_o3 * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_i >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_i = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_i <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_i = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S254>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S205>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_c += 5.0E-5 * rtb_yk_m_idx_0;
  rtDW.DiscreteTimeIntegrator_PrevRese = (int8_T)rtb_RelationalOperator_dk;

  /* Update for UnitDelay: '<S246>/Delay_x1' incorporates:
   *  Gain: '<S247>/A11'
   *  Gain: '<S247>/A12'
   *  Gain: '<S248>/B11'
   *  Sum: '<S246>/A*x1(k) + B*u1(k) '
   *  Sum: '<S247>/sum2'
   *  Switch: '<S255>/Switch'
   *  UnitDelay: '<S246>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_i[0] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE_i[0] +
    3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE_p[0]) + 1.6257039888904968E-5 *
    rtDW.Fcn_jl;

  /* Update for UnitDelay: '<S246>/Delay_x2' incorporates:
   *  Gain: '<S248>/B21'
   *  Sum: '<S246>/A*x2(k) + B*u2(k)'
   *  Switch: '<S255>/Switch'
   */
  rtDW.Delay_x2_DSTATE_p[0] = 0.65028159555619647 * rtDW.Fcn_jl +
    rtb_sum3_hq_idx_0;

  /* Update for UnitDelay: '<S246>/Delay_x1' incorporates:
   *  Gain: '<S247>/A11'
   *  Gain: '<S247>/A12'
   *  Gain: '<S248>/B11'
   *  Sum: '<S246>/A*x1(k) + B*u1(k) '
   *  Sum: '<S247>/sum2'
   *  Switch: '<S255>/Switch'
   *  UnitDelay: '<S246>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_i[1] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE_i[1] +
    3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE_p[1]) + 1.6257039888904968E-5 *
    rtDW.Fcn1_on;

  /* Update for UnitDelay: '<S246>/Delay_x2' incorporates:
   *  Gain: '<S248>/B21'
   *  Sum: '<S246>/A*x2(k) + B*u2(k)'
   *  Switch: '<S255>/Switch'
   */
  rtDW.Delay_x2_DSTATE_p[1] = 0.65028159555619647 * rtDW.Fcn1_on +
    rtb_RealImagtoComplex_re;

  /* Update for DiscreteIntegrator: '<S333>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S333>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_j += 800.0 * rtb_Gain_eb * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_j >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_j = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_j <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_j = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S333>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S284>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_o += 5.0E-5 * rtb_Saturation1;
  rtDW.DiscreteTimeIntegrator_PrevRe_g = (int8_T)rtb_RelationalOperator_hg;

  /* Update for UnitDelay: '<S325>/Delay_x1' incorporates:
   *  Gain: '<S326>/A11'
   *  Gain: '<S326>/A12'
   *  Gain: '<S327>/B11'
   *  Sum: '<S325>/A*x1(k) + B*u1(k) '
   *  Sum: '<S326>/sum2'
   *  Switch: '<S334>/Switch'
   *  UnitDelay: '<S325>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_pm[0] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE_pm[0]
    + 3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE_d[0]) + 1.6257039888904968E-5
    * rtDW.Fcn_d;

  /* Update for UnitDelay: '<S325>/Delay_x2' incorporates:
   *  Gain: '<S327>/B21'
   *  Sum: '<S325>/A*x2(k) + B*u2(k)'
   *  Switch: '<S334>/Switch'
   */
  rtDW.Delay_x2_DSTATE_d[0] = 0.65028159555619647 * rtDW.Fcn_d +
    rtb_sum3_h_idx_0;

  /* Update for UnitDelay: '<S325>/Delay_x1' incorporates:
   *  Gain: '<S326>/A11'
   *  Gain: '<S326>/A12'
   *  Gain: '<S327>/B11'
   *  Sum: '<S325>/A*x1(k) + B*u1(k) '
   *  Sum: '<S326>/sum2'
   *  Switch: '<S334>/Switch'
   *  UnitDelay: '<S325>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_pm[1] = (0.92503838516747083 * rtDW.Delay_x1_DSTATE_pm[1]
    + 3.2514079777809854E-5 * rtDW.Delay_x2_DSTATE_d[1]) + 1.6257039888904968E-5
    * rtDW.Fcn1_j;

  /* Update for UnitDelay: '<S325>/Delay_x2' incorporates:
   *  Gain: '<S327>/B21'
   *  Sum: '<S325>/A*x2(k) + B*u2(k)'
   *  Switch: '<S334>/Switch'
   */
  rtDW.Delay_x2_DSTATE_d[1] = 0.65028159555619647 * rtDW.Fcn1_j +
    rtb_sum3_h_idx_1;

  /* Update for DiscreteIntegrator: '<S280>/Integ4' incorporates:
   *  Fcn: '<S268>/Mag_V '
   */
  rtDW.Integ4_SYSTEM_ENABLE_ei = 0U;
  rtDW.Integ4_DSTATE_gg = 2.5E-5 * tmp + rtDW.Integ4_j0;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S281>/S-Function' incorporates:
   *  Constant: '<S280>/K1'
   */
  /* Level2 S-Function Block: '<S281>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S280>/Unit Delay' incorporates:
   *  Fcn: '<S268>/Mag_V '
   */
  rtDW.UnitDelay_DSTATE_pj = tmp;

  /* Update for UnitDelay: '<S280>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ai = rtb_Switch_i;

  /* Update for DiscreteIntegrator: '<S86>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S86>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTAT_oe += 50.0 * Initial_a * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTAT_oe >= 1000.0) {
    rtDW.DiscreteTimeIntegrator_DSTAT_oe = 1000.0;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTAT_oe <= -1000.0) {
      rtDW.DiscreteTimeIntegrator_DSTAT_oe = -1000.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S86>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S277>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTAT_ju += 5.0E-5 * rtb_Add3_d;
  if (rtDW.DiscreteTimeIntegrator_DSTAT_ju >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTAT_ju = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTAT_ju <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTAT_ju = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S277>/Discrete-Time Integrator' */

  /* Update for UnitDelay: '<S284>/Unit Delay' incorporates:
   *  Gain: '<S306>/D*u(k)'
   *  Gain: '<S309>/C11'
   *  Gain: '<S309>/C12'
   *  Sum: '<S306>/C*X(k)+D*u(k)'
   *  Sum: '<S309>/sum2'
   *  UnitDelay: '<S306>/Delay_x1'
   *  UnitDelay: '<S306>/Delay_x2'
   */
  rtDW.UnitDelay_DSTATE_cn4 = (1.233694313470147 * rtDW.Delay_x1_DSTATE_l +
    3.06720423177324E-5 * rtDW.Delay_x2_DSTATE_j) + 1.53360211588662E-5 *
    rtb_yk_h_idx_0;

  /* Update for DiscreteIntegrator: '<S278>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S278>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_k += 80.0 * rtb_yk_h_idx_1 * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_k >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_k = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_k <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_k = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S278>/Discrete-Time Integrator' */

  /* Update for DiscreteTransferFcn: '<S286>/Discrete Derivative ' */
  rtDW.DiscreteDerivative_states = (rtb_RoundingFunction_k - -5.0E-5 *
    rtDW.DiscreteDerivative_states) / 0.0001;

  /* Update for DiscreteIntegrator: '<S286>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_n += 0.08 * rtb_RoundingFunction_k;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_n >= (rtInf)) {
    rtDW.DiscreteTimeIntegrator_DSTATE_n = (rtInf);
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_n <= 0.0) {
      rtDW.DiscreteTimeIntegrator_DSTATE_n = 0.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S286>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S310>/Integ4' incorporates:
   *  Switch: '<S313>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_nm = 0U;
  rtDW.Integ4_DSTATE_ad = 2.5E-5 * rtDW.Fcn1_b + rtDW.Integ4_ll;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S312>/S-Function' */
  /* Level2 S-Function Block: '<S312>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S311>/Unit Delay' incorporates:
   *  Switch: '<S313>/Switch'
   */
  rtDW.UnitDelay_DSTATE_c3 = rtDW.Fcn1_b;

  /* Update for UnitDelay: '<S310>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o0e = rtb_RoundingFunction_l;

  /* Update for UnitDelay: '<S306>/Delay_x1' incorporates:
   *  Gain: '<S307>/A11'
   *  Gain: '<S307>/A12'
   *  Gain: '<S308>/B11'
   *  Sum: '<S306>/A*x1(k) + B*u1(k) '
   *  Sum: '<S307>/sum2'
   *  UnitDelay: '<S306>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_l = (0.99996932795768223 * rtDW.Delay_x1_DSTATE_l +
    4.9723130917851353E-5 * rtDW.Delay_x2_DSTATE_j) + 2.4861565458925677E-5 *
    rtb_yk_h_idx_0;

  /* Update for UnitDelay: '<S306>/Delay_x2' incorporates:
   *  Gain: '<S308>/B21'
   *  Sum: '<S306>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_j = 0.994462618357027 * rtb_yk_h_idx_0 + rtb_sum3;

  /* Update for DiscreteIntegrator: '<S85>/Discrete-Time Integrator' incorporates:
   *  Gain: '<S85>/Kp5'
   */
  rtDW.DiscreteTimeIntegrator_DSTAT_om += 0.25 * rtb_DigitalClock * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTAT_om >= 1.0) {
    rtDW.DiscreteTimeIntegrator_DSTAT_om = 1.0;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTAT_om <= 0.0) {
      rtDW.DiscreteTimeIntegrator_DSTAT_om = 0.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S85>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S201>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_e += 5.0E-5 * rtb_Product2_ft;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_e >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_e = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_e <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_e = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S201>/Discrete-Time Integrator' */

  /* Update for UnitDelay: '<S205>/Unit Delay' incorporates:
   *  Gain: '<S227>/D*u(k)'
   *  Gain: '<S230>/C11'
   *  Gain: '<S230>/C12'
   *  Sum: '<S227>/C*X(k)+D*u(k)'
   *  Sum: '<S230>/sum2'
   *  UnitDelay: '<S227>/Delay_x1'
   *  UnitDelay: '<S227>/Delay_x2'
   */
  rtDW.UnitDelay_DSTATE_fu = (1.233694313470147 * rtDW.Delay_x1_DSTATE_g +
    3.06720423177324E-5 * rtDW.Delay_x2_DSTATE_i) + 1.53360211588662E-5 *
    rtb_RateLimiter;

  /* Update for DiscreteIntegrator: '<S202>/Discrete-Time Integrator' incorporates:
   *  Constant: '<S83>/Iref'
   *  Gain: '<S202>/Kp5'
   *  Sum: '<S192>/Sum1'
   */
  rtDW.DiscreteTimeIntegrator_DSTATE_l += (0.0 - Initial) * 8.0 * 5.0E-5;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_l >= 1.5) {
    rtDW.DiscreteTimeIntegrator_DSTATE_l = 1.5;
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_l <= -1.5) {
      rtDW.DiscreteTimeIntegrator_DSTATE_l = -1.5;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S202>/Discrete-Time Integrator' */

  /* Update for DiscreteTransferFcn: '<S207>/Discrete Derivative ' */
  rtDW.DiscreteDerivative_states_l = (Divide_e - -5.0E-5 *
    rtDW.DiscreteDerivative_states_l) / 0.0001;

  /* Update for DiscreteIntegrator: '<S207>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_p += 0.08 * Divide_e;
  if (rtDW.DiscreteTimeIntegrator_DSTATE_p >= (rtInf)) {
    rtDW.DiscreteTimeIntegrator_DSTATE_p = (rtInf);
  } else {
    if (rtDW.DiscreteTimeIntegrator_DSTATE_p <= 0.0) {
      rtDW.DiscreteTimeIntegrator_DSTATE_p = 0.0;
    }
  }

  /* End of Update for DiscreteIntegrator: '<S207>/Discrete-Time Integrator' */

  /* Update for DiscreteIntegrator: '<S231>/Integ4' incorporates:
   *  Switch: '<S234>/Switch'
   */
  rtDW.Integ4_SYSTEM_ENABLE_nr = 0U;
  rtDW.Integ4_DSTATE_o5 = 2.5E-5 * rtDW.Fcn1_f + rtDW.Integ4_nt;

  /* Update for S-Function (sfun_discreteVariableDelay): '<S233>/S-Function' */
  /* Level2 S-Function Block: '<S233>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnUpdate(rts,1);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Update for UnitDelay: '<S232>/Unit Delay' incorporates:
   *  Switch: '<S234>/Switch'
   */
  rtDW.UnitDelay_DSTATE_k = rtDW.Fcn1_f;

  /* Update for UnitDelay: '<S231>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lv = rtb_ComplextoRealImag_o2;

  /* Update for UnitDelay: '<S227>/Delay_x1' incorporates:
   *  Gain: '<S228>/A11'
   *  Gain: '<S228>/A12'
   *  Gain: '<S229>/B11'
   *  Sum: '<S227>/A*x1(k) + B*u1(k) '
   *  Sum: '<S228>/sum2'
   *  UnitDelay: '<S227>/Delay_x2'
   */
  rtDW.Delay_x1_DSTATE_g = (0.99996932795768223 * rtDW.Delay_x1_DSTATE_g +
    4.9723130917851353E-5 * rtDW.Delay_x2_DSTATE_i) + 2.4861565458925677E-5 *
    rtb_RateLimiter;

  /* Update for UnitDelay: '<S227>/Delay_x2' incorporates:
   *  Gain: '<S229>/B21'
   *  Sum: '<S227>/A*x2(k) + B*u2(k)'
   */
  rtDW.Delay_x2_DSTATE_i = 0.994462618357027 * rtb_RateLimiter +
    rtb_DiscreteTimeIntegrator_k;

  /* Update absolute time */
  /* The "clockTick1" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick1"
   * and "Timing.stepSize1". Size of "clockTick1" ensures timer will not
   * overflow during the application lifespan selected.
   */
  rtM->Timing.t[1] =
    (++rtM->Timing.clockTick1) * rtM->Timing.stepSize1;
}

/* Model initialize function */
void power_converters_switching_function_initialize(void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));
  rtsiSetSolverName(&rtM->solverInfo,"FixedStepDiscrete");
  rtM->solverInfoPtr = (&rtM->solverInfo);

  /* Initialize timing info */
  {
    int_T *mdlTsMap = rtM->Timing.sampleTimeTaskIDArray;
    mdlTsMap[0] = 0;
    mdlTsMap[1] = 1;
    rtM->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);
    rtM->Timing.sampleTimes = (&rtM->Timing.sampleTimesArray[0]);
    rtM->Timing.offsetTimes = (&rtM->Timing.offsetTimesArray[0]);

    /* task periods */
    rtM->Timing.sampleTimes[0] = (5.0E-6);
    rtM->Timing.sampleTimes[1] = (5.0E-5);

    /* task offsets */
    rtM->Timing.offsetTimes[0] = (0.0);
    rtM->Timing.offsetTimes[1] = (0.0);
  }

  rtmSetTPtr(rtM, &rtM->Timing.tArray[0]);

  {
    int_T *mdlSampleHits = rtM->Timing.sampleHitArray;
    int_T *mdlPerTaskSampleHits = rtM->Timing.perTaskSampleHitsArray;
    rtM->Timing.perTaskSampleHits = (&mdlPerTaskSampleHits[0]);
    mdlSampleHits[0] = 1;
    rtM->Timing.sampleHits = (&mdlSampleHits[0]);
  }

  rtmSetTFinal(rtM, -1);
  rtM->Timing.stepSize0 = 5.0E-6;
  rtM->Timing.stepSize1 = 5.0E-5;
  rtM->solverInfoPtr = (&rtM->solverInfo);
  rtM->Timing.stepSize = (5.0E-6);
  rtsiSetFixedStepSize(&rtM->solverInfo, 5.0E-6);
  rtsiSetSolverMode(&rtM->solverInfo, SOLVER_MODE_MULTITASKING);

  /* child S-Function registration */
  {
    RTWSfcnInfo *sfcnInfo = &rtM->NonInlinedSFcns.sfcnInfo;
    rtM->sfcnInfo = (sfcnInfo);
    rtssSetErrorStatusPtr(sfcnInfo, ((const char_T **)(&rtmGetErrorStatus(rtM))));
    rtssSetNumRootSampTimesPtr(sfcnInfo, &rtM->Sizes.numSampTimes);
    rtM->NonInlinedSFcns.taskTimePtrs[0] = &(rtmGetTPtr(rtM)[0]);
    rtM->NonInlinedSFcns.taskTimePtrs[1] = &(rtmGetTPtr(rtM)[1]);
    rtssSetTPtrPtr(sfcnInfo,rtM->NonInlinedSFcns.taskTimePtrs);
    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(rtM));
    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(rtM));
    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(rtM));
    rtssSetStepSizePtr(sfcnInfo, &rtM->Timing.stepSize);
    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(rtM));
    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &rtM->derivCacheNeedsReset);
    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &rtM->zCCacheNeedsReset);
    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,
      &rtM->CTOutputIncnstWithState);
    rtssSetSampleHitsPtr(sfcnInfo, &rtM->Timing.sampleHits);
    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &rtM->Timing.perTaskSampleHits);
    rtssSetSimModePtr(sfcnInfo, &rtM->simMode);
    rtssSetSolverInfoPtr(sfcnInfo, &rtM->solverInfoPtr);
  }

  rtM->Sizes.numSFcns = (93);

  /* register each child */
  {
    (void) memset((void *)&rtM->NonInlinedSFcns.childSFunctions[0], 0,
                  93*sizeof(SimStruct));
    rtM->childSfunctions = (&rtM->NonInlinedSFcns.childSFunctionPtrs[0]);

    {
      int_T i;
      for (i = 0; i < 93; i++) {
        rtM->childSfunctions[i] = (&rtM->NonInlinedSFcns.childSFunctions[i]);
      }
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S95>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[0];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn0.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn0.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn0.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[0]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[0]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[0]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[0]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[0]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[0]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[0]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn0.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn0.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn0.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn0.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_im;
          sfcnUPtrs[1] = &rtDW.Integ4_im[1];
          sfcnUPtrs[2] = &rtDW.Integ4_im[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn0.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn0.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn0.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn0.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_nt));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen 2L/PWMgen - Averaging/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn0.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hh);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_l2[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jk[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn0.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn0.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hh);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_l2[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jk[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S97>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[1];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn1.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn1.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn1.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[1]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[1]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[1]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[1]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[1]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[1]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[1]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn1.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn1.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn1.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn1.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_iy;
          sfcnUPtrs[1] = &rtDW.Integ4_iy[1];
          sfcnUPtrs[2] = &rtDW.Integ4_iy[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn1.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn1.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn1.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn1.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_id));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen 2L/PWMgen - Averaging/Mean3/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn1.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ov);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mqk[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nr[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn1.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn1.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ov);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mqk[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nr[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S123>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[2];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn2.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn2.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn2.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[2]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[2]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[2]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[2]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[2]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[2]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[2]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn2.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn2.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn2.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn2.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_md;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn2.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn2.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn2.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn2.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ap));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen 2Q/Subsystem/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn2.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hgx);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_fd);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_d2);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn2.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn2.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hgx);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_fd);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_d2);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S133>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[3];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn3.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn3.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn3.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[3]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[3]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[3]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[3]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[3]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[3]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[3]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn3.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn3.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn3.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn3.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_lh;
          sfcnUPtrs[1] = &rtDW.Integ4_lh[1];
          sfcnUPtrs[2] = &rtDW.Integ4_lh[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn3.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn3.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn3.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn3.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_bl));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen 3L/PWMgen - Averaging/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn3.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_me);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_iu[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hs[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn3.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn3.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_me);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_iu[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hs[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S135>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[4];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn4.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn4.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn4.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[4]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[4]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[4]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[4]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[4]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[4]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[4]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn4.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn4.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn4.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn4.UPtrs0;
          sfcnUPtrs[0] = rtDW.Integ4_fe;
          sfcnUPtrs[1] = &rtDW.Integ4_fe[1];
          sfcnUPtrs[2] = &rtDW.Integ4_fe[2];
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 3);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn4.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn4.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn4.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn4.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 3);
          ssSetOutputPortSignal(rts, 0, ((real_T *) rtDW.SFunction_fj));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen 3L/PWMgen - Averaging/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn4.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_np);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_m1b[0]);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bd[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn4.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn4.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_np);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 3);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_m1b[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 3);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bd[0]);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 3);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 3);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 3);
      ssSetNumPWork(rts, 3);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S145>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[5];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn5.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn5.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn5.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[5]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[5]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[5]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[5]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[5]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[5]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[5]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn5.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn5.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn5.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn5.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_hv;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn5.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn5.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn5.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn5.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bv));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen Boost/PWM Gen/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn5.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nz1);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_pa);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_db);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn5.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn5.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nz1);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_pa);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_db);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S153>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[6];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn6.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn6.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn6.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[6]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[6]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[6]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[6]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[6]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[6]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[6]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn6.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn6.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn6.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn6.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_jx;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn6.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn6.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn6.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn6.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bi));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen Buck/PWM Gen/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn6.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_gs);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_khs);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_je);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn6.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn6.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_gs);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_khs);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_je);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S163>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[7];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn7.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn7.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn7.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[7]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[7]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[7]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[7]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[7]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[7]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[7]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn7.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn7.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn7.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn7.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn7.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn7.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn7.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn7.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_eh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen FB/PWM gen/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn7.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fn);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pv4);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn7.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn7.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fn);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pv4);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S165>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[8];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn8.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn8.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn8.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[8]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[8]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[8]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[8]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[8]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[8]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[8]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn8.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn8.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn8.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn8.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_jq;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn8.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn8.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn8.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn8.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_be1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen FB/PWM gen/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn8.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lp2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mt);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_c3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn8.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn8.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lp2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mt);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_c3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S181>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[9];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn9.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn9.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn9.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[9]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[9]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[9]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[9]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[9]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[9]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[9]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn9.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn9.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn9.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn9.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_l1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn9.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled12;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->NonInlinedSFcns.Sfcn9.outputPortInfo
          [0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn9.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn9.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bz));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/PWM Gen HB/Subsystem/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn9.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled13);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h4);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_pe);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn9.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn9.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h4);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_pe);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S217>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[10];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn10.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn10.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn10.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[10]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[10]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[10]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[10]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[10]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[10]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[10]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn10.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn10.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn10.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn10.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_cu;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn10.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_ou;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn10.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn10.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn10.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_lp));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Rectifier Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn10.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_abb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_kh);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jd);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn10.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn10.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_abb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_kh);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jd);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S220>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[11];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn11.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn11.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn11.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[11]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[11]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[11]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[11]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[11]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[11]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[11]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn11.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn11.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn11.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn11.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dh0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn11.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_lg;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn11.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn11.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn11.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ca));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Rectifier Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn11.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_az);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_e3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_lw);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn11.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn11.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_az);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_e3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_lw);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S296>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[12];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn12.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn12.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn12.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[12]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[12]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[12]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[12]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[12]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[12]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[12]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn12.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn12.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn12.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn12.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_cs;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn12.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_f;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn12.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn12.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn12.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_d4));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Statcom Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn12.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_kk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_lz);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn12.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn12.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_kk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_lz);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S299>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[13];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn13.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn13.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn13.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[13]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[13]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[13]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[13]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[13]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[13]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[13]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn13.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn13.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn13.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn13.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ha;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn13.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_l;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn13.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn13.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn13.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_e5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Statcom Control System/Measurements/PLL (3ph)/Model/Automatic Gain Control/Positive-Sequence (PLL-Driven)/Mean (Variable Frequency)2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn13.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_pl);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cl);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ft);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn13.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn13.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_pl);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cl);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ft);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S445>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[14];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn14.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn14.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn14.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[14]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[14]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[14]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[14]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[14]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[14]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[14]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn14.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn14.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn14.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn14.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn14.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn14.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn14.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn14.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn14.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn14.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn14.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S443>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[15];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn15.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn15.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn15.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[15]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[15]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[15]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[15]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[15]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[15]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[15]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn15.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn15.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn15.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn15.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_p;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn15.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn15.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn15.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn15.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn15.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_f);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_m);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_b);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn15.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn15.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_f);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_m);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_b);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S451>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[16];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn16.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn16.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn16.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[16]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[16]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[16]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[16]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[16]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[16]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[16]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn16.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn16.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn16.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn16.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_d;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn16.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn16.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn16.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn16.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_em));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn16.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_o);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_l);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_i);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn16.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn16.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_o);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_l);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_i);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S449>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[17];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn17.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn17.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn17.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[17]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[17]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[17]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[17]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[17]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[17]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[17]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn17.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn17.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn17.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn17.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_h;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn17.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn17.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn17.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn17.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn17.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_m);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_b);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn17.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn17.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_m);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_b);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S457>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[18];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn18.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn18.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn18.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[18]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[18]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[18]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[18]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[18]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[18]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[18]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn18.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn18.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn18.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn18.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_a;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn18.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn18.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn18.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn18.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn18.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_l);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_c);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_f);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn18.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn18.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_l);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_c);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_f);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S455>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[19];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn19.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn19.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn19.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[19]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[19]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[19]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[19]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[19]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[19]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[19]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn19.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn19.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn19.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn19.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_c;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn19.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn19.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn19.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn19.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn19.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_f2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bh);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bi);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn19.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn19.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_f2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bh);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bi);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S469>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[20];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn20.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn20.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn20.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[20]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[20]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[20]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[20]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[20]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[20]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[20]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn20.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn20.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn20.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn20.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ae;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn20.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn20.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn20.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn20.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn20.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_n);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_e);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_o);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn20.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn20.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_n);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_e);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_o);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S467>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[21];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn21.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn21.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn21.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[21]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[21]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[21]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[21]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[21]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[21]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[21]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn21.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn21.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn21.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn21.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_k;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn21.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn21.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn21.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn21.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn21.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_p);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_a);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bf);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn21.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn21.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_p);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_a);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bf);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S475>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[22];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn22.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn22.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn22.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[22]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[22]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[22]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[22]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[22]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[22]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[22]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn22.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn22.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn22.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn22.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dh;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn22.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn22.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn22.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn22.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn22.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_j);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_at);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_a);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn22.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn22.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_j);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_at);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_a);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S473>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[23];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn23.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn23.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn23.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[23]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[23]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[23]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[23]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[23]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[23]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[23]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn23.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn23.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn23.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn23.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_b;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn23.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn23.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn23.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn23.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gi));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn23.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ps);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_n);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_j);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn23.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn23.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ps);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_n);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_j);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S481>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[24];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn24.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn24.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn24.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[24]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[24]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[24]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[24]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[24]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[24]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[24]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn24.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn24.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn24.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn24.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_hq;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn24.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn24.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn24.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn24.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_lu));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn24.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_la);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_li);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_m);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn24.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn24.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_la);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_li);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_m);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S479>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[25];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn25.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn25.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn25.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[25]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[25]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[25]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[25]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[25]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[25]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[25]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn25.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn25.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn25.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn25.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_j;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn25.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn25.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn25.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn25.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_hd));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn25.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_o4);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_k);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fu);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn25.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn25.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_o4);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_k);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fu);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S913>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[26];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn26.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn26.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn26.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[26]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[26]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[26]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[26]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[26]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[26]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[26]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn26.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn26.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn26.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn26.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_f;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn26.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn26.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn26.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn26.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ez));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/V1 meas/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn26.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_i);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_j);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ii);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn26.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn26.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_i);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_j);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ii);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S911>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[27];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn27.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn27.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn27.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[27]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[27]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[27]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[27]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[27]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[27]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[27]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn27.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn27.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn27.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn27.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_aa;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn27.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn27.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn27.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn27.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/V1 meas/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn27.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_b);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_lt);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ib);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn27.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn27.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_b);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_lt);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ib);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S919>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[28];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn28.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn28.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn28.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[28]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[28]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[28]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[28]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[28]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[28]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[28]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn28.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn28.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn28.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn28.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_f0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn28.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn28.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn28.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn28.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_dm));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/V1 meas/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn28.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_k0);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_at);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn28.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn28.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_k0);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_at);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S917>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[29];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn29.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn29.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn29.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[29]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[29]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[29]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[29]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[29]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[29]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[29]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn29.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn29.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn29.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn29.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_i;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn29.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn29.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn29.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn29.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gs));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/V1 meas/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn29.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_g);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mp);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_og);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn29.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn29.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_g);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mp);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_og);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S925>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[30];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn30.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn30.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn30.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[30]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[30]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[30]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[30]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[30]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[30]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[30]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn30.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn30.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn30.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn30.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_l;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn30.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn30.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn30.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn30.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_dy));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/V1 meas/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn30.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_jh);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_af);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn30.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn30.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_jh);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_af);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S923>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[31];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn31.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn31.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn31.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[31]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[31]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[31]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[31]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[31]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[31]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[31]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn31.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn31.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn31.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn31.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_g;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn31.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn31.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn31.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn31.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/V1 meas/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn31.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hg);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_o);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ac);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn31.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn31.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hg);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_o);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ac);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S411>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[32];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn32.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn32.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn32.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[32]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[32]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[32]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[32]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[32]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[32]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[32]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn32.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn32.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn32.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn32.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn32.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn32.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn32.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn32.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn32.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fx);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_i);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_g);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn32.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn32.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fx);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_i);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_g);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S413>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[33];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn33.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn33.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn33.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[33]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[33]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[33]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[33]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[33]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[33]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[33]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn33.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn33.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn33.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn33.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_fr;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn33.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn33.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn33.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn33.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ct));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn33.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_n0);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ci);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_oa);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn33.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn33.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_n0);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ci);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_oa);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S415>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[34];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn34.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn34.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn34.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[34]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[34]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[34]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[34]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[34]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[34]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[34]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn34.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn34.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn34.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn34.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mt;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn34.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn34.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn34.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn34.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn34.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_d);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_h);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_m3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn34.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn34.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_d);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_h);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_m3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S417>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[35];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn35.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn35.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn35.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[35]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[35]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[35]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[35]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[35]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[35]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[35]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn35.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn35.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn35.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn35.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ge;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn35.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled78;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn35.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn35.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn35.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Mean3/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn35.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled79);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nd);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_os);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_e);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn35.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn35.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nd);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_os);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_e);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S425>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[36];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn36.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn36.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn36.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[36]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[36]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[36]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[36]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[36]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[36]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[36]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn36.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn36.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn36.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn36.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_lf;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn36.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn36.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn36.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn36.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power/Fourier/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn36.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_pe);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_f);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_c);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn36.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn36.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_pe);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_f);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_c);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S423>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[37];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn37.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn37.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn37.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[37]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[37]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[37]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[37]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[37]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[37]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[37]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn37.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn37.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn37.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn37.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_bp;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn37.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn37.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn37.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn37.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_c5r));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power/Fourier/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn37.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_a);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ow);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ki);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn37.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn37.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_a);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ow);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ki);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S431>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[38];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn38.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn38.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn38.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[38]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[38]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[38]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[38]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[38]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[38]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[38]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn38.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn38.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn38.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn38.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_n;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn38.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn38.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn38.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn38.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_h1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power/Fourier1/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn38.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lf);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ny);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_p);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn38.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn38.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lf);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ny);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_p);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S429>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[39];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn39.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn39.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn39.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[39]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[39]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[39]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[39]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[39]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[39]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[39]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn39.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn39.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn39.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn39.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_o;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn39.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn39.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn39.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn39.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power/Fourier1/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn39.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_e);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_my);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_h);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn39.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn39.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_e);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_my);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_h);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S495>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[40];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn40.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn40.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn40.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[40]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[40]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[40]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[40]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[40]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[40]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[40]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn40.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn40.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn40.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn40.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mta;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn40.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn40.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn40.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn40.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn40.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h1);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_d);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_l);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn40.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn40.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h1);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_d);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_l);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S493>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[41];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn41.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn41.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn41.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[41]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[41]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[41]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[41]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[41]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[41]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[41]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn41.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn41.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn41.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn41.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_oc;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn41.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn41.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn41.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn41.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ge));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn41.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_k);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_d4);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ml);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn41.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn41.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_k);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_d4);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ml);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S501>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[42];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn42.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn42.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn42.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[42]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[42]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[42]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[42]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[42]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[42]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[42]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn42.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn42.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn42.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn42.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_do;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn42.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn42.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn42.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn42.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_jm));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn42.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_mo);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_g);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k4);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn42.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn42.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_mo);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_g);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k4);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S499>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[43];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn43.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn43.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn43.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[43]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[43]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[43]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[43]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[43]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[43]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[43]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn43.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn43.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn43.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn43.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nk;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn43.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn43.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn43.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn43.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_et));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn43.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_mn);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ip);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_kd);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn43.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn43.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_mn);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ip);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_kd);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S507>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[44];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn44.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn44.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn44.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[44]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[44]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[44]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[44]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[44]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[44]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[44]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn44.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn44.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn44.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn44.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pl;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn44.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn44.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn44.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn44.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ko));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn44.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fu);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_gi);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ge);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn44.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn44.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fu);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_gi);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ge);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S505>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[45];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn45.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn45.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn45.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[45]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[45]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[45]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[45]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[45]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[45]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[45]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn45.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn45.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn45.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn45.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nkx;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn45.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn45.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn45.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn45.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ey));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn45.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_eb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_eq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_by);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn45.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn45.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_eb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_eq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_by);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S519>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[46];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn46.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn46.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn46.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[46]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[46]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[46]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[46]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[46]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[46]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[46]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn46.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn46.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn46.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn46.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mr;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn46.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn46.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn46.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn46.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_iz));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn46.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_mi);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ln);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_d);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn46.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn46.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_mi);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ln);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_d);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S517>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[47];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn47.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn47.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn47.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[47]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[47]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[47]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[47]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[47]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[47]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[47]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn47.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn47.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn47.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn47.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dg;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn47.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn47.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn47.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn47.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ff));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn47.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_eu);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_od);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_f3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn47.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn47.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_eu);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_od);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_f3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S525>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[48];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn48.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn48.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn48.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[48]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[48]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[48]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[48]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[48]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[48]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[48]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn48.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn48.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn48.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn48.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_e;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn48.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn48.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn48.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn48.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn48.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_db);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nf);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hm);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn48.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn48.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_db);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nf);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hm);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S523>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[49];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn49.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn49.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn49.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[49]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[49]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[49]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[49]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[49]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[49]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[49]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn49.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn49.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn49.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn49.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_g4;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn49.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn49.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn49.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn49.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gv));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn49.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_kh);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_hg);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_m4);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn49.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn49.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_kh);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_hg);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_m4);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S531>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[50];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn50.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn50.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn50.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[50]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[50]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[50]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[50]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[50]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[50]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[50]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn50.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn50.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn50.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn50.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ao;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn50.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn50.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn50.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn50.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_l5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn50.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ok);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_hn);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn50.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn50.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ok);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_hn);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S529>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[51];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn51.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn51.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn51.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[51]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[51]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[51]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[51]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[51]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[51]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[51]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn51.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn51.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn51.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn51.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mk;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn51.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn51.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn51.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn51.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gy));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn51.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_c);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_av);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_lp);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn51.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn51.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_c);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_av);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_lp);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S281>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[52];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn52.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn52.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn52.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[52]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[52]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[52]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[52]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[52]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[52]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[52]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn52.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn52.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn52.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn52.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_j0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn52.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.K1_Value;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn52.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn52.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn52.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Statcom Control System/Iq_ref generation/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn52.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.SFunction_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fc);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cv);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fi);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn52.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn52.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fc);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cv);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fi);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S312>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[53];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn53.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn53.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn53.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[53]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[53]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[53]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[53]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[53]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[53]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[53]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn53.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn53.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn53.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn53.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ll;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn53.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn53.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn53.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn53.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ia));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Statcom Control System/Measurements/PLL (3ph)/Model/Variable Frequency Mean value/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn53.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ks);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nz);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_gw);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn53.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn53.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ks);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nz);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_gw);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S233>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[54];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn54.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn54.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn54.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[54]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[54]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[54]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[54]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[54]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[54]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[54]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn54.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn54.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn54.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn54.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nt;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn54.UPtrs1;
          sfcnUPtrs[0] = &rtDW.Delay_o;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn54.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn54.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn54.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gd));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Control Systems/Rectifier Control System/Measurements/PLL (3ph)/Model/Variable Frequency Mean value/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn54.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled35);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_io);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_g3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_n);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn54.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn54.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_io);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_g3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_n);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-5);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S547>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[55];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn55.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn55.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn55.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[55]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[55]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[55]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[55]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[55]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[55]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[55]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn55.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn55.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn55.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn55.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_c1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn55.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled78;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn55.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn55.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn55.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_b5));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Mean3/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn55.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled79);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_g0);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_g2);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_eq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn55.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn55.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_g0);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_g2);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_eq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S623>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[56];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn56.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn56.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn56.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[56]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[56]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[56]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[56]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[56]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[56]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[56]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn56.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn56.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn56.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn56.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_is;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn56.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn56.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn56.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn56.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_do));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn56.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_md);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bfq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn56.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn56.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_md);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bfq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S625>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[57];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn57.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn57.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn57.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[57]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[57]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[57]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[57]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[57]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[57]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[57]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn57.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn57.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn57.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn57.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_np;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn57.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn57.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn57.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn57.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ks));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn57.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_k3);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_lg);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ll);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn57.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn57.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_k3);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_lg);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ll);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S629>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[58];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn58.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn58.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn58.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[58]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[58]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[58]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[58]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[58]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[58]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[58]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn58.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn58.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn58.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn58.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nw;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn58.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn58.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn58.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn58.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_kof));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn58.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_dl);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cj);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ky);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn58.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn58.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_dl);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cj);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ky);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S631>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[59];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn59.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn59.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn59.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[59]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[59]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[59]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[59]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[59]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[59]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[59]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn59.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn59.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn59.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn59.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pz;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn59.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn59.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn59.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn59.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_oc));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn59.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nq);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_jj);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cy);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn59.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn59.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nq);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_jj);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cy);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S635>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[60];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn60.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn60.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn60.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[60]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[60]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[60]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[60]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[60]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[60]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[60]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn60.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn60.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn60.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn60.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_i0;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn60.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn60.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn60.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn60.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ok));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn60.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hw);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_e1);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cu);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn60.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn60.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hw);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_e1);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cu);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S637>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[61];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn61.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn61.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn61.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[61]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[61]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[61]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[61]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[61]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[61]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[61]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn61.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn61.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn61.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn61.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_j1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn61.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn61.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn61.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn61.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_i1));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn61.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_jg);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ll);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pj);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn61.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn61.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_jg);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ll);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pj);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S647>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[62];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn62.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn62.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn62.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[62]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[62]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[62]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[62]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[62]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[62]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[62]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn62.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn62.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn62.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn62.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_di;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn62.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn62.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn62.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn62.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_fd));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn62.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_pu);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_k2);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_hq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn62.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn62.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_pu);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_k2);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_hq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S649>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[63];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn63.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn63.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn63.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[63]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[63]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[63]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[63]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[63]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[63]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[63]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn63.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn63.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn63.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn63.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dd;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn63.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn63.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn63.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn63.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ig));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn63.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ku);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_gn);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn63.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn63.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ku);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_gn);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S653>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[64];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn64.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn64.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn64.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[64]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[64]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[64]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[64]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[64]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[64]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[64]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn64.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn64.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn64.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn64.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_a3;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn64.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn64.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn64.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn64.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_jc));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn64.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_kw);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_mq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nt);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn64.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn64.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_kw);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_mq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nt);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S655>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[65];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn65.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn65.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn65.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[65]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[65]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[65]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[65]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[65]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[65]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[65]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn65.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn65.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn65.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn65.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_lc;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn65.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn65.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn65.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn65.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_gh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn65.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ii);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bo);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_nk);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn65.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn65.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ii);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bo);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_nk);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S659>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[66];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn66.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn66.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn66.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[66]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[66]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[66]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[66]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[66]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[66]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[66]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn66.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn66.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn66.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn66.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_hp;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn66.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn66.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn66.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn66.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_cu));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn66.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_os);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_o3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jf);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn66.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn66.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_os);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_o3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jf);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S661>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[67];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn67.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn67.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn67.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[67]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[67]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[67]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[67]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[67]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[67]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[67]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn67.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn67.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn67.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn67.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ce;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn67.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn67.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn67.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn67.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ck));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Positive-Sequence)1/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn67.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_l2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ht);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ag);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn67.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn67.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_l2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ht);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ag);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S553>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[68];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn68.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn68.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn68.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[68]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[68]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[68]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[68]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[68]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[68]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[68]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn68.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn68.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn68.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn68.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_mu;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn68.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn68.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn68.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn68.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_me));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power/Fourier/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn68.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ez);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ba);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cc);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn68.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn68.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ez);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ba);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cc);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S555>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[69];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn69.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn69.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn69.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[69]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[69]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[69]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[69]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[69]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[69]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[69]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn69.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn69.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn69.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn69.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ddm;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn69.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn69.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn69.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn69.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_mk));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power/Fourier/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn69.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_h3);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_p);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ea);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn69.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn69.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_h3);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_p);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ea);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S559>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[70];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn70.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn70.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn70.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[70]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[70]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[70]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[70]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[70]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[70]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[70]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn70.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn70.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn70.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn70.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m1;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn70.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn70.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn70.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn70.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_i11));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power/Fourier1/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn70.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_bg);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_da);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bh);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn70.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn70.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_bg);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_da);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bh);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S561>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[71];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn71.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn71.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn71.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[71]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[71]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[71]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[71]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[71]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[71]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[71]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn71.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn71.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn71.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn71.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_nr;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn71.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn71.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn71.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn71.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ib));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power/Fourier1/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn71.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_jq);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_m1);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fn);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn71.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn71.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_jq);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_m1);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fn);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S573>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[72];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn72.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn72.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn72.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[72]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[72]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[72]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[72]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[72]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[72]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[72]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn72.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn72.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn72.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn72.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ab;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn72.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn72.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn72.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn72.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_kf));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn72.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_dv);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bz);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_km);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn72.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn72.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_dv);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bz);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_km);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S575>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[73];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn73.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn73.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn73.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[73]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[73]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[73]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[73]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[73]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[73]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[73]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn73.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn73.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn73.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn73.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_cc;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn73.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn73.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn73.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn73.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_nj));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn73.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_g0s);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_llq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pi);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn73.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn73.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_g0s);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_llq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pi);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S579>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[74];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn74.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn74.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn74.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[74]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[74]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[74]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[74]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[74]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[74]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[74]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn74.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn74.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn74.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn74.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_m3;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn74.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn74.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn74.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn74.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ix));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn74.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_be);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ks);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k4k);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn74.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn74.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_be);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ks);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k4k);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S581>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[75];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn75.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn75.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn75.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[75]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[75]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[75]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[75]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[75]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[75]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[75]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn75.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn75.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn75.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn75.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ocz;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn75.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn75.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn75.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn75.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_b3));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn75.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ab);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_gl);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ju);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn75.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn75.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ab);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_gl);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ju);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S585>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[76];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn76.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn76.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn76.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[76]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[76]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[76]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[76]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[76]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[76]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[76]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn76.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn76.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn76.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn76.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_frw;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn76.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn76.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn76.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn76.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_be));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn76.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_cp);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ik);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_kx);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn76.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn76.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_cp);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ik);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_kx);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S587>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[77];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn77.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn77.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn77.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[77]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[77]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[77]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[77]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[77]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[77]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[77]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn77.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn77.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn77.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn77.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ah;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn77.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn77.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn77.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn77.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_cs));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn77.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_i2);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cd);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_j3);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn77.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn77.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_i2);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cd);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_j3);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S597>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[78];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn78.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn78.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn78.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[78]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[78]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[78]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[78]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[78]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[78]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[78]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn78.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn78.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn78.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn78.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_jz;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn78.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn78.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn78.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn78.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_kz));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn78.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lp);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_a3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_dd);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn78.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn78.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lp);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_a3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_dd);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S599>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[79];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn79.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn79.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn79.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[79]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[79]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[79]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[79]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[79]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[79]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[79]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn79.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn79.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn79.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn79.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_oe;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn79.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn79.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn79.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn79.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ns));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn79.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ct);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nzb);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_p2);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn79.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn79.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ct);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nzb);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_p2);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S603>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[80];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn80.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn80.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn80.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[80]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[80]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[80]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[80]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[80]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[80]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[80]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn80.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn80.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn80.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn80.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ea;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn80.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn80.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn80.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn80.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_f3));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn80.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_kb);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_l3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pw);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn80.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn80.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_kb);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_l3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pw);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S605>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[81];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn81.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn81.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn81.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[81]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[81]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[81]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[81]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[81]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[81]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[81]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn81.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn81.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn81.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn81.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_no;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn81.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn81.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn81.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn81.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_hx));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn81.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nz);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_gw);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_dh);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn81.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn81.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nz);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_gw);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_dh);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S609>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[82];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn82.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn82.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn82.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[82]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[82]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[82]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[82]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[82]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[82]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[82]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn82.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn82.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn82.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn82.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ex;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn82.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn82.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn82.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn82.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_bh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn82.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_hp);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_bq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_cs);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn82.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn82.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_hp);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_bq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_cs);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S611>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[83];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn83.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn83.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn83.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[83]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[83]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[83]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[83]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[83]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[83]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[83]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn83.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn83.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn83.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn83.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ij;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn83.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn83.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn83.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn83.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_mr));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Power (Pos. Seq.)/Sequence Analyzer1/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn83.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ay);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_oh);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_n5);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn83.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn83.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ay);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_oh);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_n5);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S671>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[84];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn84.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn84.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn84.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[84]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[84]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[84]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[84]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[84]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[84]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[84]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn84.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn84.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn84.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn84.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_fg;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn84.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn84.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn84.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn84.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_j4));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/V1 meas/Fourier_A/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn84.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_nv);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_i5);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_dx);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn84.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn84.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_nv);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_i5);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_dx);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S673>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[85];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn85.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn85.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn85.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[85]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[85]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[85]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[85]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[85]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[85]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[85]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn85.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn85.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn85.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn85.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_kv;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn85.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn85.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn85.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn85.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/V1 meas/Fourier_A/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn85.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fc1);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_nc);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_ce);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn85.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn85.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fc1);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_nc);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_ce);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S677>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[86];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn86.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn86.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn86.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[86]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[86]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[86]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[86]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[86]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[86]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[86]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn86.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn86.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn86.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn86.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ks;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn86.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn86.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn86.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn86.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_h1o));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/V1 meas/Fourier_B/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn86.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_dva);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_ed);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_fnk);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn86.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn86.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_dva);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_ed);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_fnk);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S679>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[87];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn87.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn87.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn87.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[87]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[87]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[87]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[87]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[87]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[87]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[87]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn87.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn87.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn87.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn87.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_dl;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn87.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn87.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn87.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn87.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ds));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/V1 meas/Fourier_B/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn87.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_ox);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_avv);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_jv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn87.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn87.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_ox);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_avv);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_jv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S683>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[88];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn88.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn88.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn88.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[88]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[88]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[88]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[88]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[88]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[88]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[88]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn88.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn88.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn88.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn88.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_kd;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn88.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn88.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn88.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn88.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_in));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/V1 meas/Fourier_C/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn88.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_bj);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_cq);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_k41);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn88.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn88.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_bj);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_cq);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_k41);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S685>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[89];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn89.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn89.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn89.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[89]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[89]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[89]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[89]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[89]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[89]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[89]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn89.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn89.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn89.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn89.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_id;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn89.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn89.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn89.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn89.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ev));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/V1 meas/Fourier_C/Mean value1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn89.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lr);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_dk);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_bfb);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn89.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn89.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lr);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_dk);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_bfb);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S545>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[90];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn90.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn90.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn90.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[90]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[90]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[90]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[90]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[90]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[90]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[90]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn90.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn90.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn90.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn90.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_ddl;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn90.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn90.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn90.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn90.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_ga));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Mean2/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn90.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_e3);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_aa);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_kq);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn90.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn90.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_e3);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_aa);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_kq);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S541>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[91];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn91.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn91.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn91.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[91]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[91]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[91]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[91]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[91]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[91]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[91]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn91.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn91.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn91.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn91.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pt;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn91.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn91.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn91.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn91.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_lh));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Mean/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn91.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_fch);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_f3);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_pv);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn91.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn91.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_fch);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_f3);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_pv);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }

    /* Level2 S-Function Block: power_converters_switching_function/<S543>/S-Function (sfun_discreteVariableDelay) */
    {
      SimStruct *rts = rtM->childSfunctions[92];

      /* timing info */
      time_T *sfcnPeriod = rtM->NonInlinedSFcns.Sfcn92.sfcnPeriod;
      time_T *sfcnOffset = rtM->NonInlinedSFcns.Sfcn92.sfcnOffset;
      int_T *sfcnTsMap = rtM->NonInlinedSFcns.Sfcn92.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      {
        ssSetBlkInfo2Ptr(rts, &rtM->NonInlinedSFcns.blkInfo2[92]);
      }

      _ssSetBlkInfo2PortInfo2Ptr(rts, &rtM->
        NonInlinedSFcns.inputOutputPortInfo2[92]);

      /* Set up the mdlInfo pointer */
      ssSetRTWSfcnInfo(rts, rtM->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &rtM->NonInlinedSFcns.methods2[92]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &rtM->NonInlinedSFcns.methods3[92]);
      }

      /* Allocate memory of model methods 4 */
      {
        ssSetModelMethods4(rts, &rtM->NonInlinedSFcns.methods4[92]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &rtM->NonInlinedSFcns.statesInfo2[92]);
        ssSetPeriodicStatesInfo(rts, &rtM->NonInlinedSFcns.periodicStatesInfo[92]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 2);
        ssSetPortInfoForInputs(rts, &rtM->NonInlinedSFcns.Sfcn92.inputPortInfo[0]);
        _ssSetPortInfo2ForInputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn92.inputPortUnits[0]);
        ssSetInputPortUnit(rts, 0, 0);
        ssSetInputPortUnit(rts, 1, 0);
        _ssSetPortInfo2ForInputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn92.inputPortCoSimAttribute[0]);
        ssSetInputPortIsContinuousQuantity(rts, 0, 0);
        ssSetInputPortIsContinuousQuantity(rts, 1, 0);

        /* port 0 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn92.UPtrs0;
          sfcnUPtrs[0] = &rtDW.Integ4_pf;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }

        /* port 1 */
        {
          real_T const **sfcnUPtrs = (real_T const **)
            &rtM->NonInlinedSFcns.Sfcn92.UPtrs1;
          sfcnUPtrs[0] = &rtConstP.pooled68;
          ssSetInputPortSignalPtrs(rts, 1, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 1, 1);
          ssSetInputPortWidth(rts, 1, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts, &rtM->
          NonInlinedSFcns.Sfcn92.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);
        _ssSetPortInfo2ForOutputUnits(rts,
          &rtM->NonInlinedSFcns.Sfcn92.outputPortUnits[0]);
        ssSetOutputPortUnit(rts, 0, 0);
        _ssSetPortInfo2ForOutputCoSimAttribute(rts,
          &rtM->NonInlinedSFcns.Sfcn92.outputPortCoSimAttribute[0]);
        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *) &rtDW.SFunction_p2));
        }
      }

      /* path info */
      ssSetModelName(rts, "S-Function");
      ssSetPath(rts,
                "power_converters_switching_function/Scopes/Mean1/Model/Discrete Variable Time Delay/S-Function");
      ssSetRTModel(rts,rtM);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **) &rtM->NonInlinedSFcns.Sfcn92.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)rtConstP.pooled69);
        ssSetSFcnParam(rts, 1, (mxArray*)rtConstP.pooled15);
        ssSetSFcnParam(rts, 2, (mxArray*)rtConstP.pooled17);
        ssSetSFcnParam(rts, 3, (mxArray*)rtConstP.pooled19);
      }

      /* work vectors */
      ssSetRWork(rts, (real_T *) &rtDW.SFunction_RWORK_lq);
      ssSetIWork(rts, (int_T *) &rtDW.SFunction_IWORK_hj);
      ssSetPWork(rts, (void **) &rtDW.SFunction_PWORK_n1);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &rtM->NonInlinedSFcns.Sfcn92.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &rtM->NonInlinedSFcns.Sfcn92.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 3);

        /* RWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_DOUBLE);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &rtDW.SFunction_RWORK_lq);

        /* IWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &rtDW.SFunction_IWORK_hj);

        /* PWORK */
        ssSetDWorkWidth(rts, 2, 1);
        ssSetDWorkDataType(rts, 2,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 2, 0);
        ssSetDWork(rts, 2, &rtDW.SFunction_PWORK_n1);
      }

      /* registration */
      sfun_discreteVariableDelay(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 5.0E-6);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 1);
      ssSetInputPortDataType(rts, 0, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetInputPortUnit(rts, 0, 0);
      ssSetInputPortIsContinuousQuantity(rts, 0, 0);
      ssSetInputPortWidth(rts, 1, 1);
      ssSetInputPortDataType(rts, 1, SS_DOUBLE);
      ssSetInputPortComplexSignal(rts, 1, 0);
      ssSetInputPortFrameData(rts, 1, 0);
      ssSetInputPortUnit(rts, 1, 0);
      ssSetInputPortIsContinuousQuantity(rts, 1, 0);
      ssSetOutputPortWidth(rts, 0, 1);
      ssSetOutputPortDataType(rts, 0, SS_DOUBLE);
      ssSetOutputPortComplexSignal(rts, 0, 0);
      ssSetOutputPortFrameData(rts, 0, 0);
      ssSetOutputPortUnit(rts, 0, 0);
      ssSetOutputPortIsContinuousQuantity(rts, 0, 0);
      ssSetNumIWork(rts, 1);
      ssSetNumPWork(rts, 1);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetInputPortConnected(rts, 1, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
      ssSetInputPortBufferDstPort(rts, 1, -1);
    }
  }

  /* Start for S-Function (sfun_spssw_discc): '<S953>/State-Space' incorporates:
   *  Constant: '<S354>/DC'
   */

  /* S-Function block: <S953>/State-Space */
  {
    rtDW.StateSpace_PWORK.AS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.BS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.CS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.DS = (real_T*)calloc(1 * 1, sizeof(real_T));
    rtDW.StateSpace_PWORK.DX_COL = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.TMP2 = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.BD_COL = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.TMP1 = (real_T*)calloc(1, sizeof(real_T));
    rtDW.StateSpace_PWORK.XTMP = (real_T*)calloc(1, sizeof(real_T));
  }

  /* Start for Enabled SubSystem: '<S81>/PWM gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S163>/S-Function' incorporates:
   *  Constant: '<S162>/K1'
   */
  /* Level2 S-Function Block: '<S163>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S165>/S-Function' incorporates:
   *  Constant: '<S164>/K1'
   */
  /* Level2 S-Function Block: '<S165>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S81>/PWM gen' */

  /* Start for S-Function (sfun_spssw_discc): '<S954>/State-Space' incorporates:
   *  Constant: '<S381>/eee'
   *  Constant: '<S383>/eee'
   *  Constant: '<S959>/SwitchCurrents'
   */

  /* S-Function block: <S954>/State-Space */
  {
    rtDW.StateSpace_PWORK_n.AS = (real_T*)calloc(2 * 2, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.BS = (real_T*)calloc(2 * 6, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.CS = (real_T*)calloc(6 * 2, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.DS = (real_T*)calloc(6 * 6, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.DX_COL = (real_T*)calloc(6, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.TMP2 = (real_T*)calloc(6, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.BD_COL = (real_T*)calloc(2, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.TMP1 = (real_T*)calloc(2, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.XTMP = (real_T*)calloc(2, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.SWITCH_STATUS = (int_T*)calloc(2, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.SW_CHG = (int_T*)calloc(2, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.G_STATE = (int_T*)calloc(2, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.Y_SWITCH = (real_T*)calloc(2, sizeof(real_T));
    rtDW.StateSpace_PWORK_n.SWITCH_TYPES = (int_T*)calloc(2, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.IDX_OUT_SW = (int_T*)calloc(2, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.SWITCH_STATUS_INIT = (int_T*)calloc(2, sizeof(int_T));
    rtDW.StateSpace_PWORK_n.USWLAST = (real_T*)calloc(2, sizeof(real_T));
  }

  /* Start for Enabled SubSystem: '<S80>/PWM Gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */
  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S80>/PWM Gen' */

  /* Start for Enabled SubSystem: '<S79>/PWM Gen' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S145>/S-Function' incorporates:
   *  Constant: '<S144>/K1'
   */
  /* Level2 S-Function Block: '<S145>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S79>/PWM Gen' */

  /* Start for Enabled SubSystem: '<S78>/PWMgen - Averaging' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */
  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S135>/S-Function' incorporates:
   *  Constant: '<S134>/K1'
   */
  /* Level2 S-Function Block: '<S135>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S78>/PWMgen - Averaging' */

  /* Start for Enabled SubSystem: '<S76>/PWMgen - Averaging' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S95>/S-Function' incorporates:
   *  Constant: '<S94>/K1'
   */
  /* Level2 S-Function Block: '<S95>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S97>/S-Function' incorporates:
   *  Constant: '<S96>/K1'
   */
  /* Level2 S-Function Block: '<S97>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S76>/PWMgen - Averaging' */

  /* Start for RateTransition: '<S75>/Rate Transition2' */
  rtDW.RateTransition2 = 0.7;

  /* Start for Enabled SubSystem: '<S77>/Subsystem' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */
  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S77>/Subsystem' */

  /* Start for Enabled SubSystem: '<S82>/Subsystem' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S181>/S-Function' incorporates:
   *  Constant: '<S180>/K1'
   */
  /* Level2 S-Function Block: '<S181>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S82>/Subsystem' */

  /* Start for S-Function (sfun_spssw_discc): '<S955>/State-Space' incorporates:
   *  Constant: '<S355>/DC'
   *  Constant: '<S405>/eee'
   *  Constant: '<S407>/eee'
   *  Constant: '<S54>/eee'
   *  Constant: '<S705>/eee'
   *  Constant: '<S707>/eee'
   *  Constant: '<S727>/eee'
   *  Constant: '<S729>/eee'
   *  Constant: '<S72>/eee'
   *  Constant: '<S749>/eee'
   *  Constant: '<S751>/eee'
   *  Constant: '<S779>/eee'
   *  Constant: '<S781>/eee'
   *  Constant: '<S798>/eee'
   *  Constant: '<S800>/eee'
   *  Constant: '<S817>/eee'
   *  Constant: '<S819>/eee'
   *  Constant: '<S839>/eee'
   *  Constant: '<S841>/eee'
   *  Constant: '<S858>/eee'
   *  Constant: '<S860>/eee'
   *  Constant: '<S877>/eee'
   *  Constant: '<S879>/eee'
   *  Constant: '<S897>/eee'
   *  Constant: '<S899>/eee'
   *  Constant: '<S963>/SwitchCurrents'
   */

  /* S-Function block: <S955>/State-Space */
  {
    rtDW.StateSpace_PWORK_f.AS = (real_T*)calloc(38 * 38, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.BS = (real_T*)calloc(38 * 95, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.CS = (real_T*)calloc(92 * 38, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.DS = (real_T*)calloc(92 * 95, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.DX_COL = (real_T*)calloc(92, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.TMP2 = (real_T*)calloc(95, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.BD_COL = (real_T*)calloc(38, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.TMP1 = (real_T*)calloc(38, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.XTMP = (real_T*)calloc(38, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.SWITCH_STATUS = (int_T*)calloc(24, sizeof(int_T));
    rtDW.StateSpace_PWORK_f.SW_CHG = (int_T*)calloc(24, sizeof(int_T));
    rtDW.StateSpace_PWORK_f.G_STATE = (int_T*)calloc(24, sizeof(int_T));
    rtDW.StateSpace_PWORK_f.Y_SWITCH = (real_T*)calloc(24, sizeof(real_T));
    rtDW.StateSpace_PWORK_f.SWITCH_TYPES = (int_T*)calloc(24, sizeof(int_T));
    rtDW.StateSpace_PWORK_f.IDX_OUT_SW = (int_T*)calloc(24, sizeof(int_T));
    rtDW.StateSpace_PWORK_f.SWITCH_STATUS_INIT = (int_T*)calloc(24, sizeof(int_T));
    rtDW.StateSpace_PWORK_f.USWLAST = (real_T*)calloc(24, sizeof(real_T));
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */
  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */
  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */
  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */
  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S457>/S-Function' incorporates:
   *  Constant: '<S456>/K1'
   */
  /* Level2 S-Function Block: '<S457>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S455>/S-Function' incorporates:
   *  Constant: '<S454>/K1'
   */
  /* Level2 S-Function Block: '<S455>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */
  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S467>/S-Function' incorporates:
   *  Constant: '<S466>/K1'
   */
  /* Level2 S-Function Block: '<S467>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */
  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S473>/S-Function' incorporates:
   *  Constant: '<S472>/K1'
   */
  /* Level2 S-Function Block: '<S473>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S481>/S-Function' incorporates:
   *  Constant: '<S480>/K1'
   */
  /* Level2 S-Function Block: '<S481>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S479>/S-Function' incorporates:
   *  Constant: '<S478>/K1'
   */
  /* Level2 S-Function Block: '<S479>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S913>/S-Function' incorporates:
   *  Constant: '<S912>/K1'
   */
  /* Level2 S-Function Block: '<S913>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S911>/S-Function' incorporates:
   *  Constant: '<S910>/K1'
   */
  /* Level2 S-Function Block: '<S911>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S919>/S-Function' incorporates:
   *  Constant: '<S918>/K1'
   */
  /* Level2 S-Function Block: '<S919>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S917>/S-Function' incorporates:
   *  Constant: '<S916>/K1'
   */
  /* Level2 S-Function Block: '<S917>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S925>/S-Function' incorporates:
   *  Constant: '<S924>/K1'
   */
  /* Level2 S-Function Block: '<S925>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S923>/S-Function' incorporates:
   *  Constant: '<S922>/K1'
   */
  /* Level2 S-Function Block: '<S923>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S411>/S-Function' incorporates:
   *  Constant: '<S410>/K1'
   */
  /* Level2 S-Function Block: '<S411>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */
  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */
  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S417>/S-Function' incorporates:
   *  Constant: '<S416>/K1'
   */
  /* Level2 S-Function Block: '<S417>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */
  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S423>/S-Function' incorporates:
   *  Constant: '<S422>/K1'
   */
  /* Level2 S-Function Block: '<S423>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S431>/S-Function' incorporates:
   *  Constant: '<S430>/K1'
   */
  /* Level2 S-Function Block: '<S431>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S429>/S-Function' incorporates:
   *  Constant: '<S428>/K1'
   */
  /* Level2 S-Function Block: '<S429>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */
  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */
  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */
  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */
  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S507>/S-Function' incorporates:
   *  Constant: '<S506>/K1'
   */
  /* Level2 S-Function Block: '<S507>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S505>/S-Function' incorporates:
   *  Constant: '<S504>/K1'
   */
  /* Level2 S-Function Block: '<S505>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S519>/S-Function' incorporates:
   *  Constant: '<S518>/K1'
   */
  /* Level2 S-Function Block: '<S519>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */
  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */
  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */
  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */
  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */
  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for InitialCondition: '<S205>/Initial' */
  rtDW.Initial_FirstOutputTime = true;

  /* Start for InitialCondition: '<S284>/Initial' */
  rtDW.Initial_FirstOutputTime_m = true;

  /* Start for S-Function (sfun_discreteVariableDelay): '<S281>/S-Function' incorporates:
   *  Constant: '<S280>/K1'
   */
  /* Level2 S-Function Block: '<S281>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for Enabled SubSystem: '<S284>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S296>/S-Function' */
  /* Level2 S-Function Block: '<S296>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S299>/S-Function' */
  /* Level2 S-Function Block: '<S299>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S284>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S312>/S-Function' */
  /* Level2 S-Function Block: '<S312>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for Enabled SubSystem: '<S205>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S217>/S-Function' */
  /* Level2 S-Function Block: '<S217>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S220>/S-Function' */
  /* Level2 S-Function Block: '<S220>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of Start for SubSystem: '<S205>/Automatic Gain Control' */

  /* Start for S-Function (sfun_discreteVariableDelay): '<S233>/S-Function' */
  /* Level2 S-Function Block: '<S233>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S547>/S-Function' incorporates:
   *  Constant: '<S546>/K1'
   */
  /* Level2 S-Function Block: '<S547>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */
  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */
  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */
  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */
  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S635>/S-Function' incorporates:
   *  Constant: '<S634>/K1'
   */
  /* Level2 S-Function Block: '<S635>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S637>/S-Function' incorporates:
   *  Constant: '<S636>/K1'
   */
  /* Level2 S-Function Block: '<S637>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */
  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */
  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */
  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */
  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S659>/S-Function' incorporates:
   *  Constant: '<S658>/K1'
   */
  /* Level2 S-Function Block: '<S659>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S661>/S-Function' incorporates:
   *  Constant: '<S660>/K1'
   */
  /* Level2 S-Function Block: '<S661>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S553>/S-Function' incorporates:
   *  Constant: '<S552>/K1'
   */
  /* Level2 S-Function Block: '<S553>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */
  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S559>/S-Function' incorporates:
   *  Constant: '<S558>/K1'
   */
  /* Level2 S-Function Block: '<S559>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S561>/S-Function' incorporates:
   *  Constant: '<S560>/K1'
   */
  /* Level2 S-Function Block: '<S561>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */
  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */
  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */
  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */
  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S585>/S-Function' incorporates:
   *  Constant: '<S584>/K1'
   */
  /* Level2 S-Function Block: '<S585>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S587>/S-Function' incorporates:
   *  Constant: '<S586>/K1'
   */
  /* Level2 S-Function Block: '<S587>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S597>/S-Function' incorporates:
   *  Constant: '<S596>/K1'
   */
  /* Level2 S-Function Block: '<S597>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */
  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S603>/S-Function' incorporates:
   *  Constant: '<S602>/K1'
   */
  /* Level2 S-Function Block: '<S603>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */
  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S609>/S-Function' incorporates:
   *  Constant: '<S608>/K1'
   */
  /* Level2 S-Function Block: '<S609>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S611>/S-Function' incorporates:
   *  Constant: '<S610>/K1'
   */
  /* Level2 S-Function Block: '<S611>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S671>/S-Function' incorporates:
   *  Constant: '<S670>/K1'
   */
  /* Level2 S-Function Block: '<S671>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S673>/S-Function' incorporates:
   *  Constant: '<S672>/K1'
   */
  /* Level2 S-Function Block: '<S673>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S677>/S-Function' incorporates:
   *  Constant: '<S676>/K1'
   */
  /* Level2 S-Function Block: '<S677>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S679>/S-Function' incorporates:
   *  Constant: '<S678>/K1'
   */
  /* Level2 S-Function Block: '<S679>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S683>/S-Function' incorporates:
   *  Constant: '<S682>/K1'
   */
  /* Level2 S-Function Block: '<S683>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S685>/S-Function' incorporates:
   *  Constant: '<S684>/K1'
   */
  /* Level2 S-Function Block: '<S685>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */
  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S541>/S-Function' incorporates:
   *  Constant: '<S540>/K1'
   */
  /* Level2 S-Function Block: '<S541>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* Start for S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */
  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnStart(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_spssw_discc): '<S953>/State-Space' incorporates:
   *  Constant: '<S354>/DC'
   */
  {
    int32_T i, j;
    real_T *As = (real_T*)rtDW.StateSpace_PWORK.AS;
    real_T *Bs = (real_T*)rtDW.StateSpace_PWORK.BS;
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK.DS;
    real_T *X0 = (real_T*)&rtDW.StateSpace_DSTATE;
    for (i = 0; i < 1; i++) {
      X0[i] = 500001.56250000012;
    }

    /* Copy and transpose A and B */
    for (i=0; i<1; i++) {
      for (j=0; j<1; j++)
        As[i*1 + j] = 0.99999375001953117;
      for (j=0; j<1; j++)
        Bs[i*1 + j] = 0.0062499804688110347;
    }

    /* Copy and transpose C */
    for (i=0; i<1; i++) {
      for (j=0; j<1; j++)
        Cs[i*1 + j] = 4.9999843750488282E-6;
    }

    /* Copy and transpose D */
    for (i=0; i<1; i++) {
      for (j=0; j<1; j++)
        Ds[i*1 + j] = 1.5624951172027588E-8;
    }
  }

  /* InitializeConditions for S-Function (sfun_spssw_discc): '<S954>/State-Space' incorporates:
   *  Constant: '<S381>/eee'
   *  Constant: '<S383>/eee'
   *  Constant: '<S959>/SwitchCurrents'
   */
  {
    int32_T i, j;
    real_T *As = (real_T*)rtDW.StateSpace_PWORK_n.AS;
    real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_n.BS;
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_n.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_n.DS;
    real_T *X0 = (real_T*)&rtDW.StateSpace_DSTATE_d[0];
    for (i = 0; i < 2; i++) {
      X0[i] = (rtConstP.pooled23[i]);
    }

    /* Copy and transpose A and B */
    for (i=0; i<2; i++) {
      for (j=0; j<2; j++)
        As[i*2 + j] = (rtConstP.StateSpace_AS_param_h[i + j*2]);
      for (j=0; j<6; j++)
        Bs[i*6 + j] = (rtConstP.StateSpace_BS_param_k[i + j*2]);
    }

    /* Copy and transpose C */
    for (i=0; i<6; i++) {
      for (j=0; j<2; j++)
        Cs[i*2 + j] = (rtConstP.StateSpace_CS_param_i[i + j*6]);
    }

    /* Copy and transpose D */
    for (i=0; i<6; i++) {
      for (j=0; j<6; j++)
        Ds[i*6 + j] = (rtConstP.StateSpace_DS_param_f[i + j*6]);
    }

    {
      /* Switches work vectors */
      int_T *switch_status = (int_T*) rtDW.StateSpace_PWORK_n.SWITCH_STATUS;
      int_T *gState = (int_T*)rtDW.StateSpace_PWORK_n.G_STATE;
      real_T *yswitch = (real_T*)rtDW.StateSpace_PWORK_n.Y_SWITCH;
      int_T *switchTypes = (int_T*)rtDW.StateSpace_PWORK_n.SWITCH_TYPES;
      int_T *idxOutSw = (int_T*)rtDW.StateSpace_PWORK_n.IDX_OUT_SW;
      int_T *switch_status_init = (int_T*)
        rtDW.StateSpace_PWORK_n.SWITCH_STATUS_INIT;

      /* Initialize work vectors */
      switch_status[0] = 0;
      switch_status_init[0] = 0;
      gState[0] = (int_T) 0.0;
      yswitch[0] = 1/0.001;
      switchTypes[0] = (int_T)3.0;
      idxOutSw[0] = ((int_T)0.0) - 1;
      switch_status[1] = 0;
      switch_status_init[1] = 0;
      gState[1] = (int_T) 0.0;
      yswitch[1] = 1/0.001;
      switchTypes[1] = (int_T)3.0;
      idxOutSw[1] = ((int_T)0.0) - 1;
    }
  }

  /* InitializeConditions for DiscreteIntegrator: '<S346>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE = 125.66370614359172;

  /* InitializeConditions for UnitDelay: '<S346>/KE filter' */
  rtDW.KEfilter_DSTATE = 2.5;

  /* InitializeConditions for RateTransition: '<S75>/Rate Transition2' */
  rtDW.RateTransition2_Buffer0 = 0.7;

  /* InitializeConditions for S-Function (sfun_spssw_discc): '<S955>/State-Space' incorporates:
   *  Constant: '<S355>/DC'
   *  Constant: '<S405>/eee'
   *  Constant: '<S407>/eee'
   *  Constant: '<S54>/eee'
   *  Constant: '<S705>/eee'
   *  Constant: '<S707>/eee'
   *  Constant: '<S727>/eee'
   *  Constant: '<S729>/eee'
   *  Constant: '<S72>/eee'
   *  Constant: '<S749>/eee'
   *  Constant: '<S751>/eee'
   *  Constant: '<S779>/eee'
   *  Constant: '<S781>/eee'
   *  Constant: '<S798>/eee'
   *  Constant: '<S800>/eee'
   *  Constant: '<S817>/eee'
   *  Constant: '<S819>/eee'
   *  Constant: '<S839>/eee'
   *  Constant: '<S841>/eee'
   *  Constant: '<S858>/eee'
   *  Constant: '<S860>/eee'
   *  Constant: '<S877>/eee'
   *  Constant: '<S879>/eee'
   *  Constant: '<S897>/eee'
   *  Constant: '<S899>/eee'
   *  Constant: '<S963>/SwitchCurrents'
   */
  {
    int32_T i, j;
    real_T *As = (real_T*)rtDW.StateSpace_PWORK_f.AS;
    real_T *Bs = (real_T*)rtDW.StateSpace_PWORK_f.BS;
    real_T *Cs = (real_T*)rtDW.StateSpace_PWORK_f.CS;
    real_T *Ds = (real_T*)rtDW.StateSpace_PWORK_f.DS;
    real_T *X0 = (real_T*)&rtDW.StateSpace_DSTATE_l[0];
    for (i = 0; i < 38; i++) {
      X0[i] = (rtConstP.StateSpace_X0_param_c[i]);
    }

    /* Copy and transpose A and B */
    for (i=0; i<38; i++) {
      for (j=0; j<38; j++)
        As[i*38 + j] = (rtConstP.StateSpace_AS_param_b[i + j*38]);
      for (j=0; j<95; j++)
        Bs[i*95 + j] = (rtConstP.StateSpace_BS_param_m[i + j*38]);
    }

    /* Copy and transpose C */
    for (i=0; i<92; i++) {
      for (j=0; j<38; j++)
        Cs[i*38 + j] = (rtConstP.StateSpace_CS_param_f[i + j*92]);
    }

    /* Copy and transpose D */
    for (i=0; i<92; i++) {
      for (j=0; j<95; j++)
        Ds[i*95 + j] = (rtConstP.StateSpace_DS_param_e[i + j*92]);
    }

    {
      /* Switches work vectors */
      int_T *switch_status = (int_T*) rtDW.StateSpace_PWORK_f.SWITCH_STATUS;
      int_T *gState = (int_T*)rtDW.StateSpace_PWORK_f.G_STATE;
      real_T *yswitch = (real_T*)rtDW.StateSpace_PWORK_f.Y_SWITCH;
      int_T *switchTypes = (int_T*)rtDW.StateSpace_PWORK_f.SWITCH_TYPES;
      int_T *idxOutSw = (int_T*)rtDW.StateSpace_PWORK_f.IDX_OUT_SW;
      int_T *switch_status_init = (int_T*)
        rtDW.StateSpace_PWORK_f.SWITCH_STATUS_INIT;

      /* Initialize work vectors */
      switch_status[0] = 0;
      switch_status_init[0] = 0;
      gState[0] = (int_T) 0.0;
      yswitch[0] = 1/0.001;
      switchTypes[0] = (int_T)3.0;
      idxOutSw[0] = ((int_T)0.0) - 1;
      switch_status[1] = 0;
      switch_status_init[1] = 0;
      gState[1] = (int_T) 0.0;
      yswitch[1] = 1/0.001;
      switchTypes[1] = (int_T)3.0;
      idxOutSw[1] = ((int_T)0.0) - 1;
      switch_status[2] = 0;
      switch_status_init[2] = 0;
      gState[2] = (int_T) 0.0;
      yswitch[2] = 1/0.001;
      switchTypes[2] = (int_T)3.0;
      idxOutSw[2] = ((int_T)0.0) - 1;
      switch_status[3] = 0;
      switch_status_init[3] = 0;
      gState[3] = (int_T) 0.0;
      yswitch[3] = 1/0.001;
      switchTypes[3] = (int_T)3.0;
      idxOutSw[3] = ((int_T)0.0) - 1;
      switch_status[4] = 0;
      switch_status_init[4] = 0;
      gState[4] = (int_T) 0.0;
      yswitch[4] = 1/0.001;
      switchTypes[4] = (int_T)3.0;
      idxOutSw[4] = ((int_T)0.0) - 1;
      switch_status[5] = 0;
      switch_status_init[5] = 0;
      gState[5] = (int_T) 0.0;
      yswitch[5] = 1/0.001;
      switchTypes[5] = (int_T)3.0;
      idxOutSw[5] = ((int_T)0.0) - 1;
      switch_status[6] = 0;
      switch_status_init[6] = 0;
      gState[6] = (int_T) 0.0;
      yswitch[6] = 1/0.001;
      switchTypes[6] = (int_T)3.0;
      idxOutSw[6] = ((int_T)0.0) - 1;
      switch_status[7] = 0;
      switch_status_init[7] = 0;
      gState[7] = (int_T) 0.0;
      yswitch[7] = 1/0.001;
      switchTypes[7] = (int_T)3.0;
      idxOutSw[7] = ((int_T)0.0) - 1;
      switch_status[8] = 0;
      switch_status_init[8] = 0;
      gState[8] = (int_T) 0.0;
      yswitch[8] = 1/0.001;
      switchTypes[8] = (int_T)3.0;
      idxOutSw[8] = ((int_T)0.0) - 1;
      switch_status[9] = 0;
      switch_status_init[9] = 0;
      gState[9] = (int_T) 0.0;
      yswitch[9] = 1/0.001;
      switchTypes[9] = (int_T)3.0;
      idxOutSw[9] = ((int_T)0.0) - 1;
      switch_status[10] = 0;
      switch_status_init[10] = 0;
      gState[10] = (int_T) 0.0;
      yswitch[10] = 1/0.001;
      switchTypes[10] = (int_T)3.0;
      idxOutSw[10] = ((int_T)0.0) - 1;
      switch_status[11] = 0;
      switch_status_init[11] = 0;
      gState[11] = (int_T) 0.0;
      yswitch[11] = 1/0.001;
      switchTypes[11] = (int_T)3.0;
      idxOutSw[11] = ((int_T)0.0) - 1;
      switch_status[12] = 0;
      switch_status_init[12] = 0;
      gState[12] = (int_T) 0.0;
      yswitch[12] = 1/0.001;
      switchTypes[12] = (int_T)3.0;
      idxOutSw[12] = ((int_T)0.0) - 1;
      switch_status[13] = 0;
      switch_status_init[13] = 0;
      gState[13] = (int_T) 0.0;
      yswitch[13] = 1/0.001;
      switchTypes[13] = (int_T)3.0;
      idxOutSw[13] = ((int_T)0.0) - 1;
      switch_status[14] = 0;
      switch_status_init[14] = 0;
      gState[14] = (int_T) 0.0;
      yswitch[14] = 1/0.001;
      switchTypes[14] = (int_T)3.0;
      idxOutSw[14] = ((int_T)0.0) - 1;
      switch_status[15] = 0;
      switch_status_init[15] = 0;
      gState[15] = (int_T) 0.0;
      yswitch[15] = 1/0.001;
      switchTypes[15] = (int_T)3.0;
      idxOutSw[15] = ((int_T)0.0) - 1;
      switch_status[16] = 0;
      switch_status_init[16] = 0;
      gState[16] = (int_T) 0.0;
      yswitch[16] = 1/0.001;
      switchTypes[16] = (int_T)3.0;
      idxOutSw[16] = ((int_T)0.0) - 1;
      switch_status[17] = 0;
      switch_status_init[17] = 0;
      gState[17] = (int_T) 0.0;
      yswitch[17] = 1/0.001;
      switchTypes[17] = (int_T)3.0;
      idxOutSw[17] = ((int_T)0.0) - 1;
      switch_status[18] = 0;
      switch_status_init[18] = 0;
      gState[18] = (int_T) 0.0;
      yswitch[18] = 1/0.001;
      switchTypes[18] = (int_T)3.0;
      idxOutSw[18] = ((int_T)0.0) - 1;
      switch_status[19] = 0;
      switch_status_init[19] = 0;
      gState[19] = (int_T) 0.0;
      yswitch[19] = 1/0.001;
      switchTypes[19] = (int_T)3.0;
      idxOutSw[19] = ((int_T)0.0) - 1;
      switch_status[20] = 0;
      switch_status_init[20] = 0;
      gState[20] = (int_T) 0.0;
      yswitch[20] = 1/0.001;
      switchTypes[20] = (int_T)3.0;
      idxOutSw[20] = ((int_T)0.0) - 1;
      switch_status[21] = 0;
      switch_status_init[21] = 0;
      gState[21] = (int_T) 0.0;
      yswitch[21] = 1/0.001;
      switchTypes[21] = (int_T)3.0;
      idxOutSw[21] = ((int_T)0.0) - 1;
      switch_status[22] = 0;
      switch_status_init[22] = 0;
      gState[22] = (int_T) 0.0;
      yswitch[22] = 1/0.001;
      switchTypes[22] = (int_T)3.0;
      idxOutSw[22] = ((int_T)0.0) - 1;
      switch_status[23] = 0;
      switch_status_init[23] = 0;
      gState[23] = (int_T) 0.0;
      yswitch[23] = 1/0.001;
      switchTypes[23] = (int_T)3.0;
      idxOutSw[23] = ((int_T)0.0) - 1;
    }
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S445>/S-Function' incorporates:
   *  Constant: '<S444>/K1'
   */
  /* Level2 S-Function Block: '<S445>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[14];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S444>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m = 20412.414523193154;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S443>/S-Function' incorporates:
   *  Constant: '<S442>/K1'
   */
  /* Level2 S-Function Block: '<S443>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[15];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S451>/S-Function' incorporates:
   *  Constant: '<S450>/K1'
   */
  /* Level2 S-Function Block: '<S451>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[16];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S450>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_fh = -10206.207261596574;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S449>/S-Function' incorporates:
   *  Constant: '<S448>/K1'
   */
  /* Level2 S-Function Block: '<S449>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[17];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S448>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jg = -17677.669529663694;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S457>/S-Function' incorporates:
   *  Constant: '<S456>/K1'
   */
  /* Level2 S-Function Block: '<S457>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[18];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S456>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_n = -10206.207261596574;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S455>/S-Function' incorporates:
   *  Constant: '<S454>/K1'
   */
  /* Level2 S-Function Block: '<S455>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[19];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S454>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_h = 17677.669529663694;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S469>/S-Function' incorporates:
   *  Constant: '<S468>/K1'
   */
  /* Level2 S-Function Block: '<S469>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[20];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S468>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_au = 50.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S467>/S-Function' incorporates:
   *  Constant: '<S466>/K1'
   */
  /* Level2 S-Function Block: '<S467>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[21];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S475>/S-Function' incorporates:
   *  Constant: '<S474>/K1'
   */
  /* Level2 S-Function Block: '<S475>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[22];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S474>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_mw = -24.999999999999989;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S473>/S-Function' incorporates:
   *  Constant: '<S472>/K1'
   */
  /* Level2 S-Function Block: '<S473>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[23];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S472>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_o = -43.301270189221938;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S481>/S-Function' incorporates:
   *  Constant: '<S480>/K1'
   */
  /* Level2 S-Function Block: '<S481>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[24];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S480>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jl = -24.999999999999989;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S479>/S-Function' incorporates:
   *  Constant: '<S478>/K1'
   */
  /* Level2 S-Function Block: '<S479>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[25];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S478>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ha = 43.301270189221938;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S913>/S-Function' incorporates:
   *  Constant: '<S912>/K1'
   */
  /* Level2 S-Function Block: '<S913>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[26];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S912>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ay = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S911>/S-Function' incorporates:
   *  Constant: '<S910>/K1'
   */
  /* Level2 S-Function Block: '<S911>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[27];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S919>/S-Function' incorporates:
   *  Constant: '<S918>/K1'
   */
  /* Level2 S-Function Block: '<S919>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[28];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S918>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ca = -0.49999999999999978;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S917>/S-Function' incorporates:
   *  Constant: '<S916>/K1'
   */
  /* Level2 S-Function Block: '<S917>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[29];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S916>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ag = -0.86602540378443871;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S925>/S-Function' incorporates:
   *  Constant: '<S924>/K1'
   */
  /* Level2 S-Function Block: '<S925>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[30];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S924>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_cr = -0.49999999999999978;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S923>/S-Function' incorporates:
   *  Constant: '<S922>/K1'
   */
  /* Level2 S-Function Block: '<S923>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[31];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S922>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_p = 0.86602540378443871;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S411>/S-Function' incorporates:
   *  Constant: '<S410>/K1'
   */
  /* Level2 S-Function Block: '<S411>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[32];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S410>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_m0 = 400000.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S413>/S-Function' incorporates:
   *  Constant: '<S412>/K1'
   */
  /* Level2 S-Function Block: '<S413>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[33];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S412>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_g = -100000.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S415>/S-Function' incorporates:
   *  Constant: '<S414>/K1'
   */
  /* Level2 S-Function Block: '<S415>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[34];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S417>/S-Function' incorporates:
   *  Constant: '<S416>/K1'
   */
  /* Level2 S-Function Block: '<S417>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[35];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S416>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lg = 300000.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S425>/S-Function' incorporates:
   *  Constant: '<S424>/K1'
   */
  /* Level2 S-Function Block: '<S425>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[36];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S424>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_jx = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S423>/S-Function' incorporates:
   *  Constant: '<S422>/K1'
   */
  /* Level2 S-Function Block: '<S423>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[37];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S431>/S-Function' incorporates:
   *  Constant: '<S430>/K1'
   */
  /* Level2 S-Function Block: '<S431>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[38];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S430>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_lz = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S429>/S-Function' incorporates:
   *  Constant: '<S428>/K1'
   */
  /* Level2 S-Function Block: '<S429>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[39];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S495>/S-Function' incorporates:
   *  Constant: '<S494>/K1'
   */
  /* Level2 S-Function Block: '<S495>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[40];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S493>/S-Function' incorporates:
   *  Constant: '<S492>/K1'
   */
  /* Level2 S-Function Block: '<S493>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[41];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S501>/S-Function' incorporates:
   *  Constant: '<S500>/K1'
   */
  /* Level2 S-Function Block: '<S501>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[42];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S499>/S-Function' incorporates:
   *  Constant: '<S498>/K1'
   */
  /* Level2 S-Function Block: '<S499>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[43];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S507>/S-Function' incorporates:
   *  Constant: '<S506>/K1'
   */
  /* Level2 S-Function Block: '<S507>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[44];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S505>/S-Function' incorporates:
   *  Constant: '<S504>/K1'
   */
  /* Level2 S-Function Block: '<S505>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[45];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S519>/S-Function' incorporates:
   *  Constant: '<S518>/K1'
   */
  /* Level2 S-Function Block: '<S519>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[46];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S517>/S-Function' incorporates:
   *  Constant: '<S516>/K1'
   */
  /* Level2 S-Function Block: '<S517>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[47];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S525>/S-Function' incorporates:
   *  Constant: '<S524>/K1'
   */
  /* Level2 S-Function Block: '<S525>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[48];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S523>/S-Function' incorporates:
   *  Constant: '<S522>/K1'
   */
  /* Level2 S-Function Block: '<S523>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[49];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S531>/S-Function' incorporates:
   *  Constant: '<S530>/K1'
   */
  /* Level2 S-Function Block: '<S531>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[50];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S529>/S-Function' incorporates:
   *  Constant: '<S528>/K1'
   */
  /* Level2 S-Function Block: '<S529>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[51];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for DiscreteIntegrator: '<S205>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_PrevRese = 2;

  /* InitializeConditions for DiscreteIntegrator: '<S284>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_PrevRe_g = 2;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S281>/S-Function' incorporates:
   *  Constant: '<S280>/K1'
   */
  /* Level2 S-Function Block: '<S281>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[52];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S280>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ai = 1.0;

  /* InitializeConditions for RateLimiter: '<S75>/Rate Limiter' */
  rtDW.PrevY_k = 1200.0;

  /* InitializeConditions for DiscreteIntegrator: '<S86>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTAT_oe = 200.0;

  /* InitializeConditions for RateLimiter: '<S75>/Rate Limiter1' */
  rtDW.PrevY_n = 200.0;

  /* InitializeConditions for UnitDelay: '<S284>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_cn4 = 60.0;

  /* InitializeConditions for DiscreteIntegrator: '<S286>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_n = 376.99111843077515;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S312>/S-Function' */
  /* Level2 S-Function Block: '<S312>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[53];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for RateLimiter: '<S284>/Rate Limiter' */
  rtDW.PrevY_l = 60.0;

  /* InitializeConditions for UnitDelay: '<S306>/Delay_x1' */
  rtDW.Delay_x1_DSTATE_l = 48.633668149093175;

  /* InitializeConditions for UnitDelay: '<S306>/Delay_x2' */
  rtDW.Delay_x2_DSTATE_j = -3.5527136788005009E-15;

  /* InitializeConditions for DiscreteIntegrator: '<S85>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTAT_om = 0.7;

  /* InitializeConditions for UnitDelay: '<S205>/Unit Delay' */
  rtDW.UnitDelay_DSTATE_fu = 60.0;

  /* InitializeConditions for DiscreteIntegrator: '<S207>/Discrete-Time Integrator' */
  rtDW.DiscreteTimeIntegrator_DSTATE_p = 376.99111843077515;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S233>/S-Function' */
  /* Level2 S-Function Block: '<S233>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[54];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for RateLimiter: '<S205>/Rate Limiter' */
  rtDW.PrevY_a = 60.0;

  /* InitializeConditions for UnitDelay: '<S227>/Delay_x1' */
  rtDW.Delay_x1_DSTATE_g = 48.633668149093175;

  /* InitializeConditions for UnitDelay: '<S227>/Delay_x2' */
  rtDW.Delay_x2_DSTATE_i = -3.5527136788005009E-15;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S547>/S-Function' incorporates:
   *  Constant: '<S546>/K1'
   */
  /* Level2 S-Function Block: '<S547>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[55];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S623>/S-Function' incorporates:
   *  Constant: '<S622>/K1'
   */
  /* Level2 S-Function Block: '<S623>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[56];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S625>/S-Function' incorporates:
   *  Constant: '<S624>/K1'
   */
  /* Level2 S-Function Block: '<S625>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[57];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S629>/S-Function' incorporates:
   *  Constant: '<S628>/K1'
   */
  /* Level2 S-Function Block: '<S629>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[58];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S631>/S-Function' incorporates:
   *  Constant: '<S630>/K1'
   */
  /* Level2 S-Function Block: '<S631>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[59];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S635>/S-Function' incorporates:
   *  Constant: '<S634>/K1'
   */
  /* Level2 S-Function Block: '<S635>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[60];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S637>/S-Function' incorporates:
   *  Constant: '<S636>/K1'
   */
  /* Level2 S-Function Block: '<S637>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[61];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S647>/S-Function' incorporates:
   *  Constant: '<S646>/K1'
   */
  /* Level2 S-Function Block: '<S647>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[62];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S649>/S-Function' incorporates:
   *  Constant: '<S648>/K1'
   */
  /* Level2 S-Function Block: '<S649>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[63];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S653>/S-Function' incorporates:
   *  Constant: '<S652>/K1'
   */
  /* Level2 S-Function Block: '<S653>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[64];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S655>/S-Function' incorporates:
   *  Constant: '<S654>/K1'
   */
  /* Level2 S-Function Block: '<S655>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[65];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S659>/S-Function' incorporates:
   *  Constant: '<S658>/K1'
   */
  /* Level2 S-Function Block: '<S659>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[66];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S661>/S-Function' incorporates:
   *  Constant: '<S660>/K1'
   */
  /* Level2 S-Function Block: '<S661>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[67];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S553>/S-Function' incorporates:
   *  Constant: '<S552>/K1'
   */
  /* Level2 S-Function Block: '<S553>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[68];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S555>/S-Function' incorporates:
   *  Constant: '<S554>/K1'
   */
  /* Level2 S-Function Block: '<S555>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[69];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S559>/S-Function' incorporates:
   *  Constant: '<S558>/K1'
   */
  /* Level2 S-Function Block: '<S559>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[70];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S561>/S-Function' incorporates:
   *  Constant: '<S560>/K1'
   */
  /* Level2 S-Function Block: '<S561>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[71];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S573>/S-Function' incorporates:
   *  Constant: '<S572>/K1'
   */
  /* Level2 S-Function Block: '<S573>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[72];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S575>/S-Function' incorporates:
   *  Constant: '<S574>/K1'
   */
  /* Level2 S-Function Block: '<S575>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[73];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S579>/S-Function' incorporates:
   *  Constant: '<S578>/K1'
   */
  /* Level2 S-Function Block: '<S579>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[74];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S581>/S-Function' incorporates:
   *  Constant: '<S580>/K1'
   */
  /* Level2 S-Function Block: '<S581>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[75];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S585>/S-Function' incorporates:
   *  Constant: '<S584>/K1'
   */
  /* Level2 S-Function Block: '<S585>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[76];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S587>/S-Function' incorporates:
   *  Constant: '<S586>/K1'
   */
  /* Level2 S-Function Block: '<S587>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[77];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S597>/S-Function' incorporates:
   *  Constant: '<S596>/K1'
   */
  /* Level2 S-Function Block: '<S597>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[78];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S599>/S-Function' incorporates:
   *  Constant: '<S598>/K1'
   */
  /* Level2 S-Function Block: '<S599>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[79];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S603>/S-Function' incorporates:
   *  Constant: '<S602>/K1'
   */
  /* Level2 S-Function Block: '<S603>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[80];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S605>/S-Function' incorporates:
   *  Constant: '<S604>/K1'
   */
  /* Level2 S-Function Block: '<S605>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[81];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S609>/S-Function' incorporates:
   *  Constant: '<S608>/K1'
   */
  /* Level2 S-Function Block: '<S609>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[82];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S611>/S-Function' incorporates:
   *  Constant: '<S610>/K1'
   */
  /* Level2 S-Function Block: '<S611>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[83];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S671>/S-Function' incorporates:
   *  Constant: '<S670>/K1'
   */
  /* Level2 S-Function Block: '<S671>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[84];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S673>/S-Function' incorporates:
   *  Constant: '<S672>/K1'
   */
  /* Level2 S-Function Block: '<S673>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[85];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S677>/S-Function' incorporates:
   *  Constant: '<S676>/K1'
   */
  /* Level2 S-Function Block: '<S677>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[86];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S679>/S-Function' incorporates:
   *  Constant: '<S678>/K1'
   */
  /* Level2 S-Function Block: '<S679>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[87];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S683>/S-Function' incorporates:
   *  Constant: '<S682>/K1'
   */
  /* Level2 S-Function Block: '<S683>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[88];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S685>/S-Function' incorporates:
   *  Constant: '<S684>/K1'
   */
  /* Level2 S-Function Block: '<S685>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[89];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S545>/S-Function' incorporates:
   *  Constant: '<S544>/K1'
   */
  /* Level2 S-Function Block: '<S545>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[90];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S541>/S-Function' incorporates:
   *  Constant: '<S540>/K1'
   */
  /* Level2 S-Function Block: '<S541>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[91];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S543>/S-Function' incorporates:
   *  Constant: '<S542>/K1'
   */
  /* Level2 S-Function Block: '<S543>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[92];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* SystemInitialize for Enabled SubSystem: '<S81>/PWM gen' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S163>/S-Function' incorporates:
   *  Constant: '<S162>/K1'
   */
  /* Level2 S-Function Block: '<S163>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[7];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S165>/S-Function' incorporates:
   *  Constant: '<S164>/K1'
   */
  /* Level2 S-Function Block: '<S165>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[8];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S81>/PWM gen' */

  /* SystemInitialize for Enabled SubSystem: '<S80>/PWM Gen' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S153>/S-Function' incorporates:
   *  Constant: '<S152>/K1'
   */
  /* Level2 S-Function Block: '<S153>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[6];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S80>/PWM Gen' */

  /* SystemInitialize for Enabled SubSystem: '<S79>/PWM Gen' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S145>/S-Function' incorporates:
   *  Constant: '<S144>/K1'
   */
  /* Level2 S-Function Block: '<S145>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[5];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S79>/PWM Gen' */

  /* SystemInitialize for Enabled SubSystem: '<S78>/PWMgen - Averaging' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S133>/S-Function' incorporates:
   *  Constant: '<S132>/K1'
   */
  /* Level2 S-Function Block: '<S133>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[3];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S135>/S-Function' incorporates:
   *  Constant: '<S134>/K1'
   */
  /* Level2 S-Function Block: '<S135>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[4];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S78>/PWMgen - Averaging' */

  /* SystemInitialize for Enabled SubSystem: '<S76>/PWMgen - Averaging' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S95>/S-Function' incorporates:
   *  Constant: '<S94>/K1'
   */
  /* Level2 S-Function Block: '<S95>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[0];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S97>/S-Function' incorporates:
   *  Constant: '<S96>/K1'
   */
  /* Level2 S-Function Block: '<S97>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[1];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S76>/PWMgen - Averaging' */

  /* SystemInitialize for Enabled SubSystem: '<S77>/Subsystem' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S123>/S-Function' incorporates:
   *  Constant: '<S122>/K1'
   */
  /* Level2 S-Function Block: '<S123>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[2];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S77>/Subsystem' */

  /* SystemInitialize for Enabled SubSystem: '<S82>/Subsystem' */

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S181>/S-Function' incorporates:
   *  Constant: '<S180>/K1'
   */
  /* Level2 S-Function Block: '<S181>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[9];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* End of SystemInitialize for SubSystem: '<S82>/Subsystem' */

  /* SystemInitialize for Enabled SubSystem: '<S284>/Automatic Gain Control' */
  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S296>/S-Function' */
  /* Level2 S-Function Block: '<S296>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[12];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S294>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_hp = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S299>/S-Function' */
  /* Level2 S-Function Block: '<S299>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[13];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* SystemInitialize for Outport: '<S285>/Gain' */
  rtDW.MathFunction = 1.0;

  /* End of SystemInitialize for SubSystem: '<S284>/Automatic Gain Control' */

  /* SystemInitialize for Enabled SubSystem: '<S205>/Automatic Gain Control' */
  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S217>/S-Function' */
  /* Level2 S-Function Block: '<S217>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[10];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* InitializeConditions for UnitDelay: '<S215>/Unit Delay1' */
  rtDW.UnitDelay1_DSTATE_ia = 1.0;

  /* InitializeConditions for S-Function (sfun_discreteVariableDelay): '<S220>/S-Function' */
  /* Level2 S-Function Block: '<S220>/S-Function' (sfun_discreteVariableDelay) */
  {
    SimStruct *rts = rtM->childSfunctions[11];
    sfcnInitializeConditions(rts);
    if (ssGetErrorStatus(rts) != (NULL))
      return;
  }

  /* SystemInitialize for Outport: '<S206>/Gain' */
  rtDW.MathFunction_h = 1.0;

  /* End of SystemInitialize for SubSystem: '<S205>/Automatic Gain Control' */

  /* Enable for Sin: '<S5>/Uref2' */
  rtDW.systemEnable = 1;

  /* Enable for Sin: '<Root>/Vload' */
  rtDW.systemEnable_d = 1;

  /* Enable for Sin: '<S5>/Uref1' */
  rtDW.systemEnable_h = 1;

  /* Enable for Sin: '<S434>/sin(wt)' */
  rtDW.systemEnable_f = 1;

  /* Enable for DiscreteIntegrator: '<S444>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE = 1U;

  /* Enable for Sin: '<S434>/cos(wt)' */
  rtDW.systemEnable_b = 1;

  /* Enable for DiscreteIntegrator: '<S442>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_e = 1U;

  /* Enable for Sin: '<S435>/sin(wt)' */
  rtDW.systemEnable_n = 1;

  /* Enable for DiscreteIntegrator: '<S450>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_c = 1U;

  /* Enable for Sin: '<S435>/cos(wt)' */
  rtDW.systemEnable_c = 1;

  /* Enable for DiscreteIntegrator: '<S448>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i = 1U;

  /* Enable for Sin: '<S436>/sin(wt)' */
  rtDW.systemEnable_a = 1;

  /* Enable for DiscreteIntegrator: '<S456>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n = 1U;

  /* Enable for Sin: '<S436>/cos(wt)' */
  rtDW.systemEnable_di = 1;

  /* Enable for DiscreteIntegrator: '<S454>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k = 1U;

  /* Enable for Sin: '<S458>/sin(wt)' */
  rtDW.systemEnable_fb = 1;

  /* Enable for DiscreteIntegrator: '<S468>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_g = 1U;

  /* Enable for Sin: '<S458>/cos(wt)' */
  rtDW.systemEnable_o = 1;

  /* Enable for DiscreteIntegrator: '<S466>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ex = 1U;

  /* Enable for Sin: '<S459>/sin(wt)' */
  rtDW.systemEnable_p = 1;

  /* Enable for DiscreteIntegrator: '<S474>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kl = 1U;

  /* Enable for Sin: '<S459>/cos(wt)' */
  rtDW.systemEnable_e = 1;

  /* Enable for DiscreteIntegrator: '<S472>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_l = 1U;

  /* Enable for Sin: '<S460>/sin(wt)' */
  rtDW.systemEnable_l = 1;

  /* Enable for DiscreteIntegrator: '<S480>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k2 = 1U;

  /* Enable for Sin: '<S460>/cos(wt)' */
  rtDW.systemEnable_g = 1;

  /* Enable for DiscreteIntegrator: '<S478>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_j = 1U;

  /* Enable for Sin: '<S902>/sin(wt)' */
  rtDW.systemEnable_nr = 1;

  /* Enable for DiscreteIntegrator: '<S912>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o = 1U;

  /* Enable for Sin: '<S902>/cos(wt)' */
  rtDW.systemEnable_nk = 1;

  /* Enable for DiscreteIntegrator: '<S910>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_km = 1U;

  /* Enable for Sin: '<S903>/sin(wt)' */
  rtDW.systemEnable_lm = 1;

  /* Enable for DiscreteIntegrator: '<S918>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_f = 1U;

  /* Enable for Sin: '<S903>/cos(wt)' */
  rtDW.systemEnable_fk = 1;

  /* Enable for DiscreteIntegrator: '<S916>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fy = 1U;

  /* Enable for Sin: '<S904>/sin(wt)' */
  rtDW.systemEnable_es = 1;

  /* Enable for DiscreteIntegrator: '<S924>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_n0 = 1U;

  /* Enable for Sin: '<S904>/cos(wt)' */
  rtDW.systemEnable_eq = 1;

  /* Enable for DiscreteIntegrator: '<S922>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_d = 1U;

  /* Enable for DiscreteIntegrator: '<S410>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a = 1U;

  /* Enable for DiscreteIntegrator: '<S412>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h = 1U;

  /* Enable for DiscreteIntegrator: '<S414>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_m = 1U;

  /* Enable for DiscreteIntegrator: '<S416>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o0 = 1U;

  /* Enable for Sin: '<S418>/sin(wt)' */
  rtDW.systemEnable_m = 1;

  /* Enable for DiscreteIntegrator: '<S424>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_b = 1U;

  /* Enable for Sin: '<S418>/cos(wt)' */
  rtDW.systemEnable_e2 = 1;

  /* Enable for DiscreteIntegrator: '<S422>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_en = 1U;

  /* Enable for Sin: '<S419>/sin(wt)' */
  rtDW.systemEnable_aq = 1;

  /* Enable for DiscreteIntegrator: '<S430>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a3 = 1U;

  /* Enable for Sin: '<S419>/cos(wt)' */
  rtDW.systemEnable_ac = 1;

  /* Enable for DiscreteIntegrator: '<S428>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_kb = 1U;

  /* Enable for Sin: '<S484>/sin(wt)' */
  rtDW.systemEnable_j = 1;

  /* Enable for DiscreteIntegrator: '<S494>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cl = 1U;

  /* Enable for Sin: '<S484>/cos(wt)' */
  rtDW.systemEnable_gz = 1;

  /* Enable for DiscreteIntegrator: '<S492>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i2 = 1U;

  /* Enable for Sin: '<S485>/sin(wt)' */
  rtDW.systemEnable_lb = 1;

  /* Enable for DiscreteIntegrator: '<S500>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bc = 1U;

  /* Enable for Sin: '<S485>/cos(wt)' */
  rtDW.systemEnable_i = 1;

  /* Enable for DiscreteIntegrator: '<S498>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gs = 1U;

  /* Enable for Sin: '<S486>/sin(wt)' */
  rtDW.systemEnable_bk = 1;

  /* Enable for DiscreteIntegrator: '<S506>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jz = 1U;

  /* Enable for Sin: '<S486>/cos(wt)' */
  rtDW.systemEnable_oz = 1;

  /* Enable for DiscreteIntegrator: '<S504>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bm = 1U;

  /* Enable for Sin: '<S508>/sin(wt)' */
  rtDW.systemEnable_cd = 1;

  /* Enable for DiscreteIntegrator: '<S518>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ke = 1U;

  /* Enable for Sin: '<S508>/cos(wt)' */
  rtDW.systemEnable_jg = 1;

  /* Enable for DiscreteIntegrator: '<S516>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oh = 1U;

  /* Enable for Sin: '<S509>/sin(wt)' */
  rtDW.systemEnable_av = 1;

  /* Enable for DiscreteIntegrator: '<S524>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_lx = 1U;

  /* Enable for Sin: '<S509>/cos(wt)' */
  rtDW.systemEnable_oh = 1;

  /* Enable for DiscreteIntegrator: '<S522>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_of = 1U;

  /* Enable for Sin: '<S510>/sin(wt)' */
  rtDW.systemEnable_bn = 1;

  /* Enable for DiscreteIntegrator: '<S530>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_p = 1U;

  /* Enable for Sin: '<S510>/cos(wt)' */
  rtDW.systemEnable_na = 1;

  /* Enable for DiscreteIntegrator: '<S528>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_on = 1U;

  /* Enable for DiscreteIntegrator: '<S280>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ei = 1U;

  /* Enable for DiscreteIntegrator: '<S310>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nm = 1U;

  /* Enable for DiscreteIntegrator: '<S231>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nr = 1U;

  /* Enable for DiscreteIntegrator: '<S546>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_o3 = 1U;

  /* Enable for Sin: '<S614>/cos(wt)' */
  rtDW.systemEnable_bz = 1;

  /* Enable for DiscreteIntegrator: '<S622>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_og = 1U;

  /* Enable for Sin: '<S614>/sin(wt)' */
  rtDW.systemEnable_e5 = 1;

  /* Enable for DiscreteIntegrator: '<S624>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gy = 1U;

  /* Enable for Sin: '<S615>/cos(wt)' */
  rtDW.systemEnable_bj = 1;

  /* Enable for DiscreteIntegrator: '<S628>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_nt = 1U;

  /* Enable for Sin: '<S615>/sin(wt)' */
  rtDW.systemEnable_dif = 1;

  /* Enable for DiscreteIntegrator: '<S630>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ax = 1U;

  /* Enable for Sin: '<S616>/cos(wt)' */
  rtDW.systemEnable_k = 1;

  /* Enable for DiscreteIntegrator: '<S634>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ob = 1U;

  /* Enable for Sin: '<S616>/sin(wt)' */
  rtDW.systemEnable_go = 1;

  /* Enable for DiscreteIntegrator: '<S636>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pc = 1U;

  /* Enable for Sin: '<S638>/cos(wt)' */
  rtDW.systemEnable_fq = 1;

  /* Enable for DiscreteIntegrator: '<S646>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ka = 1U;

  /* Enable for Sin: '<S638>/sin(wt)' */
  rtDW.systemEnable_kf = 1;

  /* Enable for DiscreteIntegrator: '<S648>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ft = 1U;

  /* Enable for Sin: '<S639>/cos(wt)' */
  rtDW.systemEnable_ip = 1;

  /* Enable for DiscreteIntegrator: '<S652>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_js = 1U;

  /* Enable for Sin: '<S639>/sin(wt)' */
  rtDW.systemEnable_g1 = 1;

  /* Enable for DiscreteIntegrator: '<S654>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jw = 1U;

  /* Enable for Sin: '<S640>/cos(wt)' */
  rtDW.systemEnable_e3 = 1;

  /* Enable for DiscreteIntegrator: '<S658>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_h5 = 1U;

  /* Enable for Sin: '<S640>/sin(wt)' */
  rtDW.systemEnable_bl = 1;

  /* Enable for DiscreteIntegrator: '<S660>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_k5 = 1U;

  /* Enable for Sin: '<S548>/cos(wt)' */
  rtDW.systemEnable_pz = 1;

  /* Enable for DiscreteIntegrator: '<S552>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bj = 1U;

  /* Enable for Sin: '<S548>/sin(wt)' */
  rtDW.systemEnable_avi = 1;

  /* Enable for DiscreteIntegrator: '<S554>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ba = 1U;

  /* Enable for Sin: '<S549>/cos(wt)' */
  rtDW.systemEnable_ci = 1;

  /* Enable for DiscreteIntegrator: '<S558>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_gl = 1U;

  /* Enable for Sin: '<S549>/sin(wt)' */
  rtDW.systemEnable_bj1 = 1;

  /* Enable for DiscreteIntegrator: '<S560>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fs = 1U;

  /* Enable for Sin: '<S564>/cos(wt)' */
  rtDW.systemEnable_co = 1;

  /* Enable for DiscreteIntegrator: '<S572>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cm = 1U;

  /* Enable for Sin: '<S564>/sin(wt)' */
  rtDW.systemEnable_pd = 1;

  /* Enable for DiscreteIntegrator: '<S574>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_cc = 1U;

  /* Enable for Sin: '<S565>/cos(wt)' */
  rtDW.systemEnable_i2 = 1;

  /* Enable for DiscreteIntegrator: '<S578>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ix = 1U;

  /* Enable for Sin: '<S565>/sin(wt)' */
  rtDW.systemEnable_ov = 1;

  /* Enable for DiscreteIntegrator: '<S580>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_jo = 1U;

  /* Enable for Sin: '<S566>/cos(wt)' */
  rtDW.systemEnable_mj = 1;

  /* Enable for DiscreteIntegrator: '<S584>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bu = 1U;

  /* Enable for Sin: '<S566>/sin(wt)' */
  rtDW.systemEnable_nf = 1;

  /* Enable for DiscreteIntegrator: '<S586>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i0 = 1U;

  /* Enable for Sin: '<S588>/cos(wt)' */
  rtDW.systemEnable_mx = 1;

  /* Enable for DiscreteIntegrator: '<S596>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_af = 1U;

  /* Enable for Sin: '<S588>/sin(wt)' */
  rtDW.systemEnable_mx0 = 1;

  /* Enable for DiscreteIntegrator: '<S598>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ks = 1U;

  /* Enable for Sin: '<S589>/cos(wt)' */
  rtDW.systemEnable_gl = 1;

  /* Enable for DiscreteIntegrator: '<S602>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_fu = 1U;

  /* Enable for Sin: '<S589>/sin(wt)' */
  rtDW.systemEnable_df = 1;

  /* Enable for DiscreteIntegrator: '<S604>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ns = 1U;

  /* Enable for Sin: '<S590>/cos(wt)' */
  rtDW.systemEnable_h1 = 1;

  /* Enable for DiscreteIntegrator: '<S608>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_or = 1U;

  /* Enable for Sin: '<S590>/sin(wt)' */
  rtDW.systemEnable_iv = 1;

  /* Enable for DiscreteIntegrator: '<S610>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_a0 = 1U;

  /* Enable for Sin: '<S662>/cos(wt)' */
  rtDW.systemEnable_jo = 1;

  /* Enable for DiscreteIntegrator: '<S670>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ic = 1U;

  /* Enable for Sin: '<S662>/sin(wt)' */
  rtDW.systemEnable_fh = 1;

  /* Enable for DiscreteIntegrator: '<S672>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bz = 1U;

  /* Enable for Sin: '<S663>/cos(wt)' */
  rtDW.systemEnable_lo = 1;

  /* Enable for DiscreteIntegrator: '<S676>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ds = 1U;

  /* Enable for Sin: '<S663>/sin(wt)' */
  rtDW.systemEnable_jc = 1;

  /* Enable for DiscreteIntegrator: '<S678>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_ow = 1U;

  /* Enable for Sin: '<S664>/cos(wt)' */
  rtDW.systemEnable_pq = 1;

  /* Enable for DiscreteIntegrator: '<S682>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_i1 = 1U;

  /* Enable for Sin: '<S664>/sin(wt)' */
  rtDW.systemEnable_n5 = 1;

  /* Enable for DiscreteIntegrator: '<S684>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_oo = 1U;

  /* Enable for DiscreteIntegrator: '<S544>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_co = 1U;

  /* Enable for DiscreteIntegrator: '<S540>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_pb = 1U;

  /* Enable for DiscreteIntegrator: '<S542>/Integ4' */
  rtDW.Integ4_SYSTEM_ENABLE_bzw = 1U;
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
